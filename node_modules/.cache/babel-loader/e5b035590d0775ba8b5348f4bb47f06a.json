{"ast":null,"code":"/* Generated by `npm run build`, do not edit! */\n\"use strict\";\n\nvar acorn = require(\"acorn\");\n\nvar tt = acorn.tokTypes;\n\nvar privateClassElements = require(\"../private-class-elements\");\n\nfunction maybeParseFieldValue(field) {\n  if (this.eat(tt.eq)) {\n    var oldInFieldValue = this._inFieldValue;\n    this._inFieldValue = true;\n    field.value = this.parseExpression();\n    this._inFieldValue = oldInFieldValue;\n  } else {\n    field.value = null;\n  }\n}\n\nmodule.exports = function (Parser) {\n  Parser = privateClassElements(Parser);\n  return (\n    /*@__PURE__*/\n    function (Parser) {\n      function anonymous() {\n        Parser.apply(this, arguments);\n      }\n\n      if (Parser) anonymous.__proto__ = Parser;\n      anonymous.prototype = Object.create(Parser && Parser.prototype);\n      anonymous.prototype.constructor = anonymous;\n\n      anonymous.prototype.parseClassElement = function parseClassElement(_constructorAllowsSuper) {\n        if (this.options.ecmaVersion >= 8 && (this.type == tt.name || this.type == this.privateNameToken || this.type == tt.bracketL || this.type == tt.string)) {\n          var branch = this._branch();\n\n          if (branch.type == tt.bracketL) {\n            var count = 0;\n\n            do {\n              if (branch.eat(tt.bracketL)) {\n                ++count;\n              } else if (branch.eat(tt.bracketR)) {\n                --count;\n              } else {\n                branch.next();\n              }\n            } while (count > 0);\n          } else {\n            branch.next();\n          }\n\n          if (branch.type == tt.eq || branch.canInsertSemicolon() || branch.type == tt.semi) {\n            var node = this.startNode();\n\n            if (this.type == this.privateNameToken) {\n              this.parsePrivateClassElementName(node);\n            } else {\n              this.parsePropertyName(node);\n            }\n\n            if (node.key.type === \"Identifier\" && node.key.name === \"constructor\" || node.key.type === \"Literal\" && node.key.value === \"constructor\") {\n              this.raise(node.key.start, \"Classes may not have a field called constructor\");\n            }\n\n            maybeParseFieldValue.call(this, node);\n            this.finishNode(node, \"FieldDefinition\");\n            this.semicolon();\n            return node;\n          }\n        }\n\n        return Parser.prototype.parseClassElement.apply(this, arguments);\n      }; // Prohibit arguments in class field initializers\n\n\n      anonymous.prototype.parseIdent = function parseIdent(liberal, isBinding) {\n        var ident = Parser.prototype.parseIdent.call(this, liberal, isBinding);\n\n        if (this._inFieldValue && ident.name == \"arguments\") {\n          this.raise(ident.start, \"A class field initializer may not contain arguments\");\n        }\n\n        return ident;\n      };\n\n      return anonymous;\n    }(Parser)\n  );\n};","map":{"version":3,"sources":["/home/yanxiaoyang/react-project/PersonalWebsiteTest/node_modules/acorn-node/lib/class-fields/index.js"],"names":["acorn","require","tt","tokTypes","privateClassElements","maybeParseFieldValue","field","eat","eq","oldInFieldValue","_inFieldValue","value","parseExpression","module","exports","Parser","anonymous","apply","arguments","__proto__","prototype","Object","create","constructor","parseClassElement","_constructorAllowsSuper","options","ecmaVersion","type","name","privateNameToken","bracketL","string","branch","_branch","count","bracketR","next","canInsertSemicolon","semi","node","startNode","parsePrivateClassElementName","parsePropertyName","key","raise","start","call","finishNode","semicolon","parseIdent","liberal","isBinding","ident"],"mappings":"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","sourcesContent":["/* Generated by `npm run build`, do not edit! */\n\n\"use strict\"\n\nvar acorn = require(\"acorn\")\nvar tt = acorn.tokTypes\nvar privateClassElements = require(\"../private-class-elements\")\n\nfunction maybeParseFieldValue(field) {\n  if (this.eat(tt.eq)) {\n    var oldInFieldValue = this._inFieldValue\n    this._inFieldValue = true\n    field.value = this.parseExpression()\n    this._inFieldValue = oldInFieldValue\n  } else { field.value = null }\n}\n\nmodule.exports = function(Parser) {\n  Parser = privateClassElements(Parser)\n  return /*@__PURE__*/(function (Parser) {\n    function anonymous () {\n      Parser.apply(this, arguments);\n    }\n\n    if ( Parser ) anonymous.__proto__ = Parser;\n    anonymous.prototype = Object.create( Parser && Parser.prototype );\n    anonymous.prototype.constructor = anonymous;\n\n    anonymous.prototype.parseClassElement = function parseClassElement (_constructorAllowsSuper) {\n      if (this.options.ecmaVersion >= 8 && (this.type == tt.name || this.type == this.privateNameToken || this.type == tt.bracketL || this.type == tt.string)) {\n        var branch = this._branch()\n        if (branch.type == tt.bracketL) {\n          var count = 0\n          do {\n            if (branch.eat(tt.bracketL)) { ++count }\n            else if (branch.eat(tt.bracketR)) { --count }\n            else { branch.next() }\n          } while (count > 0)\n        } else { branch.next() }\n        if (branch.type == tt.eq || branch.canInsertSemicolon() || branch.type == tt.semi) {\n          var node = this.startNode()\n          if (this.type == this.privateNameToken) {\n            this.parsePrivateClassElementName(node)\n          } else {\n            this.parsePropertyName(node)\n          }\n          if ((node.key.type === \"Identifier\" && node.key.name === \"constructor\") ||\n              (node.key.type === \"Literal\" && node.key.value === \"constructor\")) {\n            this.raise(node.key.start, \"Classes may not have a field called constructor\")\n          }\n          maybeParseFieldValue.call(this, node)\n          this.finishNode(node, \"FieldDefinition\")\n          this.semicolon()\n          return node\n        }\n      }\n\n      return Parser.prototype.parseClassElement.apply(this, arguments)\n    };\n\n    // Prohibit arguments in class field initializers\n    anonymous.prototype.parseIdent = function parseIdent (liberal, isBinding) {\n      var ident = Parser.prototype.parseIdent.call(this, liberal, isBinding)\n      if (this._inFieldValue && ident.name == \"arguments\") { this.raise(ident.start, \"A class field initializer may not contain arguments\") }\n      return ident\n    };\n\n    return anonymous;\n  }(Parser))\n}\n"]},"metadata":{},"sourceType":"script"}