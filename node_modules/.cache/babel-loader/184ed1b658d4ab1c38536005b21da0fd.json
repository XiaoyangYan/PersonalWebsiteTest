{"ast":null,"code":"// A bit simpler than readable streams.\n// Implement an async ._write(chunk, encoding, cb), and it'll handle all\n// the drain event emission and buffering.\n'use strict';\n\nmodule.exports = Writable;\n/*<replacement>*/\n\nvar processNextTick = require('process-nextick-args');\n/*</replacement>*/\n\n/*<replacement>*/\n\n\nvar asyncWrite = !process.browser && ['v0.10', 'v0.9.'].indexOf(process.version.slice(0, 5)) > -1 ? setImmediate : processNextTick;\n/*</replacement>*/\n\n/*<replacement>*/\n\nvar Buffer = require('buffer').Buffer;\n/*</replacement>*/\n\n\nWritable.WritableState = WritableState;\n/*<replacement>*/\n\nvar util = require('core-util-is');\n\nutil.inherits = require('inherits');\n/*</replacement>*/\n\n/*<replacement>*/\n\nvar internalUtil = {\n  deprecate: require('util-deprecate')\n};\n/*</replacement>*/\n\n/*<replacement>*/\n\nvar Stream;\n\n(function () {\n  try {\n    Stream = require('st' + 'ream');\n  } catch (_) {} finally {\n    if (!Stream) Stream = require('events').EventEmitter;\n  }\n})();\n/*</replacement>*/\n\n\nvar Buffer = require('buffer').Buffer;\n\nutil.inherits(Writable, Stream);\n\nfunction nop() {}\n\nfunction WriteReq(chunk, encoding, cb) {\n  this.chunk = chunk;\n  this.encoding = encoding;\n  this.callback = cb;\n  this.next = null;\n}\n\nvar Duplex;\n\nfunction WritableState(options, stream) {\n  Duplex = Duplex || require('./_stream_duplex');\n  options = options || {}; // object stream flag to indicate whether or not this stream\n  // contains buffers or objects.\n\n  this.objectMode = !!options.objectMode;\n  if (stream instanceof Duplex) this.objectMode = this.objectMode || !!options.writableObjectMode; // the point at which write() starts returning false\n  // Note: 0 is a valid value, means that we always return false if\n  // the entire buffer is not flushed immediately on write()\n\n  var hwm = options.highWaterMark;\n  var defaultHwm = this.objectMode ? 16 : 16 * 1024;\n  this.highWaterMark = hwm || hwm === 0 ? hwm : defaultHwm; // cast to ints.\n\n  this.highWaterMark = ~~this.highWaterMark;\n  this.needDrain = false; // at the start of calling end()\n\n  this.ending = false; // when end() has been called, and returned\n\n  this.ended = false; // when 'finish' is emitted\n\n  this.finished = false; // should we decode strings into buffers before passing to _write?\n  // this is here so that some node-core streams can optimize string\n  // handling at a lower level.\n\n  var noDecode = options.decodeStrings === false;\n  this.decodeStrings = !noDecode; // Crypto is kind of old and crusty.  Historically, its default string\n  // encoding is 'binary' so we have to make this configurable.\n  // Everything else in the universe uses 'utf8', though.\n\n  this.defaultEncoding = options.defaultEncoding || 'utf8'; // not an actual buffer we keep track of, but a measurement\n  // of how much we're waiting to get pushed to some underlying\n  // socket or file.\n\n  this.length = 0; // a flag to see when we're in the middle of a write.\n\n  this.writing = false; // when true all writes will be buffered until .uncork() call\n\n  this.corked = 0; // a flag to be able to tell if the onwrite cb is called immediately,\n  // or on a later tick.  We set this to true at first, because any\n  // actions that shouldn't happen until \"later\" should generally also\n  // not happen before the first write call.\n\n  this.sync = true; // a flag to know if we're processing previously buffered items, which\n  // may call the _write() callback in the same tick, so that we don't\n  // end up in an overlapped onwrite situation.\n\n  this.bufferProcessing = false; // the callback that's passed to _write(chunk,cb)\n\n  this.onwrite = function (er) {\n    onwrite(stream, er);\n  }; // the callback that the user supplies to write(chunk,encoding,cb)\n\n\n  this.writecb = null; // the amount that is being written when _write is called.\n\n  this.writelen = 0;\n  this.bufferedRequest = null;\n  this.lastBufferedRequest = null; // number of pending user-supplied write callbacks\n  // this must be 0 before 'finish' can be emitted\n\n  this.pendingcb = 0; // emit prefinish if the only thing we're waiting for is _write cbs\n  // This is relevant for synchronous Transform streams\n\n  this.prefinished = false; // True if the error was already emitted and should not be thrown again\n\n  this.errorEmitted = false; // count buffered requests\n\n  this.bufferedRequestCount = 0; // create the two objects needed to store the corked requests\n  // they are not a linked list, as no new elements are inserted in there\n\n  this.corkedRequestsFree = new CorkedRequest(this);\n  this.corkedRequestsFree.next = new CorkedRequest(this);\n}\n\nWritableState.prototype.getBuffer = function writableStateGetBuffer() {\n  var current = this.bufferedRequest;\n  var out = [];\n\n  while (current) {\n    out.push(current);\n    current = current.next;\n  }\n\n  return out;\n};\n\n(function () {\n  try {\n    Object.defineProperty(WritableState.prototype, 'buffer', {\n      get: internalUtil.deprecate(function () {\n        return this.getBuffer();\n      }, '_writableState.buffer is deprecated. Use _writableState.getBuffer ' + 'instead.')\n    });\n  } catch (_) {}\n})();\n\nvar Duplex;\n\nfunction Writable(options) {\n  Duplex = Duplex || require('./_stream_duplex'); // Writable ctor is applied to Duplexes, though they're not\n  // instanceof Writable, they're instanceof Readable.\n\n  if (!(this instanceof Writable) && !(this instanceof Duplex)) return new Writable(options);\n  this._writableState = new WritableState(options, this); // legacy.\n\n  this.writable = true;\n\n  if (options) {\n    if (typeof options.write === 'function') this._write = options.write;\n    if (typeof options.writev === 'function') this._writev = options.writev;\n  }\n\n  Stream.call(this);\n} // Otherwise people can pipe Writable streams, which is just wrong.\n\n\nWritable.prototype.pipe = function () {\n  this.emit('error', new Error('Cannot pipe. Not readable.'));\n};\n\nfunction writeAfterEnd(stream, cb) {\n  var er = new Error('write after end'); // TODO: defer error events consistently everywhere, not just the cb\n\n  stream.emit('error', er);\n  processNextTick(cb, er);\n} // If we get something that is not a buffer, string, null, or undefined,\n// and we're not in objectMode, then that's an error.\n// Otherwise stream chunks are all considered to be of length=1, and the\n// watermarks determine how many objects to keep in the buffer, rather than\n// how many bytes or characters.\n\n\nfunction validChunk(stream, state, chunk, cb) {\n  var valid = true;\n\n  if (!Buffer.isBuffer(chunk) && typeof chunk !== 'string' && chunk !== null && chunk !== undefined && !state.objectMode) {\n    var er = new TypeError('Invalid non-string/buffer chunk');\n    stream.emit('error', er);\n    processNextTick(cb, er);\n    valid = false;\n  }\n\n  return valid;\n}\n\nWritable.prototype.write = function (chunk, encoding, cb) {\n  var state = this._writableState;\n  var ret = false;\n\n  if (typeof encoding === 'function') {\n    cb = encoding;\n    encoding = null;\n  }\n\n  if (Buffer.isBuffer(chunk)) encoding = 'buffer';else if (!encoding) encoding = state.defaultEncoding;\n  if (typeof cb !== 'function') cb = nop;\n  if (state.ended) writeAfterEnd(this, cb);else if (validChunk(this, state, chunk, cb)) {\n    state.pendingcb++;\n    ret = writeOrBuffer(this, state, chunk, encoding, cb);\n  }\n  return ret;\n};\n\nWritable.prototype.cork = function () {\n  var state = this._writableState;\n  state.corked++;\n};\n\nWritable.prototype.uncork = function () {\n  var state = this._writableState;\n\n  if (state.corked) {\n    state.corked--;\n    if (!state.writing && !state.corked && !state.finished && !state.bufferProcessing && state.bufferedRequest) clearBuffer(this, state);\n  }\n};\n\nWritable.prototype.setDefaultEncoding = function setDefaultEncoding(encoding) {\n  // node::ParseEncoding() requires lower case.\n  if (typeof encoding === 'string') encoding = encoding.toLowerCase();\n  if (!(['hex', 'utf8', 'utf-8', 'ascii', 'binary', 'base64', 'ucs2', 'ucs-2', 'utf16le', 'utf-16le', 'raw'].indexOf((encoding + '').toLowerCase()) > -1)) throw new TypeError('Unknown encoding: ' + encoding);\n  this._writableState.defaultEncoding = encoding;\n};\n\nfunction decodeChunk(state, chunk, encoding) {\n  if (!state.objectMode && state.decodeStrings !== false && typeof chunk === 'string') {\n    chunk = new Buffer(chunk, encoding);\n  }\n\n  return chunk;\n} // if we're already writing something, then just put this\n// in the queue, and wait our turn.  Otherwise, call _write\n// If we return false, then we need a drain event, so set that flag.\n\n\nfunction writeOrBuffer(stream, state, chunk, encoding, cb) {\n  chunk = decodeChunk(state, chunk, encoding);\n  if (Buffer.isBuffer(chunk)) encoding = 'buffer';\n  var len = state.objectMode ? 1 : chunk.length;\n  state.length += len;\n  var ret = state.length < state.highWaterMark; // we must ensure that previous needDrain will not be reset to false.\n\n  if (!ret) state.needDrain = true;\n\n  if (state.writing || state.corked) {\n    var last = state.lastBufferedRequest;\n    state.lastBufferedRequest = new WriteReq(chunk, encoding, cb);\n\n    if (last) {\n      last.next = state.lastBufferedRequest;\n    } else {\n      state.bufferedRequest = state.lastBufferedRequest;\n    }\n\n    state.bufferedRequestCount += 1;\n  } else {\n    doWrite(stream, state, false, len, chunk, encoding, cb);\n  }\n\n  return ret;\n}\n\nfunction doWrite(stream, state, writev, len, chunk, encoding, cb) {\n  state.writelen = len;\n  state.writecb = cb;\n  state.writing = true;\n  state.sync = true;\n  if (writev) stream._writev(chunk, state.onwrite);else stream._write(chunk, encoding, state.onwrite);\n  state.sync = false;\n}\n\nfunction onwriteError(stream, state, sync, er, cb) {\n  --state.pendingcb;\n  if (sync) processNextTick(cb, er);else cb(er);\n  stream._writableState.errorEmitted = true;\n  stream.emit('error', er);\n}\n\nfunction onwriteStateUpdate(state) {\n  state.writing = false;\n  state.writecb = null;\n  state.length -= state.writelen;\n  state.writelen = 0;\n}\n\nfunction onwrite(stream, er) {\n  var state = stream._writableState;\n  var sync = state.sync;\n  var cb = state.writecb;\n  onwriteStateUpdate(state);\n  if (er) onwriteError(stream, state, sync, er, cb);else {\n    // Check if we're actually ready to finish, but don't emit yet\n    var finished = needFinish(state);\n\n    if (!finished && !state.corked && !state.bufferProcessing && state.bufferedRequest) {\n      clearBuffer(stream, state);\n    }\n\n    if (sync) {\n      /*<replacement>*/\n      asyncWrite(afterWrite, stream, state, finished, cb);\n      /*</replacement>*/\n    } else {\n      afterWrite(stream, state, finished, cb);\n    }\n  }\n}\n\nfunction afterWrite(stream, state, finished, cb) {\n  if (!finished) onwriteDrain(stream, state);\n  state.pendingcb--;\n  cb();\n  finishMaybe(stream, state);\n} // Must force callback to be called on nextTick, so that we don't\n// emit 'drain' before the write() consumer gets the 'false' return\n// value, and has a chance to attach a 'drain' listener.\n\n\nfunction onwriteDrain(stream, state) {\n  if (state.length === 0 && state.needDrain) {\n    state.needDrain = false;\n    stream.emit('drain');\n  }\n} // if there's something in the buffer waiting, then process it\n\n\nfunction clearBuffer(stream, state) {\n  state.bufferProcessing = true;\n  var entry = state.bufferedRequest;\n\n  if (stream._writev && entry && entry.next) {\n    // Fast case, write everything using _writev()\n    var l = state.bufferedRequestCount;\n    var buffer = new Array(l);\n    var holder = state.corkedRequestsFree;\n    holder.entry = entry;\n    var count = 0;\n\n    while (entry) {\n      buffer[count] = entry;\n      entry = entry.next;\n      count += 1;\n    }\n\n    doWrite(stream, state, true, state.length, buffer, '', holder.finish); // doWrite is always async, defer these to save a bit of time\n    // as the hot path ends with doWrite\n\n    state.pendingcb++;\n    state.lastBufferedRequest = null;\n    state.corkedRequestsFree = holder.next;\n    holder.next = null;\n  } else {\n    // Slow case, write chunks one-by-one\n    while (entry) {\n      var chunk = entry.chunk;\n      var encoding = entry.encoding;\n      var cb = entry.callback;\n      var len = state.objectMode ? 1 : chunk.length;\n      doWrite(stream, state, false, len, chunk, encoding, cb);\n      entry = entry.next; // if we didn't call the onwrite immediately, then\n      // it means that we need to wait until it does.\n      // also, that means that the chunk and cb are currently\n      // being processed, so move the buffer counter past them.\n\n      if (state.writing) {\n        break;\n      }\n    }\n\n    if (entry === null) state.lastBufferedRequest = null;\n  }\n\n  state.bufferedRequestCount = 0;\n  state.bufferedRequest = entry;\n  state.bufferProcessing = false;\n}\n\nWritable.prototype._write = function (chunk, encoding, cb) {\n  cb(new Error('not implemented'));\n};\n\nWritable.prototype._writev = null;\n\nWritable.prototype.end = function (chunk, encoding, cb) {\n  var state = this._writableState;\n\n  if (typeof chunk === 'function') {\n    cb = chunk;\n    chunk = null;\n    encoding = null;\n  } else if (typeof encoding === 'function') {\n    cb = encoding;\n    encoding = null;\n  }\n\n  if (chunk !== null && chunk !== undefined) this.write(chunk, encoding); // .end() fully uncorks\n\n  if (state.corked) {\n    state.corked = 1;\n    this.uncork();\n  } // ignore unnecessary end() calls.\n\n\n  if (!state.ending && !state.finished) endWritable(this, state, cb);\n};\n\nfunction needFinish(state) {\n  return state.ending && state.length === 0 && state.bufferedRequest === null && !state.finished && !state.writing;\n}\n\nfunction prefinish(stream, state) {\n  if (!state.prefinished) {\n    state.prefinished = true;\n    stream.emit('prefinish');\n  }\n}\n\nfunction finishMaybe(stream, state) {\n  var need = needFinish(state);\n\n  if (need) {\n    if (state.pendingcb === 0) {\n      prefinish(stream, state);\n      state.finished = true;\n      stream.emit('finish');\n    } else {\n      prefinish(stream, state);\n    }\n  }\n\n  return need;\n}\n\nfunction endWritable(stream, state, cb) {\n  state.ending = true;\n  finishMaybe(stream, state);\n\n  if (cb) {\n    if (state.finished) processNextTick(cb);else stream.once('finish', cb);\n  }\n\n  state.ended = true;\n  stream.writable = false;\n} // It seems a linked list but it is not\n// there will be only 2 of these for each stream\n\n\nfunction CorkedRequest(state) {\n  var _this = this;\n\n  this.next = null;\n  this.entry = null;\n\n  this.finish = function (err) {\n    var entry = _this.entry;\n    _this.entry = null;\n\n    while (entry) {\n      var cb = entry.callback;\n      state.pendingcb--;\n      cb(err);\n      entry = entry.next;\n    }\n\n    if (state.corkedRequestsFree) {\n      state.corkedRequestsFree.next = _this;\n    } else {\n      state.corkedRequestsFree = _this;\n    }\n  };\n}","map":{"version":3,"sources":["/home/yanxiaoyang/react-project/PersonalWebsiteTest/node_modules/browserify/node_modules/concat-stream/node_modules/readable-stream/lib/_stream_writable.js"],"names":["module","exports","Writable","processNextTick","require","asyncWrite","process","browser","indexOf","version","slice","setImmediate","Buffer","WritableState","util","inherits","internalUtil","deprecate","Stream","_","EventEmitter","nop","WriteReq","chunk","encoding","cb","callback","next","Duplex","options","stream","objectMode","writableObjectMode","hwm","highWaterMark","defaultHwm","needDrain","ending","ended","finished","noDecode","decodeStrings","defaultEncoding","length","writing","corked","sync","bufferProcessing","onwrite","er","writecb","writelen","bufferedRequest","lastBufferedRequest","pendingcb","prefinished","errorEmitted","bufferedRequestCount","corkedRequestsFree","CorkedRequest","prototype","getBuffer","writableStateGetBuffer","current","out","push","Object","defineProperty","get","_writableState","writable","write","_write","writev","_writev","call","pipe","emit","Error","writeAfterEnd","validChunk","state","valid","isBuffer","undefined","TypeError","ret","writeOrBuffer","cork","uncork","clearBuffer","setDefaultEncoding","toLowerCase","decodeChunk","len","last","doWrite","onwriteError","onwriteStateUpdate","needFinish","afterWrite","onwriteDrain","finishMaybe","entry","l","buffer","Array","holder","count","finish","end","endWritable","prefinish","need","once","_this","err"],"mappings":"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","sourcesContent":["// A bit simpler than readable streams.\n// Implement an async ._write(chunk, encoding, cb), and it'll handle all\n// the drain event emission and buffering.\n\n'use strict';\n\nmodule.exports = Writable;\n\n/*<replacement>*/\nvar processNextTick = require('process-nextick-args');\n/*</replacement>*/\n\n/*<replacement>*/\nvar asyncWrite = !process.browser && ['v0.10', 'v0.9.'].indexOf(process.version.slice(0, 5)) > -1 ? setImmediate : processNextTick;\n/*</replacement>*/\n\n/*<replacement>*/\nvar Buffer = require('buffer').Buffer;\n/*</replacement>*/\n\nWritable.WritableState = WritableState;\n\n/*<replacement>*/\nvar util = require('core-util-is');\nutil.inherits = require('inherits');\n/*</replacement>*/\n\n/*<replacement>*/\nvar internalUtil = {\n  deprecate: require('util-deprecate')\n};\n/*</replacement>*/\n\n/*<replacement>*/\nvar Stream;\n(function () {\n  try {\n    Stream = require('st' + 'ream');\n  } catch (_) {} finally {\n    if (!Stream) Stream = require('events').EventEmitter;\n  }\n})();\n/*</replacement>*/\n\nvar Buffer = require('buffer').Buffer;\n\nutil.inherits(Writable, Stream);\n\nfunction nop() {}\n\nfunction WriteReq(chunk, encoding, cb) {\n  this.chunk = chunk;\n  this.encoding = encoding;\n  this.callback = cb;\n  this.next = null;\n}\n\nvar Duplex;\nfunction WritableState(options, stream) {\n  Duplex = Duplex || require('./_stream_duplex');\n\n  options = options || {};\n\n  // object stream flag to indicate whether or not this stream\n  // contains buffers or objects.\n  this.objectMode = !!options.objectMode;\n\n  if (stream instanceof Duplex) this.objectMode = this.objectMode || !!options.writableObjectMode;\n\n  // the point at which write() starts returning false\n  // Note: 0 is a valid value, means that we always return false if\n  // the entire buffer is not flushed immediately on write()\n  var hwm = options.highWaterMark;\n  var defaultHwm = this.objectMode ? 16 : 16 * 1024;\n  this.highWaterMark = hwm || hwm === 0 ? hwm : defaultHwm;\n\n  // cast to ints.\n  this.highWaterMark = ~ ~this.highWaterMark;\n\n  this.needDrain = false;\n  // at the start of calling end()\n  this.ending = false;\n  // when end() has been called, and returned\n  this.ended = false;\n  // when 'finish' is emitted\n  this.finished = false;\n\n  // should we decode strings into buffers before passing to _write?\n  // this is here so that some node-core streams can optimize string\n  // handling at a lower level.\n  var noDecode = options.decodeStrings === false;\n  this.decodeStrings = !noDecode;\n\n  // Crypto is kind of old and crusty.  Historically, its default string\n  // encoding is 'binary' so we have to make this configurable.\n  // Everything else in the universe uses 'utf8', though.\n  this.defaultEncoding = options.defaultEncoding || 'utf8';\n\n  // not an actual buffer we keep track of, but a measurement\n  // of how much we're waiting to get pushed to some underlying\n  // socket or file.\n  this.length = 0;\n\n  // a flag to see when we're in the middle of a write.\n  this.writing = false;\n\n  // when true all writes will be buffered until .uncork() call\n  this.corked = 0;\n\n  // a flag to be able to tell if the onwrite cb is called immediately,\n  // or on a later tick.  We set this to true at first, because any\n  // actions that shouldn't happen until \"later\" should generally also\n  // not happen before the first write call.\n  this.sync = true;\n\n  // a flag to know if we're processing previously buffered items, which\n  // may call the _write() callback in the same tick, so that we don't\n  // end up in an overlapped onwrite situation.\n  this.bufferProcessing = false;\n\n  // the callback that's passed to _write(chunk,cb)\n  this.onwrite = function (er) {\n    onwrite(stream, er);\n  };\n\n  // the callback that the user supplies to write(chunk,encoding,cb)\n  this.writecb = null;\n\n  // the amount that is being written when _write is called.\n  this.writelen = 0;\n\n  this.bufferedRequest = null;\n  this.lastBufferedRequest = null;\n\n  // number of pending user-supplied write callbacks\n  // this must be 0 before 'finish' can be emitted\n  this.pendingcb = 0;\n\n  // emit prefinish if the only thing we're waiting for is _write cbs\n  // This is relevant for synchronous Transform streams\n  this.prefinished = false;\n\n  // True if the error was already emitted and should not be thrown again\n  this.errorEmitted = false;\n\n  // count buffered requests\n  this.bufferedRequestCount = 0;\n\n  // create the two objects needed to store the corked requests\n  // they are not a linked list, as no new elements are inserted in there\n  this.corkedRequestsFree = new CorkedRequest(this);\n  this.corkedRequestsFree.next = new CorkedRequest(this);\n}\n\nWritableState.prototype.getBuffer = function writableStateGetBuffer() {\n  var current = this.bufferedRequest;\n  var out = [];\n  while (current) {\n    out.push(current);\n    current = current.next;\n  }\n  return out;\n};\n\n(function () {\n  try {\n    Object.defineProperty(WritableState.prototype, 'buffer', {\n      get: internalUtil.deprecate(function () {\n        return this.getBuffer();\n      }, '_writableState.buffer is deprecated. Use _writableState.getBuffer ' + 'instead.')\n    });\n  } catch (_) {}\n})();\n\nvar Duplex;\nfunction Writable(options) {\n  Duplex = Duplex || require('./_stream_duplex');\n\n  // Writable ctor is applied to Duplexes, though they're not\n  // instanceof Writable, they're instanceof Readable.\n  if (!(this instanceof Writable) && !(this instanceof Duplex)) return new Writable(options);\n\n  this._writableState = new WritableState(options, this);\n\n  // legacy.\n  this.writable = true;\n\n  if (options) {\n    if (typeof options.write === 'function') this._write = options.write;\n\n    if (typeof options.writev === 'function') this._writev = options.writev;\n  }\n\n  Stream.call(this);\n}\n\n// Otherwise people can pipe Writable streams, which is just wrong.\nWritable.prototype.pipe = function () {\n  this.emit('error', new Error('Cannot pipe. Not readable.'));\n};\n\nfunction writeAfterEnd(stream, cb) {\n  var er = new Error('write after end');\n  // TODO: defer error events consistently everywhere, not just the cb\n  stream.emit('error', er);\n  processNextTick(cb, er);\n}\n\n// If we get something that is not a buffer, string, null, or undefined,\n// and we're not in objectMode, then that's an error.\n// Otherwise stream chunks are all considered to be of length=1, and the\n// watermarks determine how many objects to keep in the buffer, rather than\n// how many bytes or characters.\nfunction validChunk(stream, state, chunk, cb) {\n  var valid = true;\n\n  if (!Buffer.isBuffer(chunk) && typeof chunk !== 'string' && chunk !== null && chunk !== undefined && !state.objectMode) {\n    var er = new TypeError('Invalid non-string/buffer chunk');\n    stream.emit('error', er);\n    processNextTick(cb, er);\n    valid = false;\n  }\n  return valid;\n}\n\nWritable.prototype.write = function (chunk, encoding, cb) {\n  var state = this._writableState;\n  var ret = false;\n\n  if (typeof encoding === 'function') {\n    cb = encoding;\n    encoding = null;\n  }\n\n  if (Buffer.isBuffer(chunk)) encoding = 'buffer';else if (!encoding) encoding = state.defaultEncoding;\n\n  if (typeof cb !== 'function') cb = nop;\n\n  if (state.ended) writeAfterEnd(this, cb);else if (validChunk(this, state, chunk, cb)) {\n    state.pendingcb++;\n    ret = writeOrBuffer(this, state, chunk, encoding, cb);\n  }\n\n  return ret;\n};\n\nWritable.prototype.cork = function () {\n  var state = this._writableState;\n\n  state.corked++;\n};\n\nWritable.prototype.uncork = function () {\n  var state = this._writableState;\n\n  if (state.corked) {\n    state.corked--;\n\n    if (!state.writing && !state.corked && !state.finished && !state.bufferProcessing && state.bufferedRequest) clearBuffer(this, state);\n  }\n};\n\nWritable.prototype.setDefaultEncoding = function setDefaultEncoding(encoding) {\n  // node::ParseEncoding() requires lower case.\n  if (typeof encoding === 'string') encoding = encoding.toLowerCase();\n  if (!(['hex', 'utf8', 'utf-8', 'ascii', 'binary', 'base64', 'ucs2', 'ucs-2', 'utf16le', 'utf-16le', 'raw'].indexOf((encoding + '').toLowerCase()) > -1)) throw new TypeError('Unknown encoding: ' + encoding);\n  this._writableState.defaultEncoding = encoding;\n};\n\nfunction decodeChunk(state, chunk, encoding) {\n  if (!state.objectMode && state.decodeStrings !== false && typeof chunk === 'string') {\n    chunk = new Buffer(chunk, encoding);\n  }\n  return chunk;\n}\n\n// if we're already writing something, then just put this\n// in the queue, and wait our turn.  Otherwise, call _write\n// If we return false, then we need a drain event, so set that flag.\nfunction writeOrBuffer(stream, state, chunk, encoding, cb) {\n  chunk = decodeChunk(state, chunk, encoding);\n\n  if (Buffer.isBuffer(chunk)) encoding = 'buffer';\n  var len = state.objectMode ? 1 : chunk.length;\n\n  state.length += len;\n\n  var ret = state.length < state.highWaterMark;\n  // we must ensure that previous needDrain will not be reset to false.\n  if (!ret) state.needDrain = true;\n\n  if (state.writing || state.corked) {\n    var last = state.lastBufferedRequest;\n    state.lastBufferedRequest = new WriteReq(chunk, encoding, cb);\n    if (last) {\n      last.next = state.lastBufferedRequest;\n    } else {\n      state.bufferedRequest = state.lastBufferedRequest;\n    }\n    state.bufferedRequestCount += 1;\n  } else {\n    doWrite(stream, state, false, len, chunk, encoding, cb);\n  }\n\n  return ret;\n}\n\nfunction doWrite(stream, state, writev, len, chunk, encoding, cb) {\n  state.writelen = len;\n  state.writecb = cb;\n  state.writing = true;\n  state.sync = true;\n  if (writev) stream._writev(chunk, state.onwrite);else stream._write(chunk, encoding, state.onwrite);\n  state.sync = false;\n}\n\nfunction onwriteError(stream, state, sync, er, cb) {\n  --state.pendingcb;\n  if (sync) processNextTick(cb, er);else cb(er);\n\n  stream._writableState.errorEmitted = true;\n  stream.emit('error', er);\n}\n\nfunction onwriteStateUpdate(state) {\n  state.writing = false;\n  state.writecb = null;\n  state.length -= state.writelen;\n  state.writelen = 0;\n}\n\nfunction onwrite(stream, er) {\n  var state = stream._writableState;\n  var sync = state.sync;\n  var cb = state.writecb;\n\n  onwriteStateUpdate(state);\n\n  if (er) onwriteError(stream, state, sync, er, cb);else {\n    // Check if we're actually ready to finish, but don't emit yet\n    var finished = needFinish(state);\n\n    if (!finished && !state.corked && !state.bufferProcessing && state.bufferedRequest) {\n      clearBuffer(stream, state);\n    }\n\n    if (sync) {\n      /*<replacement>*/\n      asyncWrite(afterWrite, stream, state, finished, cb);\n      /*</replacement>*/\n    } else {\n        afterWrite(stream, state, finished, cb);\n      }\n  }\n}\n\nfunction afterWrite(stream, state, finished, cb) {\n  if (!finished) onwriteDrain(stream, state);\n  state.pendingcb--;\n  cb();\n  finishMaybe(stream, state);\n}\n\n// Must force callback to be called on nextTick, so that we don't\n// emit 'drain' before the write() consumer gets the 'false' return\n// value, and has a chance to attach a 'drain' listener.\nfunction onwriteDrain(stream, state) {\n  if (state.length === 0 && state.needDrain) {\n    state.needDrain = false;\n    stream.emit('drain');\n  }\n}\n\n// if there's something in the buffer waiting, then process it\nfunction clearBuffer(stream, state) {\n  state.bufferProcessing = true;\n  var entry = state.bufferedRequest;\n\n  if (stream._writev && entry && entry.next) {\n    // Fast case, write everything using _writev()\n    var l = state.bufferedRequestCount;\n    var buffer = new Array(l);\n    var holder = state.corkedRequestsFree;\n    holder.entry = entry;\n\n    var count = 0;\n    while (entry) {\n      buffer[count] = entry;\n      entry = entry.next;\n      count += 1;\n    }\n\n    doWrite(stream, state, true, state.length, buffer, '', holder.finish);\n\n    // doWrite is always async, defer these to save a bit of time\n    // as the hot path ends with doWrite\n    state.pendingcb++;\n    state.lastBufferedRequest = null;\n    state.corkedRequestsFree = holder.next;\n    holder.next = null;\n  } else {\n    // Slow case, write chunks one-by-one\n    while (entry) {\n      var chunk = entry.chunk;\n      var encoding = entry.encoding;\n      var cb = entry.callback;\n      var len = state.objectMode ? 1 : chunk.length;\n\n      doWrite(stream, state, false, len, chunk, encoding, cb);\n      entry = entry.next;\n      // if we didn't call the onwrite immediately, then\n      // it means that we need to wait until it does.\n      // also, that means that the chunk and cb are currently\n      // being processed, so move the buffer counter past them.\n      if (state.writing) {\n        break;\n      }\n    }\n\n    if (entry === null) state.lastBufferedRequest = null;\n  }\n\n  state.bufferedRequestCount = 0;\n  state.bufferedRequest = entry;\n  state.bufferProcessing = false;\n}\n\nWritable.prototype._write = function (chunk, encoding, cb) {\n  cb(new Error('not implemented'));\n};\n\nWritable.prototype._writev = null;\n\nWritable.prototype.end = function (chunk, encoding, cb) {\n  var state = this._writableState;\n\n  if (typeof chunk === 'function') {\n    cb = chunk;\n    chunk = null;\n    encoding = null;\n  } else if (typeof encoding === 'function') {\n    cb = encoding;\n    encoding = null;\n  }\n\n  if (chunk !== null && chunk !== undefined) this.write(chunk, encoding);\n\n  // .end() fully uncorks\n  if (state.corked) {\n    state.corked = 1;\n    this.uncork();\n  }\n\n  // ignore unnecessary end() calls.\n  if (!state.ending && !state.finished) endWritable(this, state, cb);\n};\n\nfunction needFinish(state) {\n  return state.ending && state.length === 0 && state.bufferedRequest === null && !state.finished && !state.writing;\n}\n\nfunction prefinish(stream, state) {\n  if (!state.prefinished) {\n    state.prefinished = true;\n    stream.emit('prefinish');\n  }\n}\n\nfunction finishMaybe(stream, state) {\n  var need = needFinish(state);\n  if (need) {\n    if (state.pendingcb === 0) {\n      prefinish(stream, state);\n      state.finished = true;\n      stream.emit('finish');\n    } else {\n      prefinish(stream, state);\n    }\n  }\n  return need;\n}\n\nfunction endWritable(stream, state, cb) {\n  state.ending = true;\n  finishMaybe(stream, state);\n  if (cb) {\n    if (state.finished) processNextTick(cb);else stream.once('finish', cb);\n  }\n  state.ended = true;\n  stream.writable = false;\n}\n\n// It seems a linked list but it is not\n// there will be only 2 of these for each stream\nfunction CorkedRequest(state) {\n  var _this = this;\n\n  this.next = null;\n  this.entry = null;\n\n  this.finish = function (err) {\n    var entry = _this.entry;\n    _this.entry = null;\n    while (entry) {\n      var cb = entry.callback;\n      state.pendingcb--;\n      cb(err);\n      entry = entry.next;\n    }\n    if (state.corkedRequestsFree) {\n      state.corkedRequestsFree.next = _this;\n    } else {\n      state.corkedRequestsFree = _this;\n    }\n  };\n}"]},"metadata":{},"sourceType":"script"}