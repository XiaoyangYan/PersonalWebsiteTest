{"ast":null,"code":"'use strict';\n\nvar SourceMapGenerator = require('source-map').SourceMapGenerator;\n\nfunction offsetMapping(mapping, offset) {\n  return {\n    line: offset.line + mapping.line,\n    column: offset.column + mapping.column\n  };\n}\n\nfunction newlinesIn(src) {\n  if (!src) return 0;\n  var newlines = src.match(/\\n/g);\n  return newlines ? newlines.length : 0;\n}\n\nfunction Generator(opts) {\n  opts = opts || {};\n  this.generator = new SourceMapGenerator({\n    file: opts.file || '',\n    sourceRoot: opts.sourceRoot || ''\n  });\n  this.sourcesContent = undefined;\n  this.opts = opts;\n}\n/**\n * Adds the given mappings to the generator and offsets them if offset is given \n *\n * @name addMappings\n * @function\n * @param sourceFile {String} name of the source file\n * @param mappings {Array{{Object}} each object has the form { original: { line: _, column: _ }, generated: { line: _, column: _ } }\n * @param offset {Object} offset to apply to each mapping. Has the form { line: _, column: _ }\n * @return {Object} the generator to allow chaining\n */\n\n\nGenerator.prototype.addMappings = function (sourceFile, mappings, offset) {\n  var generator = this.generator;\n  offset = offset || {};\n  offset.line = offset.hasOwnProperty('line') ? offset.line : 0;\n  offset.column = offset.hasOwnProperty('column') ? offset.column : 0;\n  mappings.forEach(function (m) {\n    // only set source if we have original position to handle edgecase (see inline-source-map tests)\n    generator.addMapping({\n      source: m.original ? sourceFile : undefined,\n      original: m.original,\n      generated: offsetMapping(m.generated, offset)\n    });\n  });\n  return this;\n};\n/**\n * Generates mappings for the given source, assuming that no translation from original to generated is necessary.\n *\n * @name addGeneratedMappings\n * @function\n * @param sourceFile {String} name of the source file\n * @param source {String} source of the file\n * @param offset {Object} offset to apply to each mapping. Has the form { line: _, column: _ }\n * @return {Object} the generator to allow chaining\n */\n\n\nGenerator.prototype.addGeneratedMappings = function (sourceFile, source, offset) {\n  var mappings = [],\n      linesToGenerate = newlinesIn(source) + 1;\n\n  for (var line = 1; line <= linesToGenerate; line++) {\n    var location = {\n      line: line,\n      column: 0\n    };\n    mappings.push({\n      original: location,\n      generated: location\n    });\n  }\n\n  return this.addMappings(sourceFile, mappings, offset);\n};\n/**\n * Adds source content for the given source file.\n * \n * @name addSourceContent\n * @function\n * @param sourceFile {String} The source file for which a mapping is included\n * @param sourcesContent {String} The content of the source file\n * @return {Object} The generator to allow chaining\n */\n\n\nGenerator.prototype.addSourceContent = function (sourceFile, sourcesContent) {\n  this.sourcesContent = this.sourcesContent || {};\n  this.sourcesContent[sourceFile] = sourcesContent;\n  return this;\n};\n/**\n * @name base64Encode\n * @function\n * @return {String} bas64 encoded representation of the added mappings\n */\n\n\nGenerator.prototype.base64Encode = function () {\n  var map = this.toString();\n  return new Buffer(map).toString('base64');\n};\n/**\n * @name inlineMappingUrl\n * @function\n * @return {String} comment with base64 encoded representation of the added mappings. Can be inlined at the end of the generated file. \n */\n\n\nGenerator.prototype.inlineMappingUrl = function () {\n  var charset = this.opts.charset || 'utf-8';\n  return '//# sourceMappingURL=data:application/json;charset=' + charset + ';base64,' + this.base64Encode();\n};\n\nGenerator.prototype.toJSON = function () {\n  var map = this.generator.toJSON();\n  if (!this.sourcesContent) return map;\n\n  var toSourcesContent = function (s) {\n    if (typeof this.sourcesContent[s] === 'string') {\n      return this.sourcesContent[s];\n    } else {\n      return null;\n    }\n  }.bind(this);\n\n  map.sourcesContent = map.sources.map(toSourcesContent);\n  return map;\n};\n\nGenerator.prototype.toString = function () {\n  return JSON.stringify(this);\n};\n\nGenerator.prototype._mappings = function () {\n  return this.generator._mappings._array;\n};\n\nGenerator.prototype.gen = function () {\n  return this.generator;\n};\n\nmodule.exports = function (opts) {\n  return new Generator(opts);\n};\n\nmodule.exports.Generator = Generator;","map":{"version":3,"sources":["/home/yanxiaoyang/react-project/PersonalWebsiteTest/node_modules/inline-source-map/index.js"],"names":["SourceMapGenerator","require","offsetMapping","mapping","offset","line","column","newlinesIn","src","newlines","match","length","Generator","opts","generator","file","sourceRoot","sourcesContent","undefined","prototype","addMappings","sourceFile","mappings","hasOwnProperty","forEach","m","addMapping","source","original","generated","addGeneratedMappings","linesToGenerate","location","push","addSourceContent","base64Encode","map","toString","Buffer","inlineMappingUrl","charset","toJSON","toSourcesContent","s","bind","sources","JSON","stringify","_mappings","_array","gen","module","exports"],"mappings":"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","sourcesContent":["'use strict';\nvar SourceMapGenerator = require('source-map').SourceMapGenerator;\n\nfunction offsetMapping(mapping, offset) {\n  return { line: offset.line + mapping.line, column: offset.column + mapping.column };\n}\n\nfunction newlinesIn(src) {\n  if (!src) return 0;\n  var newlines = src.match(/\\n/g);\n\n  return newlines ? newlines.length : 0;\n}\n \nfunction Generator(opts) {\n  opts = opts || {};\n  this.generator = new SourceMapGenerator({ file: opts.file || '', sourceRoot: opts.sourceRoot || '' });\n  this.sourcesContent = undefined;\n  this.opts = opts;\n}\n\n/**\n * Adds the given mappings to the generator and offsets them if offset is given \n *\n * @name addMappings\n * @function\n * @param sourceFile {String} name of the source file\n * @param mappings {Array{{Object}} each object has the form { original: { line: _, column: _ }, generated: { line: _, column: _ } }\n * @param offset {Object} offset to apply to each mapping. Has the form { line: _, column: _ }\n * @return {Object} the generator to allow chaining\n */\nGenerator.prototype.addMappings = function (sourceFile, mappings, offset) { \n  var generator = this.generator; \n\n  offset = offset || {};\n  offset.line = offset.hasOwnProperty('line') ? offset.line : 0;\n  offset.column = offset.hasOwnProperty('column') ? offset.column : 0;\n\n  mappings.forEach(function (m) {\n    // only set source if we have original position to handle edgecase (see inline-source-map tests)\n    generator.addMapping({\n        source    :  m.original ? sourceFile : undefined\n      , original  :  m.original\n      , generated :  offsetMapping(m.generated, offset)\n    });\n  });\n  return this;\n};\n\n/**\n * Generates mappings for the given source, assuming that no translation from original to generated is necessary.\n *\n * @name addGeneratedMappings\n * @function\n * @param sourceFile {String} name of the source file\n * @param source {String} source of the file\n * @param offset {Object} offset to apply to each mapping. Has the form { line: _, column: _ }\n * @return {Object} the generator to allow chaining\n */\nGenerator.prototype.addGeneratedMappings = function (sourceFile, source, offset) {\n  var mappings = []\n    , linesToGenerate = newlinesIn(source) + 1;\n\n  for (var line = 1; line <= linesToGenerate; line++) {\n    var location = { line: line, column: 0 };\n    mappings.push({ original: location, generated: location });\n  }\n\n  return this.addMappings(sourceFile, mappings, offset);\n};\n\n/**\n * Adds source content for the given source file.\n * \n * @name addSourceContent\n * @function\n * @param sourceFile {String} The source file for which a mapping is included\n * @param sourcesContent {String} The content of the source file\n * @return {Object} The generator to allow chaining\n */\nGenerator.prototype.addSourceContent = function (sourceFile, sourcesContent) {\n  this.sourcesContent = this.sourcesContent || {};\n  this.sourcesContent[sourceFile] = sourcesContent;\n  return this;\n};\n\n/**\n * @name base64Encode\n * @function\n * @return {String} bas64 encoded representation of the added mappings\n */\nGenerator.prototype.base64Encode = function () {\n  var map = this.toString();\n  return new Buffer(map).toString('base64');\n};\n\n/**\n * @name inlineMappingUrl\n * @function\n * @return {String} comment with base64 encoded representation of the added mappings. Can be inlined at the end of the generated file. \n */\nGenerator.prototype.inlineMappingUrl = function () {\n  var charset = this.opts.charset || 'utf-8';\n  return '//# sourceMappingURL=data:application/json;charset=' + charset + ';base64,' + this.base64Encode();\n};\n\nGenerator.prototype.toJSON = function () {\n  var map = this.generator.toJSON();\n  if (!this.sourcesContent) return map;\n\n  var toSourcesContent = (function (s) {\n    if (typeof this.sourcesContent[s] === 'string') {\n      return this.sourcesContent[s];\n    } else {\n      return null;\n    }\n  }).bind(this);\n  map.sourcesContent = map.sources.map(toSourcesContent);\n  return map;\n};\n\nGenerator.prototype.toString = function () {\n  return JSON.stringify(this);\n};\n\nGenerator.prototype._mappings = function () {\n  return this.generator._mappings._array;\n};\n\nGenerator.prototype.gen = function () {\n  return this.generator;\n};\n\nmodule.exports = function (opts) { return new Generator(opts); };\nmodule.exports.Generator = Generator;\n"]},"metadata":{},"sourceType":"script"}