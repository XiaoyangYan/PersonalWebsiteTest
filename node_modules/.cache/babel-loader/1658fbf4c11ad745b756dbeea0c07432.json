{"ast":null,"code":"const request = require('request-promise-native');\n\nconst uuid = require('uuid');\n\nconst _require = require('./process'),\n      getProcess = _require.getProcess,\n      killProcess = _require.killProcess,\n      setAuthtoken = _require.setAuthtoken;\n\nlet processUrl;\nlet internalApi;\nlet tunnels = {};\n\nasync function connect(opts) {\n  opts = defaults(opts);\n  validate(opts);\n\n  if (opts.authtoken) {\n    await setAuthtoken(opts);\n  }\n\n  processUrl = await getProcess(opts);\n  internalApi = request.defaults({\n    baseUrl: processUrl\n  });\n  return connectRetry(opts);\n}\n\nfunction defaults(opts) {\n  opts = opts || {\n    proto: 'http',\n    addr: 80\n  };\n  if (typeof opts === 'function') opts = {\n    proto: 'http',\n    addr: 80\n  };\n  if (typeof opts !== 'object') opts = {\n    proto: 'http',\n    addr: opts\n  };\n  if (!opts.proto) opts.proto = 'http';\n  if (!opts.addr) opts.addr = opts.port || opts.host || 80;\n  if (opts.httpauth) opts.auth = opts.httpauth;\n  return opts;\n}\n\nfunction validate(opts) {\n  if (opts.web_addr === false || opts.web_addr === 'false') {\n    throw new Error('web_addr:false is not supported, module depends on internal ngrok api');\n  }\n}\n\nasync function connectRetry(opts, retryCount = 0) {\n  opts.name = String(opts.name || uuid.v4());\n\n  try {\n    const response = await internalApi.post({\n      url: 'api/tunnels',\n      json: opts\n    });\n    const publicUrl = response.public_url;\n\n    if (!publicUrl) {\n      throw new Error('failed to start tunnel');\n    }\n\n    tunnels[publicUrl] = response.uri;\n\n    if (opts.proto === 'http' && opts.bind_tls !== false) {\n      tunnels[publicUrl.replace('https', 'http')] = response.uri + ' (http)';\n    }\n\n    return publicUrl;\n  } catch (err) {\n    if (!isRetriable(err) || retryCount >= 100) {\n      throw err.error || err.response;\n    }\n\n    await new Promise(resolve => setTimeout(resolve, 200));\n    return connectRetry(opts, ++retryCount);\n  }\n}\n\nfunction isRetriable(err) {\n  if (!err.response) return false;\n  const body = err.response.body;\n  const notReady500 = err.statusCode === 500 && /panic/.test(body);\n  const notReady502 = err.statusCode === 502 && body.details && body.details.err === 'tunnel session not ready yet';\n  const notReady503 = err.statusCode === 503 && body.details && body.details.err === 'a successful ngrok tunnel session has not yet been established';\n  return notReady500 || notReady502 || notReady503;\n}\n\nasync function disconnect(publicUrl) {\n  if (!internalApi) return;\n\n  if (!publicUrl) {\n    const disconnectAll = Object.keys(tunnels).map(disconnect);\n    return Promise.all(disconnectAll);\n  }\n\n  const tunnelUrl = tunnels[publicUrl];\n\n  if (!tunnelUrl) {\n    throw new Error(`there is no tunnel with url: ${publicUrl}`);\n  }\n\n  await internalApi.del(tunnelUrl);\n  delete tunnels[publicUrl];\n}\n\nasync function kill() {\n  if (!internalApi) return;\n  await killProcess();\n  internalApi = null;\n  tunnels = {};\n}\n\nfunction getUrl() {\n  return processUrl;\n}\n\nfunction getApi() {\n  return internalApi;\n}\n\nmodule.exports = {\n  connect,\n  disconnect,\n  authtoken: setAuthtoken,\n  kill,\n  getUrl,\n  getApi\n};","map":{"version":3,"sources":["/home/yanxiaoyang/react-project/PersonalWebsiteTest/node_modules/ngrok/index.js"],"names":["request","require","uuid","getProcess","killProcess","setAuthtoken","processUrl","internalApi","tunnels","connect","opts","defaults","validate","authtoken","baseUrl","connectRetry","proto","addr","port","host","httpauth","auth","web_addr","Error","retryCount","name","String","v4","response","post","url","json","publicUrl","public_url","uri","bind_tls","replace","err","isRetriable","error","Promise","resolve","setTimeout","body","notReady500","statusCode","test","notReady502","details","notReady503","disconnect","disconnectAll","Object","keys","map","all","tunnelUrl","del","kill","getUrl","getApi","module","exports"],"mappings":"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","sourcesContent":["const request = require('request-promise-native');\nconst uuid = require('uuid');\nconst {getProcess, killProcess, setAuthtoken} = require('./process');\n\nlet processUrl;\nlet internalApi;\nlet tunnels = {};\n\nasync function connect (opts) {\n  opts = defaults(opts);\n  validate(opts);\n  if (opts.authtoken) {\n    await setAuthtoken(opts);\n  }\n\n  processUrl = await getProcess(opts);\n  internalApi = request.defaults({baseUrl: processUrl});\n  return connectRetry(opts);\n}\n\nfunction defaults (opts) {\n  opts = opts || {proto: 'http', addr: 80}\n  if (typeof opts === 'function') opts = {proto: 'http', addr: 80};\n  if (typeof opts !== 'object') opts = {proto: 'http', addr: opts};\n  if (!opts.proto) opts.proto = 'http';\n  if (!opts.addr) opts.addr = opts.port || opts.host || 80;\n  if (opts.httpauth) opts.auth = opts.httpauth;\n  return opts\n}\n\nfunction validate  (opts) {\n  if (opts.web_addr === false || opts.web_addr === 'false') {\n    throw new Error('web_addr:false is not supported, module depends on internal ngrok api')\n  }\n}\n\nasync function connectRetry (opts, retryCount = 0) {\n  opts.name = String(opts.name || uuid.v4());\n  try {\n    const response = await internalApi.post({url: 'api/tunnels', json: opts});\n    const publicUrl = response.public_url;\n    if (!publicUrl) {\n      throw new Error('failed to start tunnel');\n    }\n    tunnels[publicUrl] = response.uri;\n    if (opts.proto === 'http' && opts.bind_tls !== false) {\n      tunnels[publicUrl.replace('https', 'http')] = response.uri + ' (http)';\n    }\n    return publicUrl;\n  } catch (err) {\n    if (!isRetriable(err) || retryCount >= 100) {\n      throw err.error || err.response;\n    }\n    await new Promise((resolve) => setTimeout(resolve, 200));\n    return connectRetry(opts, ++retryCount);\n  }\n }\n\nfunction isRetriable (err) {\n  if (!err.response) return false;\n  const body = err.response.body;\n  const notReady500 = err.statusCode === 500 && /panic/.test(body)\n  const notReady502 = err.statusCode === 502 && body.details && body.details.err === 'tunnel session not ready yet';\n  const notReady503 = err.statusCode === 503 && body.details && body.details.err === 'a successful ngrok tunnel session has not yet been established';\n  return notReady500 || notReady502 || notReady503;\n}\n\nasync function disconnect (publicUrl) {\n  if (!internalApi) return;\n  if (!publicUrl) {\n  \tconst disconnectAll = Object.keys(tunnels).map(disconnect);\n  \treturn Promise.all(disconnectAll);\n  }\n  const tunnelUrl = tunnels[publicUrl];\n  if (!tunnelUrl) {\n    throw new Error(`there is no tunnel with url: ${publicUrl}`)\n  }\n  await internalApi.del(tunnelUrl)\n  delete tunnels[publicUrl];\n}\n\nasync function kill ()  {\n  if (!internalApi) return;\n  await killProcess();\n  internalApi = null;\n  tunnels = {}\n}\n\nfunction getUrl() {\n  return processUrl;\n}\n\nfunction getApi() {\n  return internalApi;\n}\n\nmodule.exports = {\n  connect,\n  disconnect,\n  authtoken: setAuthtoken,\n  kill,\n  getUrl,\n  getApi\n};\n"]},"metadata":{},"sourceType":"script"}