{"ast":null,"code":"var async = require(\"async\");\n\nvar _ = require(\"lodash\");\n\nvar deprecatedChain = {};\n\ndeprecatedChain.chain = function (obj) {\n  var _this = this;\n\n  if (!obj) {\n    obj = {};\n  } // Update the onError callback if supplied.  The most recent .chain()\n  // invocation overrides previous onError handlers.\n\n\n  if (obj.onError) {\n    this._chainOnErrorCallback = obj.onError;\n  } else if (!this._chainOnErrorCallback) {\n    this._chainOnErrorCallback = function (err) {\n      if (err) {\n        console.error(\"a function in your .chain() failed:\", err); // eslint-disable-line no-console\n      }\n    };\n  } // Add queue if not already here\n\n\n  if (!_this._queue) {\n    _this._queue = async.queue(function (task, callback) {\n      if (task.args.length > 0 && typeof task.args[task.args.length - 1] === \"function\") {\n        //wrap the existing callback\n        //if this is queueAddAsync, we instead create a callback that will be\n        //passed through to the function provided\n        var cb_arg = task.name === 'queueAddAsync' ? 1 : task.args.length - 1;\n        var func = task.args[cb_arg];\n\n        task.args[cb_arg] = function (err) {\n          // if the chain user has their own callback, we will not invoke\n          // the onError handler, supplying your own callback suggests you\n          // handle the error on your own.\n          if (func) {\n            func.apply(null, arguments);\n          }\n\n          if (!_this._chainHalted) {\n            callback(err);\n          }\n        };\n      } else {\n        // if the .chain() does not supply a callback, we assume they\n        // expect us to catch errors.\n        task.args.push(function (err) {\n          // if there is an error, call the onError callback,\n          // and do not invoke callback() which would make the\n          // task queue continue processing\n          if (err) {\n            _this._chainOnErrorCallback(err);\n          } else {\n            callback();\n          }\n        });\n      } //call the function\n\n\n      _this[task.name].apply(_this, task.args);\n    }, 1); // add unshift method if we need to add sth to the queue\n\n    _this._queue = _.extend(_this._queue, {\n      unshift: function (data, callback) {\n        var _this = this;\n\n        if (data.constructor !== Array) {\n          data = [data];\n        }\n\n        data.forEach(function (task) {\n          _this.tasks.unshift({\n            data: task,\n            callback: typeof callback === 'function' ? callback : null\n          });\n\n          if (_this.saturated && _this.tasks.length === _this.concurrency) {\n            _this.saturated();\n          }\n\n          async.nextTick(_this.process);\n        });\n      }\n    });\n  }\n\n  var chain = {}; //builds a placeHolder functions\n\n  var buildPlaceholder = function (name) {\n    return function () {\n      _this._queue.push({\n        name: name,\n        args: Array.prototype.slice.call(arguments, 0)\n      });\n\n      return chain;\n    };\n  }; //fill the chain with placeholders\n\n\n  _.each(_.functionsIn(_this), function (k) {\n    if (k !== \"chain\") {\n      chain[k] = buildPlaceholder(k);\n    }\n  });\n\n  return chain;\n}; // manually stop processing of queued chained functions\n\n\ndeprecatedChain.haltChain = function () {\n  this._chainHalted = true;\n  this._queue = null;\n};\n\ndeprecatedChain.pauseChain = function (timeoutMs, cb) {\n  setTimeout(function () {\n    cb();\n  }, timeoutMs);\n  return this.chain;\n};\n\ndeprecatedChain.next = function () {\n  this._queue.unshift({\n    name: arguments[0],\n    args: _.drop(arguments)\n  });\n};\n\ndeprecatedChain.queueAdd = function (func) {\n  func();\n  return this.chain;\n};\n\ndeprecatedChain.queueAddAsync = function (func, cb) {\n  func(cb);\n  return this.chain;\n};\n\nmodule.exports = {\n  patch: function (browser) {\n    var chain = _(deprecatedChain);\n\n    var functions = _.isFunction(chain.methods) ? chain.methods() : chain.functions();\n    functions.each(function (methodName) {\n      browser[methodName] = deprecatedChain[methodName].bind(browser);\n    });\n  }\n};","map":{"version":3,"sources":["/home/yanxiaoyang/react-project/PersonalWebsiteTest/node_modules/wd/lib/deprecated-chain.js"],"names":["async","require","_","deprecatedChain","chain","obj","_this","onError","_chainOnErrorCallback","err","console","error","_queue","queue","task","callback","args","length","cb_arg","name","func","apply","arguments","_chainHalted","push","extend","unshift","data","constructor","Array","forEach","tasks","saturated","concurrency","nextTick","process","buildPlaceholder","prototype","slice","call","each","functionsIn","k","haltChain","pauseChain","timeoutMs","cb","setTimeout","next","drop","queueAdd","queueAddAsync","module","exports","patch","browser","functions","isFunction","methods","methodName","bind"],"mappings":"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","sourcesContent":["var async = require(\"async\");\nvar _ = require(\"lodash\");\n\nvar deprecatedChain ={};\n\ndeprecatedChain.chain = function(obj){\n  var _this = this;\n  if (!obj) { obj = {}; }\n\n  // Update the onError callback if supplied.  The most recent .chain()\n  // invocation overrides previous onError handlers.\n  if (obj.onError) {\n    this._chainOnErrorCallback = obj.onError;\n  } else if (!this._chainOnErrorCallback) {\n    this._chainOnErrorCallback = function(err) {\n      if (err) {\n        console.error(\"a function in your .chain() failed:\", err); // eslint-disable-line no-console\n      }\n    };\n  }\n\n  // Add queue if not already here\n  if(!_this._queue){\n    _this._queue = async.queue(function (task, callback) {\n      if(task.args.length > 0 && typeof task.args[task.args.length-1] === \"function\"){\n        //wrap the existing callback\n        //if this is queueAddAsync, we instead create a callback that will be\n        //passed through to the function provided\n        var cb_arg = (task.name === 'queueAddAsync' ? 1 : task.args.length - 1);\n        var func = task.args[cb_arg];\n        task.args[cb_arg] = function(err) {\n          // if the chain user has their own callback, we will not invoke\n          // the onError handler, supplying your own callback suggests you\n          // handle the error on your own.\n          if (func)\n            { func.apply(null, arguments); }\n          if (!_this._chainHalted) { callback(err); }\n        };\n      } else {\n        // if the .chain() does not supply a callback, we assume they\n        // expect us to catch errors.\n        task.args.push(function(err) {\n          // if there is an error, call the onError callback,\n          // and do not invoke callback() which would make the\n          // task queue continue processing\n          if (err) { _this._chainOnErrorCallback(err); }\n          else { callback(); }\n        });\n      }\n\n      //call the function\n      _this[task.name].apply(_this, task.args);\n    }, 1);\n\n    // add unshift method if we need to add sth to the queue\n    _this._queue = _.extend(_this._queue, {\n      unshift: function (data, callback) {\n        var _this = this;\n        if(data.constructor !== Array) {\n            data = [data];\n        }\n        data.forEach(function(task) {\n            _this.tasks.unshift({\n                data: task,\n                callback: typeof callback === 'function' ? callback : null\n            });\n            if (_this.saturated && _this.tasks.length === _this.concurrency) {\n                _this.saturated();\n            }\n            async.nextTick(_this.process);\n        });\n      }\n    });\n  }\n\n  var chain = {};\n\n  //builds a placeHolder functions\n  var buildPlaceholder = function(name){\n    return function(){\n      _this._queue.push({name: name, args: Array.prototype.slice.call(arguments, 0)});\n      return chain;\n    };\n  };\n\n  //fill the chain with placeholders\n  _.each(_.functionsIn(_this), function(k) {\n    if(k !== \"chain\"){\n      chain[k] = buildPlaceholder(k);\n    }\n  });\n\n  return chain;\n};\n\n// manually stop processing of queued chained functions\ndeprecatedChain.haltChain = function(){\n  this._chainHalted = true;\n  this._queue = null;\n};\n\ndeprecatedChain.pauseChain = function(timeoutMs, cb){\n  setTimeout(function() {\n    cb();\n  }, timeoutMs);\n  return this.chain;\n};\n\ndeprecatedChain.next = function(){\n  this._queue.unshift({name: arguments[0], args: _.drop(arguments)});\n};\n\ndeprecatedChain.queueAdd = function(func){\n  func();\n  return this.chain;\n};\n\ndeprecatedChain.queueAddAsync = function(func, cb) {\n  func(cb);\n  return this.chain;\n};\n\nmodule.exports = {\n  patch: function (browser) {\n    var chain = _(deprecatedChain);\n    var functions = _.isFunction(chain.methods) ?\n      chain.methods() :\n      chain.functions();\n\n    functions.each(function (methodName) {\n      browser[methodName] = deprecatedChain[methodName].bind(browser);\n    });\n  }\n};\n"]},"metadata":{},"sourceType":"script"}