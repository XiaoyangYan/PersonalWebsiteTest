{"ast":null,"code":"'use strict';\n\nvar fs = require('fs');\n\nvar sysPath = require('path');\n\nvar readdirp = require('readdirp');\n\nvar fsevents;\n\ntry {\n  fsevents = require('fsevents');\n} catch (error) {\n  if (process.env.CHOKIDAR_PRINT_FSEVENTS_REQUIRE_ERROR) console.error(error);\n} // fsevents instance helper functions\n// object to hold per-process fsevents instances\n// (may be shared across chokidar FSWatcher instances)\n\n\nvar FSEventsWatchers = Object.create(null); // Threshold of duplicate path prefixes at which to start\n// consolidating going forward\n\nvar consolidateThreshhold = 10; // Private function: Instantiates the fsevents interface\n// * path       - string, path to be watched\n// * callback   - function, called when fsevents is bound and ready\n// Returns new fsevents instance\n\nfunction createFSEventsInstance(path, callback) {\n  return new fsevents(path).on('fsevent', callback).start();\n} // Private function: Instantiates the fsevents interface or binds listeners\n// to an existing one covering the same file tree\n// * path       - string, path to be watched\n// * realPath   - string, real path (in case of symlinks)\n// * listener   - function, called when fsevents emits events\n// * rawEmitter - function, passes data to listeners of the 'raw' event\n// Returns close function\n\n\nfunction setFSEventsListener(path, realPath, listener, rawEmitter) {\n  var watchPath = sysPath.extname(path) ? sysPath.dirname(path) : path;\n  var watchContainer;\n  var parentPath = sysPath.dirname(watchPath); // If we've accumulated a substantial number of paths that\n  // could have been consolidated by watching one directory\n  // above the current one, create a watcher on the parent\n  // path instead, so that we do consolidate going forward.\n\n  if (couldConsolidate(parentPath)) {\n    watchPath = parentPath;\n  }\n\n  var resolvedPath = sysPath.resolve(path);\n  var hasSymlink = resolvedPath !== realPath;\n\n  function filteredListener(fullPath, flags, info) {\n    if (hasSymlink) fullPath = fullPath.replace(realPath, resolvedPath);\n    if (fullPath === resolvedPath || !fullPath.indexOf(resolvedPath + sysPath.sep)) listener(fullPath, flags, info);\n  } // check if there is already a watcher on a parent path\n  // modifies `watchPath` to the parent path when it finds a match\n\n\n  function watchedParent() {\n    return Object.keys(FSEventsWatchers).some(function (watchedPath) {\n      // condition is met when indexOf returns 0\n      if (!realPath.indexOf(sysPath.resolve(watchedPath) + sysPath.sep)) {\n        watchPath = watchedPath;\n        return true;\n      }\n    });\n  }\n\n  if (watchPath in FSEventsWatchers || watchedParent()) {\n    watchContainer = FSEventsWatchers[watchPath];\n    watchContainer.listeners.push(filteredListener);\n  } else {\n    watchContainer = FSEventsWatchers[watchPath] = {\n      listeners: [filteredListener],\n      rawEmitters: [rawEmitter],\n      watcher: createFSEventsInstance(watchPath, function (fullPath, flags) {\n        var info = fsevents.getInfo(fullPath, flags);\n        watchContainer.listeners.forEach(function (listener) {\n          listener(fullPath, flags, info);\n        });\n        watchContainer.rawEmitters.forEach(function (emitter) {\n          emitter(info.event, fullPath, info);\n        });\n      })\n    };\n  }\n\n  var listenerIndex = watchContainer.listeners.length - 1; // removes this instance's listeners and closes the underlying fsevents\n  // instance if there are no more listeners left\n\n  return function close() {\n    delete watchContainer.listeners[listenerIndex];\n    delete watchContainer.rawEmitters[listenerIndex];\n\n    if (!Object.keys(watchContainer.listeners).length) {\n      watchContainer.watcher.stop();\n      delete FSEventsWatchers[watchPath];\n    }\n  };\n} // Decide whether or not we should start a new higher-level\n// parent watcher\n\n\nfunction couldConsolidate(path) {\n  var keys = Object.keys(FSEventsWatchers);\n  var count = 0;\n\n  for (var i = 0, len = keys.length; i < len; ++i) {\n    var watchPath = keys[i];\n\n    if (watchPath.indexOf(path) === 0) {\n      count++;\n\n      if (count >= consolidateThreshhold) {\n        return true;\n      }\n    }\n  }\n\n  return false;\n}\n\nfunction isConstructor(obj) {\n  return obj.prototype !== undefined && obj.prototype.constructor !== undefined;\n} // returns boolean indicating whether fsevents can be used\n\n\nfunction canUse() {\n  return fsevents && Object.keys(FSEventsWatchers).length < 128 && isConstructor(fsevents);\n} // determines subdirectory traversal levels from root to path\n\n\nfunction depth(path, root) {\n  var i = 0;\n\n  while (!path.indexOf(root) && (path = sysPath.dirname(path)) !== root) i++;\n\n  return i;\n} // fake constructor for attaching fsevents-specific prototype methods that\n// will be copied to FSWatcher's prototype\n\n\nfunction FsEventsHandler() {} // Private method: Handle symlinks encountered during directory scan\n// * watchPath  - string, file/dir path to be watched with fsevents\n// * realPath   - string, real path (in case of symlinks)\n// * transform  - function, path transformer\n// * globFilter - function, path filter in case a glob pattern was provided\n// Returns close function for the watcher instance\n\n\nFsEventsHandler.prototype._watchWithFsEvents = function (watchPath, realPath, transform, globFilter) {\n  if (this._isIgnored(watchPath)) return;\n\n  var watchCallback = function (fullPath, flags, info) {\n    if (this.options.depth !== undefined && depth(fullPath, realPath) > this.options.depth) return;\n    var path = transform(sysPath.join(watchPath, sysPath.relative(watchPath, fullPath)));\n    if (globFilter && !globFilter(path)) return; // ensure directories are tracked\n\n    var parent = sysPath.dirname(path);\n    var item = sysPath.basename(path);\n\n    var watchedDir = this._getWatchedDir(info.type === 'directory' ? path : parent);\n\n    var checkIgnored = function (stats) {\n      if (this._isIgnored(path, stats)) {\n        this._ignoredPaths[path] = true;\n\n        if (stats && stats.isDirectory()) {\n          this._ignoredPaths[path + '/**/*'] = true;\n        }\n\n        return true;\n      } else {\n        delete this._ignoredPaths[path];\n        delete this._ignoredPaths[path + '/**/*'];\n      }\n    }.bind(this);\n\n    var handleEvent = function (event) {\n      if (checkIgnored()) return;\n\n      if (event === 'unlink') {\n        // suppress unlink events on never before seen files\n        if (info.type === 'directory' || watchedDir.has(item)) {\n          this._remove(parent, item);\n        }\n      } else {\n        if (event === 'add') {\n          // track new directories\n          if (info.type === 'directory') this._getWatchedDir(path);\n\n          if (info.type === 'symlink' && this.options.followSymlinks) {\n            // push symlinks back to the top of the stack to get handled\n            var curDepth = this.options.depth === undefined ? undefined : depth(fullPath, realPath) + 1;\n            return this._addToFsEvents(path, false, true, curDepth);\n          } else {\n            // track new paths\n            // (other than symlinks being followed, which will be tracked soon)\n            this._getWatchedDir(parent).add(item);\n          }\n        }\n\n        var eventName = info.type === 'directory' ? event + 'Dir' : event;\n\n        this._emit(eventName, path);\n\n        if (eventName === 'addDir') this._addToFsEvents(path, false, true);\n      }\n    }.bind(this);\n\n    function addOrChange() {\n      handleEvent(watchedDir.has(item) ? 'change' : 'add');\n    }\n\n    function checkFd() {\n      fs.open(path, 'r', function (error, fd) {\n        if (error) {\n          error.code !== 'EACCES' ? handleEvent('unlink') : addOrChange();\n        } else {\n          fs.close(fd, function (err) {\n            err && err.code !== 'EACCES' ? handleEvent('unlink') : addOrChange();\n          });\n        }\n      });\n    } // correct for wrong events emitted\n\n\n    var wrongEventFlags = [69888, 70400, 71424, 72704, 73472, 131328, 131840, 262912];\n\n    if (wrongEventFlags.indexOf(flags) !== -1 || info.event === 'unknown') {\n      if (typeof this.options.ignored === 'function') {\n        fs.stat(path, function (error, stats) {\n          if (checkIgnored(stats)) return;\n          stats ? addOrChange() : handleEvent('unlink');\n        });\n      } else {\n        checkFd();\n      }\n    } else {\n      switch (info.event) {\n        case 'created':\n        case 'modified':\n          return addOrChange();\n\n        case 'deleted':\n        case 'moved':\n          return checkFd();\n      }\n    }\n  }.bind(this);\n\n  var closer = setFSEventsListener(watchPath, realPath, watchCallback, this.emit.bind(this, 'raw'));\n\n  this._emitReady();\n\n  return closer;\n}; // Private method: Handle symlinks encountered during directory scan\n// * linkPath   - string, path to symlink\n// * fullPath   - string, absolute path to the symlink\n// * transform  - function, pre-existing path transformer\n// * curDepth   - int, level of subdirectories traversed to where symlink is\n// Returns nothing\n\n\nFsEventsHandler.prototype._handleFsEventsSymlink = function (linkPath, fullPath, transform, curDepth) {\n  // don't follow the same symlink more than once\n  if (this._symlinkPaths[fullPath]) return;else this._symlinkPaths[fullPath] = true;\n  this._readyCount++;\n  fs.realpath(linkPath, function (error, linkTarget) {\n    if (this._handleError(error) || this._isIgnored(linkTarget)) {\n      return this._emitReady();\n    }\n\n    this._readyCount++; // add the linkTarget for watching with a wrapper for transform\n    // that causes emitted paths to incorporate the link's path\n\n    this._addToFsEvents(linkTarget || linkPath, function (path) {\n      var dotSlash = '.' + sysPath.sep;\n      var aliasedPath = linkPath;\n\n      if (linkTarget && linkTarget !== dotSlash) {\n        aliasedPath = path.replace(linkTarget, linkPath);\n      } else if (path !== dotSlash) {\n        aliasedPath = sysPath.join(linkPath, path);\n      }\n\n      return transform(aliasedPath);\n    }, false, curDepth);\n  }.bind(this));\n}; // Private method: Handle added path with fsevents\n// * path       - string, file/directory path or glob pattern\n// * transform  - function, converts working path to what the user expects\n// * forceAdd   - boolean, ensure add is emitted\n// * priorDepth - int, level of subdirectories already traversed\n// Returns nothing\n\n\nFsEventsHandler.prototype._addToFsEvents = function (path, transform, forceAdd, priorDepth) {\n  // applies transform if provided, otherwise returns same value\n  var processPath = typeof transform === 'function' ? transform : function (val) {\n    return val;\n  };\n\n  var emitAdd = function (newPath, stats) {\n    var pp = processPath(newPath);\n    var isDir = stats.isDirectory();\n\n    var dirObj = this._getWatchedDir(sysPath.dirname(pp));\n\n    var base = sysPath.basename(pp); // ensure empty dirs get tracked\n\n    if (isDir) this._getWatchedDir(pp);\n    if (dirObj.has(base)) return;\n    dirObj.add(base);\n\n    if (!this.options.ignoreInitial || forceAdd === true) {\n      this._emit(isDir ? 'addDir' : 'add', pp, stats);\n    }\n  }.bind(this);\n\n  var wh = this._getWatchHelpers(path); // evaluate what is at the path we're being asked to watch\n\n\n  fs[wh.statMethod](wh.watchPath, function (error, stats) {\n    if (this._handleError(error) || this._isIgnored(wh.watchPath, stats)) {\n      this._emitReady();\n\n      return this._emitReady();\n    }\n\n    if (stats.isDirectory()) {\n      // emit addDir unless this is a glob parent\n      if (!wh.globFilter) emitAdd(processPath(path), stats); // don't recurse further if it would exceed depth setting\n\n      if (priorDepth && priorDepth > this.options.depth) return; // scan the contents of the dir\n\n      readdirp({\n        root: wh.watchPath,\n        entryType: 'all',\n        fileFilter: wh.filterPath,\n        directoryFilter: wh.filterDir,\n        lstat: true,\n        depth: this.options.depth - (priorDepth || 0)\n      }).on('data', function (entry) {\n        // need to check filterPath on dirs b/c filterDir is less restrictive\n        if (entry.stat.isDirectory() && !wh.filterPath(entry)) return;\n        var joinedPath = sysPath.join(wh.watchPath, entry.path);\n        var fullPath = entry.fullPath;\n\n        if (wh.followSymlinks && entry.stat.isSymbolicLink()) {\n          // preserve the current depth here since it can't be derived from\n          // real paths past the symlink\n          var curDepth = this.options.depth === undefined ? undefined : depth(joinedPath, sysPath.resolve(wh.watchPath)) + 1;\n\n          this._handleFsEventsSymlink(joinedPath, fullPath, processPath, curDepth);\n        } else {\n          emitAdd(joinedPath, entry.stat);\n        }\n      }.bind(this)).on('error', function () {// Ignore readdirp errors\n      }).on('end', this._emitReady);\n    } else {\n      emitAdd(wh.watchPath, stats);\n\n      this._emitReady();\n    }\n  }.bind(this));\n\n  if (this.options.persistent && forceAdd !== true) {\n    var initWatch = function (error, realPath) {\n      if (this.closed) return;\n\n      var closer = this._watchWithFsEvents(wh.watchPath, sysPath.resolve(realPath || wh.watchPath), processPath, wh.globFilter);\n\n      if (closer) {\n        this._closers[path] = this._closers[path] || [];\n\n        this._closers[path].push(closer);\n      }\n    }.bind(this);\n\n    if (typeof transform === 'function') {\n      // realpath has already been resolved\n      initWatch();\n    } else {\n      fs.realpath(wh.watchPath, initWatch);\n    }\n  }\n};\n\nmodule.exports = FsEventsHandler;\nmodule.exports.canUse = canUse;","map":{"version":3,"sources":["/home/yanxiaoyang/react-project/PersonalWebsiteTest/node_modules/chokidar/lib/fsevents-handler.js"],"names":["fs","require","sysPath","readdirp","fsevents","error","process","env","CHOKIDAR_PRINT_FSEVENTS_REQUIRE_ERROR","console","FSEventsWatchers","Object","create","consolidateThreshhold","createFSEventsInstance","path","callback","on","start","setFSEventsListener","realPath","listener","rawEmitter","watchPath","extname","dirname","watchContainer","parentPath","couldConsolidate","resolvedPath","resolve","hasSymlink","filteredListener","fullPath","flags","info","replace","indexOf","sep","watchedParent","keys","some","watchedPath","listeners","push","rawEmitters","watcher","getInfo","forEach","emitter","event","listenerIndex","length","close","stop","count","i","len","isConstructor","obj","prototype","undefined","constructor","canUse","depth","root","FsEventsHandler","_watchWithFsEvents","transform","globFilter","_isIgnored","watchCallback","options","join","relative","parent","item","basename","watchedDir","_getWatchedDir","type","checkIgnored","stats","_ignoredPaths","isDirectory","bind","handleEvent","has","_remove","followSymlinks","curDepth","_addToFsEvents","add","eventName","_emit","addOrChange","checkFd","open","fd","code","err","wrongEventFlags","ignored","stat","closer","emit","_emitReady","_handleFsEventsSymlink","linkPath","_symlinkPaths","_readyCount","realpath","linkTarget","_handleError","dotSlash","aliasedPath","forceAdd","priorDepth","processPath","val","emitAdd","newPath","pp","isDir","dirObj","base","ignoreInitial","wh","_getWatchHelpers","statMethod","entryType","fileFilter","filterPath","directoryFilter","filterDir","lstat","entry","joinedPath","isSymbolicLink","persistent","initWatch","closed","_closers","module","exports"],"mappings":"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","sourcesContent":["'use strict';\n\nvar fs = require('fs');\nvar sysPath = require('path');\nvar readdirp = require('readdirp');\nvar fsevents;\ntry { fsevents = require('fsevents'); } catch (error) {\n  if (process.env.CHOKIDAR_PRINT_FSEVENTS_REQUIRE_ERROR) console.error(error)\n}\n\n// fsevents instance helper functions\n\n// object to hold per-process fsevents instances\n// (may be shared across chokidar FSWatcher instances)\nvar FSEventsWatchers = Object.create(null);\n\n// Threshold of duplicate path prefixes at which to start\n// consolidating going forward\nvar consolidateThreshhold = 10;\n\n// Private function: Instantiates the fsevents interface\n\n// * path       - string, path to be watched\n// * callback   - function, called when fsevents is bound and ready\n\n// Returns new fsevents instance\nfunction createFSEventsInstance(path, callback) {\n  return (new fsevents(path)).on('fsevent', callback).start();\n}\n\n// Private function: Instantiates the fsevents interface or binds listeners\n// to an existing one covering the same file tree\n\n// * path       - string, path to be watched\n// * realPath   - string, real path (in case of symlinks)\n// * listener   - function, called when fsevents emits events\n// * rawEmitter - function, passes data to listeners of the 'raw' event\n\n// Returns close function\nfunction setFSEventsListener(path, realPath, listener, rawEmitter) {\n  var watchPath = sysPath.extname(path) ? sysPath.dirname(path) : path;\n  var watchContainer;\n  var parentPath = sysPath.dirname(watchPath);\n\n  // If we've accumulated a substantial number of paths that\n  // could have been consolidated by watching one directory\n  // above the current one, create a watcher on the parent\n  // path instead, so that we do consolidate going forward.\n  if (couldConsolidate(parentPath)) {\n    watchPath = parentPath;\n  }\n\n  var resolvedPath = sysPath.resolve(path);\n  var hasSymlink = resolvedPath !== realPath;\n  function filteredListener(fullPath, flags, info) {\n    if (hasSymlink) fullPath = fullPath.replace(realPath, resolvedPath);\n    if (\n      fullPath === resolvedPath ||\n      !fullPath.indexOf(resolvedPath + sysPath.sep)\n    ) listener(fullPath, flags, info);\n  }\n\n  // check if there is already a watcher on a parent path\n  // modifies `watchPath` to the parent path when it finds a match\n  function watchedParent() {\n    return Object.keys(FSEventsWatchers).some(function(watchedPath) {\n      // condition is met when indexOf returns 0\n      if (!realPath.indexOf(sysPath.resolve(watchedPath) + sysPath.sep)) {\n        watchPath = watchedPath;\n        return true;\n      }\n    });\n  }\n\n  if (watchPath in FSEventsWatchers || watchedParent()) {\n    watchContainer = FSEventsWatchers[watchPath];\n    watchContainer.listeners.push(filteredListener);\n  } else {\n    watchContainer = FSEventsWatchers[watchPath] = {\n      listeners: [filteredListener],\n      rawEmitters: [rawEmitter],\n      watcher: createFSEventsInstance(watchPath, function(fullPath, flags) {\n        var info = fsevents.getInfo(fullPath, flags);\n        watchContainer.listeners.forEach(function(listener) {\n          listener(fullPath, flags, info);\n        });\n        watchContainer.rawEmitters.forEach(function(emitter) {\n          emitter(info.event, fullPath, info);\n        });\n      })\n    };\n  }\n  var listenerIndex = watchContainer.listeners.length - 1;\n\n  // removes this instance's listeners and closes the underlying fsevents\n  // instance if there are no more listeners left\n  return function close() {\n    delete watchContainer.listeners[listenerIndex];\n    delete watchContainer.rawEmitters[listenerIndex];\n    if (!Object.keys(watchContainer.listeners).length) {\n      watchContainer.watcher.stop();\n      delete FSEventsWatchers[watchPath];\n    }\n  };\n}\n\n// Decide whether or not we should start a new higher-level\n// parent watcher\nfunction couldConsolidate(path) {\n  var keys = Object.keys(FSEventsWatchers);\n  var count = 0;\n\n  for (var i = 0, len = keys.length; i < len; ++i) {\n    var watchPath = keys[i];\n    if (watchPath.indexOf(path) === 0) {\n      count++;\n      if (count >= consolidateThreshhold) {\n        return true;\n      }\n    }\n  }\n\n  return false;\n}\n\nfunction isConstructor(obj) {\n  return obj.prototype !== undefined && obj.prototype.constructor !== undefined;\n}\n\n// returns boolean indicating whether fsevents can be used\nfunction canUse() {\n  return fsevents && Object.keys(FSEventsWatchers).length < 128 && isConstructor(fsevents);\n}\n\n// determines subdirectory traversal levels from root to path\nfunction depth(path, root) {\n  var i = 0;\n  while (!path.indexOf(root) && (path = sysPath.dirname(path)) !== root) i++;\n  return i;\n}\n\n// fake constructor for attaching fsevents-specific prototype methods that\n// will be copied to FSWatcher's prototype\nfunction FsEventsHandler() {}\n\n// Private method: Handle symlinks encountered during directory scan\n\n// * watchPath  - string, file/dir path to be watched with fsevents\n// * realPath   - string, real path (in case of symlinks)\n// * transform  - function, path transformer\n// * globFilter - function, path filter in case a glob pattern was provided\n\n// Returns close function for the watcher instance\nFsEventsHandler.prototype._watchWithFsEvents =\nfunction(watchPath, realPath, transform, globFilter) {\n  if (this._isIgnored(watchPath)) return;\n  var watchCallback = function(fullPath, flags, info) {\n    if (\n      this.options.depth !== undefined &&\n      depth(fullPath, realPath) > this.options.depth\n    ) return;\n    var path = transform(sysPath.join(\n      watchPath, sysPath.relative(watchPath, fullPath)\n    ));\n    if (globFilter && !globFilter(path)) return;\n    // ensure directories are tracked\n    var parent = sysPath.dirname(path);\n    var item = sysPath.basename(path);\n    var watchedDir = this._getWatchedDir(\n      info.type === 'directory' ? path : parent\n    );\n    var checkIgnored = function(stats) {\n      if (this._isIgnored(path, stats)) {\n        this._ignoredPaths[path] = true;\n        if (stats && stats.isDirectory()) {\n          this._ignoredPaths[path + '/**/*'] = true;\n        }\n        return true;\n      } else {\n        delete this._ignoredPaths[path];\n        delete this._ignoredPaths[path + '/**/*'];\n      }\n    }.bind(this);\n\n    var handleEvent = function(event) {\n      if (checkIgnored()) return;\n\n      if (event === 'unlink') {\n        // suppress unlink events on never before seen files\n        if (info.type === 'directory' || watchedDir.has(item)) {\n          this._remove(parent, item);\n        }\n      } else {\n        if (event === 'add') {\n          // track new directories\n          if (info.type === 'directory') this._getWatchedDir(path);\n\n          if (info.type === 'symlink' && this.options.followSymlinks) {\n            // push symlinks back to the top of the stack to get handled\n            var curDepth = this.options.depth === undefined ?\n              undefined : depth(fullPath, realPath) + 1;\n            return this._addToFsEvents(path, false, true, curDepth);\n          } else {\n            // track new paths\n            // (other than symlinks being followed, which will be tracked soon)\n            this._getWatchedDir(parent).add(item);\n          }\n        }\n        var eventName = info.type === 'directory' ? event + 'Dir' : event;\n        this._emit(eventName, path);\n        if (eventName === 'addDir') this._addToFsEvents(path, false, true);\n      }\n    }.bind(this);\n\n    function addOrChange() {\n      handleEvent(watchedDir.has(item) ? 'change' : 'add');\n    }\n    function checkFd() {\n      fs.open(path, 'r', function(error, fd) {\n        if (error) {\n          error.code !== 'EACCES' ?\n            handleEvent('unlink') : addOrChange();\n        } else {\n          fs.close(fd, function(err) {\n            err && err.code !== 'EACCES' ?\n              handleEvent('unlink') : addOrChange();\n          });\n        }\n      });\n    }\n    // correct for wrong events emitted\n    var wrongEventFlags = [\n      69888, 70400, 71424, 72704, 73472, 131328, 131840, 262912\n    ];\n    if (wrongEventFlags.indexOf(flags) !== -1 || info.event === 'unknown') {\n      if (typeof this.options.ignored === 'function') {\n        fs.stat(path, function(error, stats) {\n          if (checkIgnored(stats)) return;\n          stats ? addOrChange() : handleEvent('unlink');\n        });\n      } else {\n        checkFd();\n      }\n    } else {\n      switch (info.event) {\n      case 'created':\n      case 'modified':\n        return addOrChange();\n      case 'deleted':\n      case 'moved':\n        return checkFd();\n      }\n    }\n  }.bind(this);\n\n  var closer = setFSEventsListener(\n    watchPath,\n    realPath,\n    watchCallback,\n    this.emit.bind(this, 'raw')\n  );\n\n  this._emitReady();\n  return closer;\n};\n\n// Private method: Handle symlinks encountered during directory scan\n\n// * linkPath   - string, path to symlink\n// * fullPath   - string, absolute path to the symlink\n// * transform  - function, pre-existing path transformer\n// * curDepth   - int, level of subdirectories traversed to where symlink is\n\n// Returns nothing\nFsEventsHandler.prototype._handleFsEventsSymlink =\nfunction(linkPath, fullPath, transform, curDepth) {\n  // don't follow the same symlink more than once\n  if (this._symlinkPaths[fullPath]) return;\n  else this._symlinkPaths[fullPath] = true;\n\n  this._readyCount++;\n\n  fs.realpath(linkPath, function(error, linkTarget) {\n    if (this._handleError(error) || this._isIgnored(linkTarget)) {\n      return this._emitReady();\n    }\n\n    this._readyCount++;\n\n    // add the linkTarget for watching with a wrapper for transform\n    // that causes emitted paths to incorporate the link's path\n    this._addToFsEvents(linkTarget || linkPath, function(path) {\n      var dotSlash = '.' + sysPath.sep;\n      var aliasedPath = linkPath;\n      if (linkTarget && linkTarget !== dotSlash) {\n        aliasedPath = path.replace(linkTarget, linkPath);\n      } else if (path !== dotSlash) {\n        aliasedPath = sysPath.join(linkPath, path);\n      }\n      return transform(aliasedPath);\n    }, false, curDepth);\n  }.bind(this));\n};\n\n// Private method: Handle added path with fsevents\n\n// * path       - string, file/directory path or glob pattern\n// * transform  - function, converts working path to what the user expects\n// * forceAdd   - boolean, ensure add is emitted\n// * priorDepth - int, level of subdirectories already traversed\n\n// Returns nothing\nFsEventsHandler.prototype._addToFsEvents =\nfunction(path, transform, forceAdd, priorDepth) {\n\n  // applies transform if provided, otherwise returns same value\n  var processPath = typeof transform === 'function' ?\n    transform : function(val) { return val; };\n\n  var emitAdd = function(newPath, stats) {\n    var pp = processPath(newPath);\n    var isDir = stats.isDirectory();\n    var dirObj = this._getWatchedDir(sysPath.dirname(pp));\n    var base = sysPath.basename(pp);\n\n    // ensure empty dirs get tracked\n    if (isDir) this._getWatchedDir(pp);\n\n    if (dirObj.has(base)) return;\n    dirObj.add(base);\n\n    if (!this.options.ignoreInitial || forceAdd === true) {\n      this._emit(isDir ? 'addDir' : 'add', pp, stats);\n    }\n  }.bind(this);\n\n  var wh = this._getWatchHelpers(path);\n\n  // evaluate what is at the path we're being asked to watch\n  fs[wh.statMethod](wh.watchPath, function(error, stats) {\n    if (this._handleError(error) || this._isIgnored(wh.watchPath, stats)) {\n      this._emitReady();\n      return this._emitReady();\n    }\n\n    if (stats.isDirectory()) {\n      // emit addDir unless this is a glob parent\n      if (!wh.globFilter) emitAdd(processPath(path), stats);\n\n      // don't recurse further if it would exceed depth setting\n      if (priorDepth && priorDepth > this.options.depth) return;\n\n      // scan the contents of the dir\n      readdirp({\n        root: wh.watchPath,\n        entryType: 'all',\n        fileFilter: wh.filterPath,\n        directoryFilter: wh.filterDir,\n        lstat: true,\n        depth: this.options.depth - (priorDepth || 0)\n      }).on('data', function(entry) {\n        // need to check filterPath on dirs b/c filterDir is less restrictive\n        if (entry.stat.isDirectory() && !wh.filterPath(entry)) return;\n\n        var joinedPath = sysPath.join(wh.watchPath, entry.path);\n        var fullPath = entry.fullPath;\n\n        if (wh.followSymlinks && entry.stat.isSymbolicLink()) {\n          // preserve the current depth here since it can't be derived from\n          // real paths past the symlink\n          var curDepth = this.options.depth === undefined ?\n            undefined : depth(joinedPath, sysPath.resolve(wh.watchPath)) + 1;\n\n          this._handleFsEventsSymlink(joinedPath, fullPath, processPath, curDepth);\n        } else {\n          emitAdd(joinedPath, entry.stat);\n        }\n      }.bind(this)).on('error', function() {\n        // Ignore readdirp errors\n      }).on('end', this._emitReady);\n    } else {\n      emitAdd(wh.watchPath, stats);\n      this._emitReady();\n    }\n  }.bind(this));\n\n  if (this.options.persistent && forceAdd !== true) {\n    var initWatch = function(error, realPath) {\n      if (this.closed) return;\n      var closer = this._watchWithFsEvents(\n        wh.watchPath,\n        sysPath.resolve(realPath || wh.watchPath),\n        processPath,\n        wh.globFilter\n      );\n      if (closer) {\n        this._closers[path] = this._closers[path] || [];\n        this._closers[path].push(closer);\n      }\n    }.bind(this);\n\n    if (typeof transform === 'function') {\n      // realpath has already been resolved\n      initWatch();\n    } else {\n      fs.realpath(wh.watchPath, initWatch);\n    }\n  }\n};\n\nmodule.exports = FsEventsHandler;\nmodule.exports.canUse = canUse;\n"]},"metadata":{},"sourceType":"script"}