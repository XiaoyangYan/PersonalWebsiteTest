{"ast":null,"code":"/**\r\n * Archiver Core\r\n *\r\n * @ignore\r\n * @license [MIT]{@link https://github.com/archiverjs/node-archiver/blob/master/LICENSE}\r\n * @copyright (c) 2012-2014 Chris Talkington, contributors.\r\n */\nvar fs = require('fs');\n\nvar glob = require('glob');\n\nvar async = require('async');\n\nvar path = require('path');\n\nvar util = require('archiver-utils');\n\nvar inherits = require('util').inherits;\n\nvar ArchiverError = require('./error');\n\nvar Transform = require('readable-stream').Transform;\n\nvar win32 = process.platform === 'win32';\n/**\r\n * @constructor\r\n * @param {String} format The archive format to use.\r\n * @param {(CoreOptions|TransformOptions)} options See also {@link ZipOptions} and {@link TarOptions}.\r\n */\n\nvar Archiver = function (format, options) {\n  if (!(this instanceof Archiver)) {\n    return new Archiver(format, options);\n  }\n\n  if (typeof format !== 'string') {\n    options = format;\n    format = 'zip';\n  }\n\n  options = this.options = util.defaults(options, {\n    highWaterMark: 1024 * 1024,\n    statConcurrency: 4\n  });\n  Transform.call(this, options);\n  this._format = false;\n  this._module = false;\n  this._pending = 0;\n  this._pointer = 0;\n  this._entriesCount = 0;\n  this._entriesProcessedCount = 0;\n  this._fsEntriesTotalBytes = 0;\n  this._fsEntriesProcessedBytes = 0;\n  this._queue = async.queue(this._onQueueTask.bind(this), 1);\n  this._queue.drain = this._onQueueDrain.bind(this);\n  this._statQueue = async.queue(this._onStatQueueTask.bind(this), options.statConcurrency);\n  this._state = {\n    aborted: false,\n    finalize: false,\n    finalizing: false,\n    finalized: false,\n    modulePiped: false\n  };\n  this._streams = [];\n};\n\ninherits(Archiver, Transform);\n/**\r\n * Internal logic for `abort`.\r\n *\r\n * @private\r\n * @return void\r\n */\n\nArchiver.prototype._abort = function () {\n  this._state.aborted = true;\n\n  this._queue.kill();\n\n  this._statQueue.kill();\n\n  if (this._queue.idle()) {\n    this._shutdown();\n  }\n};\n/**\r\n * Internal helper for appending files.\r\n *\r\n * @private\r\n * @param  {String} filepath The source filepath.\r\n * @param  {EntryData} data The entry data.\r\n * @return void\r\n */\n\n\nArchiver.prototype._append = function (filepath, data) {\n  data = data || {};\n  var task = {\n    source: null,\n    filepath: filepath\n  };\n\n  if (!data.name) {\n    data.name = filepath;\n  }\n\n  data.sourcePath = filepath;\n  task.data = data;\n  this._entriesCount++;\n\n  if (data.stats && data.stats instanceof fs.Stats) {\n    task = this._updateQueueTaskWithStats(task, data.stats);\n\n    if (task) {\n      if (data.stats.size) {\n        this._fsEntriesTotalBytes += data.stats.size;\n      }\n\n      this._queue.push(task);\n    }\n  } else {\n    this._statQueue.push(task);\n  }\n};\n/**\r\n * Internal logic for `finalize`.\r\n *\r\n * @private\r\n * @return void\r\n */\n\n\nArchiver.prototype._finalize = function () {\n  if (this._state.finalizing || this._state.finalized || this._state.aborted) {\n    return;\n  }\n\n  this._state.finalizing = true;\n\n  this._moduleFinalize();\n\n  this._state.finalizing = false;\n  this._state.finalized = true;\n};\n/**\r\n * Checks the various state variables to determine if we can `finalize`.\r\n *\r\n * @private\r\n * @return {Boolean}\r\n */\n\n\nArchiver.prototype._maybeFinalize = function () {\n  if (this._state.finalizing || this._state.finalized || this._state.aborted) {\n    return false;\n  }\n\n  if (this._state.finalize && this._pending === 0 && this._queue.idle() && this._statQueue.idle()) {\n    this._finalize();\n\n    return true;\n  }\n\n  return false;\n};\n/**\r\n * Appends an entry to the module.\r\n *\r\n * @private\r\n * @fires  Archiver#entry\r\n * @param  {(Buffer|Stream)} source\r\n * @param  {EntryData} data\r\n * @param  {Function} callback\r\n * @return void\r\n */\n\n\nArchiver.prototype._moduleAppend = function (source, data, callback) {\n  if (this._state.aborted) {\n    callback();\n    return;\n  }\n\n  this._module.append(source, data, function (err) {\n    this._task = null;\n\n    if (this._state.aborted) {\n      this._shutdown();\n\n      return;\n    }\n\n    if (err) {\n      this.emit('error', err);\n      setImmediate(callback);\n      return;\n    }\n    /**\r\n     * Fires when the entry's input has been processed and appended to the archive.\r\n     *\r\n     * @event Archiver#entry\r\n     * @type {EntryData}\r\n     */\n\n\n    this.emit('entry', data);\n    this._entriesProcessedCount++;\n\n    if (data.stats && data.stats.size) {\n      this._fsEntriesProcessedBytes += data.stats.size;\n    }\n    /**\r\n     * @event Archiver#progress\r\n     * @type {ProgressData}\r\n     */\n\n\n    this.emit('progress', {\n      entries: {\n        total: this._entriesCount,\n        processed: this._entriesProcessedCount\n      },\n      fs: {\n        totalBytes: this._fsEntriesTotalBytes,\n        processedBytes: this._fsEntriesProcessedBytes\n      }\n    });\n    setImmediate(callback);\n  }.bind(this));\n};\n/**\r\n * Finalizes the module.\r\n *\r\n * @private\r\n * @return void\r\n */\n\n\nArchiver.prototype._moduleFinalize = function () {\n  if (typeof this._module.finalize === 'function') {\n    this._module.finalize();\n  } else if (typeof this._module.end === 'function') {\n    this._module.end();\n  } else {\n    this.emit('error', new ArchiverError('NOENDMETHOD'));\n  }\n};\n/**\r\n * Pipes the module to our internal stream with error bubbling.\r\n *\r\n * @private\r\n * @return void\r\n */\n\n\nArchiver.prototype._modulePipe = function () {\n  this._module.on('error', this._onModuleError.bind(this));\n\n  this._module.pipe(this);\n\n  this._state.modulePiped = true;\n};\n/**\r\n * Determines if the current module supports a defined feature.\r\n *\r\n * @private\r\n * @param  {String} key\r\n * @return {Boolean}\r\n */\n\n\nArchiver.prototype._moduleSupports = function (key) {\n  if (!this._module.supports || !this._module.supports[key]) {\n    return false;\n  }\n\n  return this._module.supports[key];\n};\n/**\r\n * Unpipes the module from our internal stream.\r\n *\r\n * @private\r\n * @return void\r\n */\n\n\nArchiver.prototype._moduleUnpipe = function () {\n  this._module.unpipe(this);\n\n  this._state.modulePiped = false;\n};\n/**\r\n * Normalizes entry data with fallbacks for key properties.\r\n *\r\n * @private\r\n * @param  {Object} data\r\n * @param  {fs.Stats} stats\r\n * @return {Object}\r\n */\n\n\nArchiver.prototype._normalizeEntryData = function (data, stats) {\n  data = util.defaults(data, {\n    type: 'file',\n    name: null,\n    date: null,\n    mode: null,\n    prefix: null,\n    sourcePath: null,\n    stats: false\n  });\n\n  if (stats && data.stats === false) {\n    data.stats = stats;\n  }\n\n  var isDir = data.type === 'directory';\n\n  if (data.name) {\n    if (typeof data.prefix === 'string' && '' !== data.prefix) {\n      data.name = data.prefix + '/' + data.name;\n      data.prefix = null;\n    }\n\n    data.name = util.sanitizePath(data.name);\n\n    if (data.type !== 'symlink' && data.name.slice(-1) === '/') {\n      isDir = true;\n      data.type = 'directory';\n    } else if (isDir) {\n      data.name += '/';\n    }\n  } // 511 === 0777; 493 === 0755; 438 === 0666; 420 === 0644\n\n\n  if (typeof data.mode === 'number') {\n    if (win32) {\n      data.mode &= 511;\n    } else {\n      data.mode &= 4095;\n    }\n  } else if (data.stats && data.mode === null) {\n    if (win32) {\n      data.mode = data.stats.mode & 511;\n    } else {\n      data.mode = data.stats.mode & 4095;\n    } // stat isn't reliable on windows; force 0755 for dir\n\n\n    if (win32 && isDir) {\n      data.mode = 493;\n    }\n  } else if (data.mode === null) {\n    data.mode = isDir ? 493 : 420;\n  }\n\n  if (data.stats && data.date === null) {\n    data.date = data.stats.mtime;\n  } else {\n    data.date = util.dateify(data.date);\n  }\n\n  return data;\n};\n/**\r\n * Error listener that re-emits error on to our internal stream.\r\n *\r\n * @private\r\n * @param  {Error} err\r\n * @return void\r\n */\n\n\nArchiver.prototype._onModuleError = function (err) {\n  /**\r\n   * @event Archiver#error\r\n   * @type {ErrorData}\r\n   */\n  this.emit('error', err);\n};\n/**\r\n * Checks the various state variables after queue has drained to determine if\r\n * we need to `finalize`.\r\n *\r\n * @private\r\n * @return void\r\n */\n\n\nArchiver.prototype._onQueueDrain = function () {\n  if (this._state.finalizing || this._state.finalized || this._state.aborted) {\n    return;\n  }\n\n  if (this._state.finalize && this._pending === 0 && this._queue.idle() && this._statQueue.idle()) {\n    this._finalize();\n  }\n};\n/**\r\n * Appends each queue task to the module.\r\n *\r\n * @private\r\n * @param  {Object} task\r\n * @param  {Function} callback\r\n * @return void\r\n */\n\n\nArchiver.prototype._onQueueTask = function (task, callback) {\n  if (this._state.finalizing || this._state.finalized || this._state.aborted) {\n    callback();\n    return;\n  }\n\n  this._task = task;\n\n  this._moduleAppend(task.source, task.data, callback);\n};\n/**\r\n * Performs a file stat and reinjects the task back into the queue.\r\n *\r\n * @private\r\n * @param  {Object} task\r\n * @param  {Function} callback\r\n * @return void\r\n */\n\n\nArchiver.prototype._onStatQueueTask = function (task, callback) {\n  if (this._state.finalizing || this._state.finalized || this._state.aborted) {\n    callback();\n    return;\n  }\n\n  fs.lstat(task.filepath, function (err, stats) {\n    if (this._state.aborted) {\n      setImmediate(callback);\n      return;\n    }\n\n    if (err) {\n      this._entriesCount--;\n      /**\r\n       * @event Archiver#warning\r\n       * @type {ErrorData}\r\n       */\n\n      this.emit('warning', err);\n      setImmediate(callback);\n      return;\n    }\n\n    task = this._updateQueueTaskWithStats(task, stats);\n\n    if (task) {\n      if (stats.size) {\n        this._fsEntriesTotalBytes += stats.size;\n      }\n\n      this._queue.push(task);\n    }\n\n    setImmediate(callback);\n  }.bind(this));\n};\n/**\r\n * Unpipes the module and ends our internal stream.\r\n *\r\n * @private\r\n * @return void\r\n */\n\n\nArchiver.prototype._shutdown = function () {\n  this._moduleUnpipe();\n\n  this.end();\n};\n/**\r\n * Tracks the bytes emitted by our internal stream.\r\n *\r\n * @private\r\n * @param  {Buffer} chunk\r\n * @param  {String} encoding\r\n * @param  {Function} callback\r\n * @return void\r\n */\n\n\nArchiver.prototype._transform = function (chunk, encoding, callback) {\n  if (chunk) {\n    this._pointer += chunk.length;\n  }\n\n  callback(null, chunk);\n};\n/**\r\n * Updates and normalizes a queue task using stats data.\r\n *\r\n * @private\r\n * @param  {Object} task\r\n * @param  {fs.Stats} stats\r\n * @return {Object}\r\n */\n\n\nArchiver.prototype._updateQueueTaskWithStats = function (task, stats) {\n  if (stats.isFile()) {\n    task.data.type = 'file';\n    task.data.sourceType = 'stream';\n    task.source = util.lazyReadStream(task.filepath);\n  } else if (stats.isDirectory() && this._moduleSupports('directory')) {\n    task.data.name = util.trailingSlashIt(task.data.name);\n    task.data.type = 'directory';\n    task.data.sourcePath = util.trailingSlashIt(task.filepath);\n    task.data.sourceType = 'buffer';\n    task.source = Buffer.concat([]);\n  } else if (stats.isSymbolicLink() && this._moduleSupports('symlink')) {\n    var linkPath = fs.readlinkSync(task.filepath);\n    var dirName = path.dirname(task.filepath);\n    task.data.type = 'symlink';\n    task.data.linkname = path.relative(dirName, path.resolve(dirName, linkPath));\n    task.data.sourceType = 'buffer';\n    task.source = Buffer.concat([]);\n  } else {\n    if (stats.isDirectory()) {\n      this.emit('warning', new ArchiverError('DIRECTORYNOTSUPPORTED', task.data));\n    } else if (stats.isSymbolicLink()) {\n      this.emit('warning', new ArchiverError('SYMLINKNOTSUPPORTED', task.data));\n    } else {\n      this.emit('warning', new ArchiverError('ENTRYNOTSUPPORTED', task.data));\n    }\n\n    return null;\n  }\n\n  task.data = this._normalizeEntryData(task.data, stats);\n  return task;\n};\n/**\r\n * Aborts the archiving process, taking a best-effort approach, by:\r\n *\r\n * - removing any pending queue tasks\r\n * - allowing any active queue workers to finish\r\n * - detaching internal module pipes\r\n * - ending both sides of the Transform stream\r\n *\r\n * It will NOT drain any remaining sources.\r\n *\r\n * @return {this}\r\n */\n\n\nArchiver.prototype.abort = function () {\n  if (this._state.aborted || this._state.finalized) {\n    return this;\n  }\n\n  this._abort();\n\n  return this;\n};\n/**\r\n * Appends an input source (text string, buffer, or stream) to the instance.\r\n *\r\n * When the instance has received, processed, and emitted the input, the `entry`\r\n * event is fired.\r\n *\r\n * @fires  Archiver#entry\r\n * @param  {(Buffer|Stream|String)} source The input source.\r\n * @param  {EntryData} data See also {@link ZipEntryData} and {@link TarEntryData}.\r\n * @return {this}\r\n */\n\n\nArchiver.prototype.append = function (source, data) {\n  if (this._state.finalize || this._state.aborted) {\n    this.emit('error', new ArchiverError('QUEUECLOSED'));\n    return this;\n  }\n\n  data = this._normalizeEntryData(data);\n\n  if (typeof data.name !== 'string' || data.name.length === 0) {\n    this.emit('error', new ArchiverError('ENTRYNAMEREQUIRED'));\n    return this;\n  }\n\n  if (data.type === 'directory' && !this._moduleSupports('directory')) {\n    this.emit('error', new ArchiverError('DIRECTORYNOTSUPPORTED', {\n      name: data.name\n    }));\n    return this;\n  }\n\n  source = util.normalizeInputSource(source);\n\n  if (Buffer.isBuffer(source)) {\n    data.sourceType = 'buffer';\n  } else if (util.isStream(source)) {\n    data.sourceType = 'stream';\n  } else {\n    this.emit('error', new ArchiverError('INPUTSTEAMBUFFERREQUIRED', {\n      name: data.name\n    }));\n    return this;\n  }\n\n  this._entriesCount++;\n\n  this._queue.push({\n    data: data,\n    source: source\n  });\n\n  return this;\n};\n/**\r\n * Appends a directory and its files, recursively, given its dirpath.\r\n *\r\n * @param  {String} dirpath The source directory path.\r\n * @param  {String} destpath The destination path within the archive.\r\n * @param  {(EntryData|Function)} data See also [ZipEntryData]{@link ZipEntryData} and\r\n * [TarEntryData]{@link TarEntryData}.\r\n * @return {this}\r\n */\n\n\nArchiver.prototype.directory = function (dirpath, destpath, data) {\n  if (this._state.finalize || this._state.aborted) {\n    this.emit('error', new ArchiverError('QUEUECLOSED'));\n    return this;\n  }\n\n  if (typeof dirpath !== 'string' || dirpath.length === 0) {\n    this.emit('error', new ArchiverError('DIRECTORYDIRPATHREQUIRED'));\n    return this;\n  }\n\n  this._pending++;\n\n  if (destpath === false) {\n    destpath = '';\n  } else if (typeof destpath !== 'string') {\n    destpath = dirpath;\n  }\n\n  var dataFunction = false;\n\n  if (typeof data === 'function') {\n    dataFunction = data;\n    data = {};\n  } else if (typeof data !== 'object') {\n    data = {};\n  }\n\n  var globOptions = {\n    stat: false,\n    dot: true,\n    cwd: dirpath\n  };\n\n  function onGlobEnd() {\n    this._pending--;\n\n    this._maybeFinalize();\n  }\n\n  function onGlobError(err) {\n    this.emit('error', err);\n  }\n\n  function onGlobMatch(match) {\n    var ignoreMatch = false;\n    var entryData = Object.assign({}, data);\n    entryData.name = match;\n    entryData.prefix = destpath;\n    match = globber._makeAbs(match);\n\n    try {\n      if (dataFunction) {\n        entryData = dataFunction(entryData);\n\n        if (entryData === false) {\n          ignoreMatch = true;\n        } else if (typeof entryData !== 'object') {\n          throw new ArchiverError('DIRECTORYFUNCTIONINVALIDDATA', {\n            dirpath: dirpath\n          });\n        }\n      }\n    } catch (e) {\n      this.emit('error', e);\n      return;\n    }\n\n    if (ignoreMatch) {\n      return;\n    }\n\n    this._append(match, entryData);\n  }\n\n  var globber = glob('**', globOptions);\n  globber.on('error', onGlobError.bind(this));\n  globber.on('match', onGlobMatch.bind(this));\n  globber.on('end', onGlobEnd.bind(this));\n  return this;\n};\n/**\r\n * Appends a file given its filepath using a\r\n * [lazystream]{@link https://github.com/jpommerening/node-lazystream} wrapper to\r\n * prevent issues with open file limits.\r\n *\r\n * When the instance has received, processed, and emitted the file, the `entry`\r\n * event is fired.\r\n *\r\n * @param  {String} filepath The source filepath.\r\n * @param  {EntryData} data See also [ZipEntryData]{@link ZipEntryData} and\r\n * [TarEntryData]{@link TarEntryData}.\r\n * @return {this}\r\n */\n\n\nArchiver.prototype.file = function (filepath, data) {\n  if (this._state.finalize || this._state.aborted) {\n    this.emit('error', new ArchiverError('QUEUECLOSED'));\n    return this;\n  }\n\n  if (typeof filepath !== 'string' || filepath.length === 0) {\n    this.emit('error', new ArchiverError('FILEFILEPATHREQUIRED'));\n    return this;\n  }\n\n  this._append(filepath, data);\n\n  return this;\n};\n/**\r\n * Appends multiple files that match a glob pattern.\r\n *\r\n * @param  {String} pattern The [glob pattern]{@link https://github.com/isaacs/node-glob#glob-primer} to match.\r\n * @param  {Object} options See [node-glob]{@link https://github.com/isaacs/node-glob#options}.\r\n * @param  {EntryData} data See also [ZipEntryData]{@link ZipEntryData} and\r\n * [TarEntryData]{@link TarEntryData}.\r\n * @return {this}\r\n */\n\n\nArchiver.prototype.glob = function (pattern, options, data) {\n  this._pending++;\n  options = util.defaults(options, {\n    stat: false\n  });\n\n  function onGlobEnd() {\n    this._pending--;\n\n    this._maybeFinalize();\n  }\n\n  function onGlobError(err) {\n    this.emit('error', err);\n  }\n\n  function onGlobMatch(match) {\n    var entryData = Object.assign({}, data);\n\n    if (options.cwd) {\n      entryData.name = match;\n      match = globber._makeAbs(match);\n    }\n\n    this._append(match, entryData);\n  }\n\n  var globber = glob(pattern, options);\n  globber.on('error', onGlobError.bind(this));\n  globber.on('match', onGlobMatch.bind(this));\n  globber.on('end', onGlobEnd.bind(this));\n  return this;\n};\n/**\r\n * Finalizes the instance and prevents further appending to the archive\r\n * structure (queue will continue til drained).\r\n *\r\n * The `end`, `close` or `finish` events on the destination stream may fire\r\n * right after calling this method so you should set listeners beforehand to\r\n * properly detect stream completion.\r\n *\r\n * @return {this}\r\n */\n\n\nArchiver.prototype.finalize = function () {\n  if (this._state.aborted) {\n    this.emit('error', new ArchiverError('ABORTED'));\n    return this;\n  }\n\n  if (this._state.finalize) {\n    this.emit('error', new ArchiverError('FINALIZING'));\n    return this;\n  }\n\n  this._state.finalize = true;\n\n  if (this._pending === 0 && this._queue.idle() && this._statQueue.idle()) {\n    this._finalize();\n  }\n\n  var self = this;\n  return new Promise(function (resolve, reject) {\n    var errored;\n\n    self._module.on('end', function () {\n      if (!errored) {\n        resolve();\n      }\n    });\n\n    self._module.on('error', function (err) {\n      errored = true;\n      reject(err);\n    });\n  });\n};\n/**\r\n * Sets the module format name used for archiving.\r\n *\r\n * @param {String} format The name of the format.\r\n * @return {this}\r\n */\n\n\nArchiver.prototype.setFormat = function (format) {\n  if (this._format) {\n    this.emit('error', new ArchiverError('FORMATSET'));\n    return this;\n  }\n\n  this._format = format;\n  return this;\n};\n/**\r\n * Sets the module used for archiving.\r\n *\r\n * @param {Function} module The function for archiver to interact with.\r\n * @return {this}\r\n */\n\n\nArchiver.prototype.setModule = function (module) {\n  if (this._state.aborted) {\n    this.emit('error', new ArchiverError('ABORTED'));\n    return this;\n  }\n\n  if (this._state.module) {\n    this.emit('error', new ArchiverError('MODULESET'));\n    return this;\n  }\n\n  this._module = module;\n\n  this._modulePipe();\n\n  return this;\n};\n/**\r\n * Appends a symlink to the instance.\r\n *\r\n * This does NOT interact with filesystem and is used for programmatically creating symlinks.\r\n *\r\n * @param  {String} filepath The symlink path (within archive).\r\n * @param  {String} target The target path (within archive).\r\n * @return {this}\r\n */\n\n\nArchiver.prototype.symlink = function (filepath, target) {\n  if (this._state.finalize || this._state.aborted) {\n    this.emit('error', new ArchiverError('QUEUECLOSED'));\n    return this;\n  }\n\n  if (typeof filepath !== 'string' || filepath.length === 0) {\n    this.emit('error', new ArchiverError('SYMLINKFILEPATHREQUIRED'));\n    return this;\n  }\n\n  if (typeof target !== 'string' || target.length === 0) {\n    this.emit('error', new ArchiverError('SYMLINKTARGETREQUIRED', {\n      filepath: filepath\n    }));\n    return this;\n  }\n\n  if (!this._moduleSupports('symlink')) {\n    this.emit('error', new ArchiverError('SYMLINKNOTSUPPORTED', {\n      filepath: filepath\n    }));\n    return this;\n  }\n\n  var data = {};\n  data.type = 'symlink';\n  data.name = filepath.replace(/\\\\/g, '/');\n  data.linkname = target.replace(/\\\\/g, '/');\n  data.sourceType = 'buffer';\n  this._entriesCount++;\n\n  this._queue.push({\n    data: data,\n    source: Buffer.concat([])\n  });\n\n  return this;\n};\n/**\r\n * Returns the current length (in bytes) that has been emitted.\r\n *\r\n * @return {Number}\r\n */\n\n\nArchiver.prototype.pointer = function () {\n  return this._pointer;\n};\n/**\r\n * Middleware-like helper that has yet to be fully implemented.\r\n *\r\n * @private\r\n * @param  {Function} plugin\r\n * @return {this}\r\n */\n\n\nArchiver.prototype.use = function (plugin) {\n  this._streams.push(plugin);\n\n  return this;\n};\n\nmodule.exports = Archiver;\n/**\r\n * @typedef {Object} CoreOptions\r\n * @global\r\n * @property {Number} [statConcurrency=4] Sets the number of workers used to\r\n * process the internal fs stat queue.\r\n */\n\n/**\r\n * @typedef {Object} TransformOptions\r\n * @property {Boolean} [allowHalfOpen=true] If set to false, then the stream\r\n * will automatically end the readable side when the writable side ends and vice\r\n * versa.\r\n * @property {Boolean} [readableObjectMode=false] Sets objectMode for readable\r\n * side of the stream. Has no effect if objectMode is true.\r\n * @property {Boolean} [writableObjectMode=false] Sets objectMode for writable\r\n * side of the stream. Has no effect if objectMode is true.\r\n * @property {Boolean} [decodeStrings=true] Whether or not to decode strings\r\n * into Buffers before passing them to _write(). `Writable`\r\n * @property {String} [encoding=NULL] If specified, then buffers will be decoded\r\n * to strings using the specified encoding. `Readable`\r\n * @property {Number} [highWaterMark=16kb] The maximum number of bytes to store\r\n * in the internal buffer before ceasing to read from the underlying resource.\r\n * `Readable` `Writable`\r\n * @property {Boolean} [objectMode=false] Whether this stream should behave as a\r\n * stream of objects. Meaning that stream.read(n) returns a single value instead\r\n * of a Buffer of size n. `Readable` `Writable`\r\n */\n\n/**\r\n * @typedef {Object} EntryData\r\n * @property {String} name Sets the entry name including internal path.\r\n * @property {(String|Date)} [date=NOW()] Sets the entry date.\r\n * @property {Number} [mode=D:0755/F:0644] Sets the entry permissions.\r\n * @property {String} [prefix] Sets a path prefix for the entry name. Useful\r\n * when working with methods like `directory` or `glob`.\r\n * @property {fs.Stats} [stats] Sets the fs stat data for this entry allowing\r\n * for reduction of fs stat calls when stat data is already known.\r\n */\n\n/**\r\n * @typedef {Object} ErrorData\r\n * @property {String} message The message of the error.\r\n * @property {String} code The error code assigned to this error.\r\n * @property {String} data Additional data provided for reporting or debugging (where available).\r\n */\n\n/**\r\n * @typedef {Object} ProgressData\r\n * @property {Object} entries\r\n * @property {Number} entries.total Number of entries that have been appended.\r\n * @property {Number} entries.processed Number of entries that have been processed.\r\n * @property {Object} fs\r\n * @property {Number} fs.totalBytes Number of bytes that have been appended. Calculated asynchronously and might not be accurate: it growth while entries are added. (based on fs.Stats)\r\n * @property {Number} fs.processedBytes Number of bytes that have been processed. (based on fs.Stats)\r\n */","map":{"version":3,"sources":["/home/yanxiaoyang/react-project/PersonalWebsiteTest/node_modules/archiver/lib/core.js"],"names":["fs","require","glob","async","path","util","inherits","ArchiverError","Transform","win32","process","platform","Archiver","format","options","defaults","highWaterMark","statConcurrency","call","_format","_module","_pending","_pointer","_entriesCount","_entriesProcessedCount","_fsEntriesTotalBytes","_fsEntriesProcessedBytes","_queue","queue","_onQueueTask","bind","drain","_onQueueDrain","_statQueue","_onStatQueueTask","_state","aborted","finalize","finalizing","finalized","modulePiped","_streams","prototype","_abort","kill","idle","_shutdown","_append","filepath","data","task","source","name","sourcePath","stats","Stats","_updateQueueTaskWithStats","size","push","_finalize","_moduleFinalize","_maybeFinalize","_moduleAppend","callback","append","err","_task","emit","setImmediate","entries","total","processed","totalBytes","processedBytes","end","_modulePipe","on","_onModuleError","pipe","_moduleSupports","key","supports","_moduleUnpipe","unpipe","_normalizeEntryData","type","date","mode","prefix","isDir","sanitizePath","slice","mtime","dateify","lstat","_transform","chunk","encoding","length","isFile","sourceType","lazyReadStream","isDirectory","trailingSlashIt","Buffer","concat","isSymbolicLink","linkPath","readlinkSync","dirName","dirname","linkname","relative","resolve","abort","normalizeInputSource","isBuffer","isStream","directory","dirpath","destpath","dataFunction","globOptions","stat","dot","cwd","onGlobEnd","onGlobError","onGlobMatch","match","ignoreMatch","entryData","Object","assign","globber","_makeAbs","e","file","pattern","self","Promise","reject","errored","setFormat","setModule","module","symlink","target","replace","pointer","use","plugin","exports"],"mappings":"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","sourcesContent":["/**\r\n * Archiver Core\r\n *\r\n * @ignore\r\n * @license [MIT]{@link https://github.com/archiverjs/node-archiver/blob/master/LICENSE}\r\n * @copyright (c) 2012-2014 Chris Talkington, contributors.\r\n */\r\nvar fs = require('fs');\r\nvar glob = require('glob');\r\nvar async = require('async');\r\nvar path = require('path');\r\nvar util = require('archiver-utils');\r\n\r\nvar inherits = require('util').inherits;\r\nvar ArchiverError = require('./error');\r\nvar Transform = require('readable-stream').Transform;\r\n\r\nvar win32 = process.platform === 'win32';\r\n\r\n/**\r\n * @constructor\r\n * @param {String} format The archive format to use.\r\n * @param {(CoreOptions|TransformOptions)} options See also {@link ZipOptions} and {@link TarOptions}.\r\n */\r\nvar Archiver = function(format, options) {\r\n  if (!(this instanceof Archiver)) {\r\n    return new Archiver(format, options);\r\n  }\r\n\r\n  if (typeof format !== 'string') {\r\n    options = format;\r\n    format = 'zip';\r\n  }\r\n\r\n  options = this.options = util.defaults(options, {\r\n    highWaterMark: 1024 * 1024,\r\n    statConcurrency: 4\r\n  });\r\n\r\n  Transform.call(this, options);\r\n\r\n  this._format = false;\r\n  this._module = false;\r\n  this._pending = 0;\r\n  this._pointer = 0;\r\n\r\n  this._entriesCount = 0;\r\n  this._entriesProcessedCount = 0;\r\n  this._fsEntriesTotalBytes = 0;\r\n  this._fsEntriesProcessedBytes = 0;\r\n\r\n  this._queue = async.queue(this._onQueueTask.bind(this), 1);\r\n  this._queue.drain = this._onQueueDrain.bind(this);\r\n\r\n  this._statQueue = async.queue(this._onStatQueueTask.bind(this), options.statConcurrency);\r\n\r\n  this._state = {\r\n    aborted: false,\r\n    finalize: false,\r\n    finalizing: false,\r\n    finalized: false,\r\n    modulePiped: false\r\n  };\r\n\r\n  this._streams = [];\r\n};\r\n\r\ninherits(Archiver, Transform);\r\n\r\n/**\r\n * Internal logic for `abort`.\r\n *\r\n * @private\r\n * @return void\r\n */\r\nArchiver.prototype._abort = function() {\r\n  this._state.aborted = true;\r\n  this._queue.kill();\r\n  this._statQueue.kill();\r\n\r\n  if (this._queue.idle()) {\r\n    this._shutdown();\r\n  }\r\n};\r\n\r\n/**\r\n * Internal helper for appending files.\r\n *\r\n * @private\r\n * @param  {String} filepath The source filepath.\r\n * @param  {EntryData} data The entry data.\r\n * @return void\r\n */\r\nArchiver.prototype._append = function(filepath, data) {\r\n  data = data || {};\r\n\r\n  var task = {\r\n    source: null,\r\n    filepath: filepath\r\n  };\r\n\r\n  if (!data.name) {\r\n    data.name = filepath;\r\n  }\r\n\r\n  data.sourcePath = filepath;\r\n  task.data = data;\r\n  this._entriesCount++;\r\n\r\n  if (data.stats && data.stats instanceof fs.Stats) {\r\n    task = this._updateQueueTaskWithStats(task, data.stats);\r\n    if (task) {\r\n      if (data.stats.size) {\r\n        this._fsEntriesTotalBytes += data.stats.size;\r\n      }\r\n\r\n      this._queue.push(task);\r\n    }\r\n  } else {\r\n    this._statQueue.push(task);\r\n  }\r\n};\r\n\r\n/**\r\n * Internal logic for `finalize`.\r\n *\r\n * @private\r\n * @return void\r\n */\r\nArchiver.prototype._finalize = function() {\r\n  if (this._state.finalizing || this._state.finalized || this._state.aborted) {\r\n    return;\r\n  }\r\n\r\n  this._state.finalizing = true;\r\n\r\n  this._moduleFinalize();\r\n\r\n  this._state.finalizing = false;\r\n  this._state.finalized = true;\r\n};\r\n\r\n/**\r\n * Checks the various state variables to determine if we can `finalize`.\r\n *\r\n * @private\r\n * @return {Boolean}\r\n */\r\nArchiver.prototype._maybeFinalize = function() {\r\n  if (this._state.finalizing || this._state.finalized || this._state.aborted) {\r\n    return false;\r\n  }\r\n\r\n  if (this._state.finalize && this._pending === 0 && this._queue.idle() && this._statQueue.idle()) {\r\n    this._finalize();\r\n    return true;\r\n  }\r\n\r\n  return false;\r\n};\r\n\r\n/**\r\n * Appends an entry to the module.\r\n *\r\n * @private\r\n * @fires  Archiver#entry\r\n * @param  {(Buffer|Stream)} source\r\n * @param  {EntryData} data\r\n * @param  {Function} callback\r\n * @return void\r\n */\r\nArchiver.prototype._moduleAppend = function(source, data, callback) {\r\n  if (this._state.aborted) {\r\n    callback();\r\n    return;\r\n  }\r\n\r\n  this._module.append(source, data, function(err) {\r\n    this._task = null;\r\n\r\n    if (this._state.aborted) {\r\n      this._shutdown();\r\n      return;\r\n    }\r\n\r\n    if (err) {\r\n      this.emit('error', err);\r\n      setImmediate(callback);\r\n      return;\r\n    }\r\n\r\n    /**\r\n     * Fires when the entry's input has been processed and appended to the archive.\r\n     *\r\n     * @event Archiver#entry\r\n     * @type {EntryData}\r\n     */\r\n    this.emit('entry', data);\r\n    this._entriesProcessedCount++;\r\n\r\n    if (data.stats && data.stats.size) {\r\n      this._fsEntriesProcessedBytes += data.stats.size;\r\n    }\r\n\r\n    /**\r\n     * @event Archiver#progress\r\n     * @type {ProgressData}\r\n     */\r\n    this.emit('progress', {\r\n      entries: {\r\n        total: this._entriesCount,\r\n        processed: this._entriesProcessedCount\r\n      },\r\n      fs: {\r\n        totalBytes: this._fsEntriesTotalBytes,\r\n        processedBytes: this._fsEntriesProcessedBytes\r\n      }\r\n    });\r\n\r\n    setImmediate(callback);\r\n  }.bind(this));\r\n};\r\n\r\n/**\r\n * Finalizes the module.\r\n *\r\n * @private\r\n * @return void\r\n */\r\nArchiver.prototype._moduleFinalize = function() {\r\n  if (typeof this._module.finalize === 'function') {\r\n    this._module.finalize();\r\n  } else if (typeof this._module.end === 'function') {\r\n    this._module.end();\r\n  } else {\r\n    this.emit('error', new ArchiverError('NOENDMETHOD'));\r\n  }\r\n};\r\n\r\n/**\r\n * Pipes the module to our internal stream with error bubbling.\r\n *\r\n * @private\r\n * @return void\r\n */\r\nArchiver.prototype._modulePipe = function() {\r\n  this._module.on('error', this._onModuleError.bind(this));\r\n  this._module.pipe(this);\r\n  this._state.modulePiped = true;\r\n};\r\n\r\n/**\r\n * Determines if the current module supports a defined feature.\r\n *\r\n * @private\r\n * @param  {String} key\r\n * @return {Boolean}\r\n */\r\nArchiver.prototype._moduleSupports = function(key) {\r\n  if (!this._module.supports || !this._module.supports[key]) {\r\n    return false;\r\n  }\r\n\r\n  return this._module.supports[key];\r\n};\r\n\r\n/**\r\n * Unpipes the module from our internal stream.\r\n *\r\n * @private\r\n * @return void\r\n */\r\nArchiver.prototype._moduleUnpipe = function() {\r\n  this._module.unpipe(this);\r\n  this._state.modulePiped = false;\r\n};\r\n\r\n/**\r\n * Normalizes entry data with fallbacks for key properties.\r\n *\r\n * @private\r\n * @param  {Object} data\r\n * @param  {fs.Stats} stats\r\n * @return {Object}\r\n */\r\nArchiver.prototype._normalizeEntryData = function(data, stats) {\r\n  data = util.defaults(data, {\r\n    type: 'file',\r\n    name: null,\r\n    date: null,\r\n    mode: null,\r\n    prefix: null,\r\n    sourcePath: null,\r\n    stats: false\r\n  });\r\n\r\n  if (stats && data.stats === false) {\r\n    data.stats = stats;\r\n  }\r\n\r\n  var isDir = data.type === 'directory';\r\n\r\n  if (data.name) {\r\n    if (typeof data.prefix === 'string' && '' !== data.prefix) {\r\n      data.name = data.prefix + '/' + data.name;\r\n      data.prefix = null;\r\n    }\r\n\r\n    data.name = util.sanitizePath(data.name);\r\n\r\n    if (data.type !== 'symlink' && data.name.slice(-1) === '/') {\r\n      isDir = true;\r\n      data.type = 'directory';\r\n    } else if (isDir) {\r\n      data.name += '/';\r\n    }\r\n  }\r\n\r\n  // 511 === 0777; 493 === 0755; 438 === 0666; 420 === 0644\r\n  if (typeof data.mode === 'number') {\r\n    if (win32) {\r\n      data.mode &= 511;\r\n    } else {\r\n      data.mode &= 4095\r\n    }\r\n  } else if (data.stats && data.mode === null) {\r\n    if (win32) {\r\n      data.mode = data.stats.mode & 511;\r\n    } else {\r\n      data.mode = data.stats.mode & 4095;\r\n    }\r\n\r\n    // stat isn't reliable on windows; force 0755 for dir\r\n    if (win32 && isDir) {\r\n      data.mode = 493;\r\n    }\r\n  } else if (data.mode === null) {\r\n    data.mode = isDir ? 493 : 420;\r\n  }\r\n\r\n  if (data.stats && data.date === null) {\r\n    data.date = data.stats.mtime;\r\n  } else {\r\n    data.date = util.dateify(data.date);\r\n  }\r\n\r\n  return data;\r\n};\r\n\r\n/**\r\n * Error listener that re-emits error on to our internal stream.\r\n *\r\n * @private\r\n * @param  {Error} err\r\n * @return void\r\n */\r\nArchiver.prototype._onModuleError = function(err) {\r\n  /**\r\n   * @event Archiver#error\r\n   * @type {ErrorData}\r\n   */\r\n  this.emit('error', err);\r\n};\r\n\r\n/**\r\n * Checks the various state variables after queue has drained to determine if\r\n * we need to `finalize`.\r\n *\r\n * @private\r\n * @return void\r\n */\r\nArchiver.prototype._onQueueDrain = function() {\r\n  if (this._state.finalizing || this._state.finalized || this._state.aborted) {\r\n    return;\r\n  }\r\n\r\n  if (this._state.finalize && this._pending === 0 && this._queue.idle() && this._statQueue.idle()) {\r\n    this._finalize();\r\n  }\r\n};\r\n\r\n/**\r\n * Appends each queue task to the module.\r\n *\r\n * @private\r\n * @param  {Object} task\r\n * @param  {Function} callback\r\n * @return void\r\n */\r\nArchiver.prototype._onQueueTask = function(task, callback) {\r\n  if (this._state.finalizing || this._state.finalized || this._state.aborted) {\r\n    callback();\r\n    return;\r\n  }\r\n\r\n  this._task = task;\r\n  this._moduleAppend(task.source, task.data, callback);\r\n};\r\n\r\n/**\r\n * Performs a file stat and reinjects the task back into the queue.\r\n *\r\n * @private\r\n * @param  {Object} task\r\n * @param  {Function} callback\r\n * @return void\r\n */\r\nArchiver.prototype._onStatQueueTask = function(task, callback) {\r\n  if (this._state.finalizing || this._state.finalized || this._state.aborted) {\r\n    callback();\r\n    return;\r\n  }\r\n\r\n  fs.lstat(task.filepath, function(err, stats) {\r\n    if (this._state.aborted) {\r\n      setImmediate(callback);\r\n      return;\r\n    }\r\n\r\n    if (err) {\r\n      this._entriesCount--;\r\n\r\n      /**\r\n       * @event Archiver#warning\r\n       * @type {ErrorData}\r\n       */\r\n      this.emit('warning', err);\r\n      setImmediate(callback);\r\n      return;\r\n    }\r\n\r\n    task = this._updateQueueTaskWithStats(task, stats);\r\n\r\n    if (task) {\r\n      if (stats.size) {\r\n        this._fsEntriesTotalBytes += stats.size;\r\n      }\r\n\r\n      this._queue.push(task);\r\n    }\r\n\r\n    setImmediate(callback);\r\n  }.bind(this));\r\n};\r\n\r\n/**\r\n * Unpipes the module and ends our internal stream.\r\n *\r\n * @private\r\n * @return void\r\n */\r\nArchiver.prototype._shutdown = function() {\r\n  this._moduleUnpipe();\r\n  this.end();\r\n};\r\n\r\n/**\r\n * Tracks the bytes emitted by our internal stream.\r\n *\r\n * @private\r\n * @param  {Buffer} chunk\r\n * @param  {String} encoding\r\n * @param  {Function} callback\r\n * @return void\r\n */\r\nArchiver.prototype._transform = function(chunk, encoding, callback) {\r\n  if (chunk) {\r\n    this._pointer += chunk.length;\r\n  }\r\n\r\n  callback(null, chunk);\r\n};\r\n\r\n/**\r\n * Updates and normalizes a queue task using stats data.\r\n *\r\n * @private\r\n * @param  {Object} task\r\n * @param  {fs.Stats} stats\r\n * @return {Object}\r\n */\r\nArchiver.prototype._updateQueueTaskWithStats = function(task, stats) {\r\n  if (stats.isFile()) {\r\n    task.data.type = 'file';\r\n    task.data.sourceType = 'stream';\r\n    task.source = util.lazyReadStream(task.filepath);\r\n  } else if (stats.isDirectory() && this._moduleSupports('directory')) {\r\n    task.data.name = util.trailingSlashIt(task.data.name);\r\n    task.data.type = 'directory';\r\n    task.data.sourcePath = util.trailingSlashIt(task.filepath);\r\n    task.data.sourceType = 'buffer';\r\n    task.source = Buffer.concat([]);\r\n  } else if (stats.isSymbolicLink() && this._moduleSupports('symlink')) {\r\n    var linkPath = fs.readlinkSync(task.filepath);\r\n    var dirName = path.dirname(task.filepath);\r\n    task.data.type = 'symlink';\r\n    task.data.linkname = path.relative(dirName, path.resolve(dirName, linkPath));\r\n    task.data.sourceType = 'buffer';\r\n    task.source = Buffer.concat([]);\r\n  } else {\r\n    if (stats.isDirectory()) {\r\n      this.emit('warning', new ArchiverError('DIRECTORYNOTSUPPORTED', task.data));\r\n    } else if (stats.isSymbolicLink()) {\r\n      this.emit('warning', new ArchiverError('SYMLINKNOTSUPPORTED', task.data));\r\n    } else {\r\n      this.emit('warning', new ArchiverError('ENTRYNOTSUPPORTED', task.data));\r\n    }\r\n\r\n    return null;\r\n  }\r\n\r\n  task.data = this._normalizeEntryData(task.data, stats);\r\n\r\n  return task;\r\n};\r\n\r\n/**\r\n * Aborts the archiving process, taking a best-effort approach, by:\r\n *\r\n * - removing any pending queue tasks\r\n * - allowing any active queue workers to finish\r\n * - detaching internal module pipes\r\n * - ending both sides of the Transform stream\r\n *\r\n * It will NOT drain any remaining sources.\r\n *\r\n * @return {this}\r\n */\r\nArchiver.prototype.abort = function() {\r\n  if (this._state.aborted || this._state.finalized) {\r\n    return this;\r\n  }\r\n\r\n  this._abort();\r\n\r\n  return this;\r\n};\r\n\r\n/**\r\n * Appends an input source (text string, buffer, or stream) to the instance.\r\n *\r\n * When the instance has received, processed, and emitted the input, the `entry`\r\n * event is fired.\r\n *\r\n * @fires  Archiver#entry\r\n * @param  {(Buffer|Stream|String)} source The input source.\r\n * @param  {EntryData} data See also {@link ZipEntryData} and {@link TarEntryData}.\r\n * @return {this}\r\n */\r\nArchiver.prototype.append = function(source, data) {\r\n  if (this._state.finalize || this._state.aborted) {\r\n    this.emit('error', new ArchiverError('QUEUECLOSED'));\r\n    return this;\r\n  }\r\n\r\n  data = this._normalizeEntryData(data);\r\n\r\n  if (typeof data.name !== 'string' || data.name.length === 0) {\r\n    this.emit('error', new ArchiverError('ENTRYNAMEREQUIRED'));\r\n    return this;\r\n  }\r\n\r\n  if (data.type === 'directory' && !this._moduleSupports('directory')) {\r\n    this.emit('error', new ArchiverError('DIRECTORYNOTSUPPORTED', { name: data.name }));\r\n    return this;\r\n  }\r\n\r\n  source = util.normalizeInputSource(source);\r\n\r\n  if (Buffer.isBuffer(source)) {\r\n    data.sourceType = 'buffer';\r\n  } else if (util.isStream(source)) {\r\n    data.sourceType = 'stream';\r\n  } else {\r\n    this.emit('error', new ArchiverError('INPUTSTEAMBUFFERREQUIRED', { name: data.name }));\r\n    return this;\r\n  }\r\n\r\n  this._entriesCount++;\r\n  this._queue.push({\r\n    data: data,\r\n    source: source\r\n  });\r\n\r\n  return this;\r\n};\r\n\r\n/**\r\n * Appends a directory and its files, recursively, given its dirpath.\r\n *\r\n * @param  {String} dirpath The source directory path.\r\n * @param  {String} destpath The destination path within the archive.\r\n * @param  {(EntryData|Function)} data See also [ZipEntryData]{@link ZipEntryData} and\r\n * [TarEntryData]{@link TarEntryData}.\r\n * @return {this}\r\n */\r\nArchiver.prototype.directory = function(dirpath, destpath, data) {\r\n  if (this._state.finalize || this._state.aborted) {\r\n    this.emit('error', new ArchiverError('QUEUECLOSED'));\r\n    return this;\r\n  }\r\n\r\n  if (typeof dirpath !== 'string' || dirpath.length === 0) {\r\n    this.emit('error', new ArchiverError('DIRECTORYDIRPATHREQUIRED'));\r\n    return this;\r\n  }\r\n\r\n  this._pending++;\r\n\r\n  if (destpath === false) {\r\n    destpath = '';\r\n  } else if (typeof destpath !== 'string'){\r\n    destpath = dirpath;\r\n  }\r\n\r\n  var dataFunction = false;\r\n  if (typeof data === 'function') {\r\n    dataFunction = data;\r\n    data = {};\r\n  } else if (typeof data !== 'object') {\r\n    data = {};\r\n  }\r\n\r\n  var globOptions = {\r\n    stat: false,\r\n    dot: true,\r\n    cwd: dirpath\r\n  };\r\n\r\n  function onGlobEnd() {\r\n    this._pending--;\r\n    this._maybeFinalize();\r\n  }\r\n\r\n  function onGlobError(err) {\r\n    this.emit('error', err);\r\n  }\r\n\r\n  function onGlobMatch(match){\r\n    var ignoreMatch = false;\r\n    var entryData = Object.assign({}, data);\r\n    entryData.name = match;\r\n    entryData.prefix = destpath;\r\n    match = globber._makeAbs(match);\r\n\r\n    try {\r\n      if (dataFunction) {\r\n        entryData = dataFunction(entryData);\r\n\r\n        if (entryData === false) {\r\n          ignoreMatch = true;\r\n        } else if (typeof entryData !== 'object') {\r\n          throw new ArchiverError('DIRECTORYFUNCTIONINVALIDDATA', { dirpath: dirpath });\r\n        }\r\n      }\r\n    } catch(e) {\r\n      this.emit('error', e);\r\n      return;\r\n    }\r\n\r\n    if (ignoreMatch) {\r\n      return;\r\n    }\r\n\r\n    this._append(match, entryData);\r\n  }\r\n\r\n  var globber = glob('**', globOptions);\r\n  globber.on('error', onGlobError.bind(this));\r\n  globber.on('match', onGlobMatch.bind(this));\r\n  globber.on('end', onGlobEnd.bind(this));\r\n\r\n  return this;\r\n};\r\n\r\n/**\r\n * Appends a file given its filepath using a\r\n * [lazystream]{@link https://github.com/jpommerening/node-lazystream} wrapper to\r\n * prevent issues with open file limits.\r\n *\r\n * When the instance has received, processed, and emitted the file, the `entry`\r\n * event is fired.\r\n *\r\n * @param  {String} filepath The source filepath.\r\n * @param  {EntryData} data See also [ZipEntryData]{@link ZipEntryData} and\r\n * [TarEntryData]{@link TarEntryData}.\r\n * @return {this}\r\n */\r\nArchiver.prototype.file = function(filepath, data) {\r\n  if (this._state.finalize || this._state.aborted) {\r\n    this.emit('error', new ArchiverError('QUEUECLOSED'));\r\n    return this;\r\n  }\r\n\r\n  if (typeof filepath !== 'string' || filepath.length === 0) {\r\n    this.emit('error', new ArchiverError('FILEFILEPATHREQUIRED'));\r\n    return this;\r\n  }\r\n\r\n  this._append(filepath, data);\r\n\r\n  return this;\r\n};\r\n\r\n/**\r\n * Appends multiple files that match a glob pattern.\r\n *\r\n * @param  {String} pattern The [glob pattern]{@link https://github.com/isaacs/node-glob#glob-primer} to match.\r\n * @param  {Object} options See [node-glob]{@link https://github.com/isaacs/node-glob#options}.\r\n * @param  {EntryData} data See also [ZipEntryData]{@link ZipEntryData} and\r\n * [TarEntryData]{@link TarEntryData}.\r\n * @return {this}\r\n */\r\nArchiver.prototype.glob = function(pattern, options, data) {\r\n  this._pending++;\r\n\r\n  options = util.defaults(options, {\r\n    stat: false\r\n  });\r\n\r\n  function onGlobEnd() {\r\n    this._pending--;\r\n    this._maybeFinalize();\r\n  }\r\n\r\n  function onGlobError(err) {\r\n    this.emit('error', err);\r\n  }\r\n\r\n  function onGlobMatch(match){\r\n    var entryData = Object.assign({}, data);\r\n\r\n    if (options.cwd) {\r\n      entryData.name = match;\r\n      match = globber._makeAbs(match);\r\n    }\r\n\r\n    this._append(match, entryData);\r\n  }\r\n\r\n  var globber = glob(pattern, options);\r\n  globber.on('error', onGlobError.bind(this));\r\n  globber.on('match', onGlobMatch.bind(this));\r\n  globber.on('end', onGlobEnd.bind(this));\r\n\r\n  return this;\r\n};\r\n\r\n/**\r\n * Finalizes the instance and prevents further appending to the archive\r\n * structure (queue will continue til drained).\r\n *\r\n * The `end`, `close` or `finish` events on the destination stream may fire\r\n * right after calling this method so you should set listeners beforehand to\r\n * properly detect stream completion.\r\n *\r\n * @return {this}\r\n */\r\nArchiver.prototype.finalize = function() {\r\n  if (this._state.aborted) {\r\n    this.emit('error', new ArchiverError('ABORTED'));\r\n    return this;\r\n  }\r\n\r\n  if (this._state.finalize) {\r\n    this.emit('error', new ArchiverError('FINALIZING'));\r\n    return this;\r\n  }\r\n\r\n  this._state.finalize = true;\r\n\r\n  if (this._pending === 0 && this._queue.idle() && this._statQueue.idle()) {\r\n    this._finalize();\r\n  }\r\n\r\n  var self = this;\r\n\r\n  return new Promise(function(resolve, reject) {\r\n    var errored;\r\n\r\n    self._module.on('end', function() {\r\n      if (!errored) {\r\n        resolve();\r\n      }\r\n    })\r\n\r\n    self._module.on('error', function(err) {\r\n      errored = true;\r\n      reject(err);\r\n    })\r\n  })\r\n};\r\n\r\n/**\r\n * Sets the module format name used for archiving.\r\n *\r\n * @param {String} format The name of the format.\r\n * @return {this}\r\n */\r\nArchiver.prototype.setFormat = function(format) {\r\n  if (this._format) {\r\n    this.emit('error', new ArchiverError('FORMATSET'));\r\n    return this;\r\n  }\r\n\r\n  this._format = format;\r\n\r\n  return this;\r\n};\r\n\r\n/**\r\n * Sets the module used for archiving.\r\n *\r\n * @param {Function} module The function for archiver to interact with.\r\n * @return {this}\r\n */\r\nArchiver.prototype.setModule = function(module) {\r\n  if (this._state.aborted) {\r\n    this.emit('error', new ArchiverError('ABORTED'));\r\n    return this;\r\n  }\r\n\r\n  if (this._state.module) {\r\n    this.emit('error', new ArchiverError('MODULESET'));\r\n    return this;\r\n  }\r\n\r\n  this._module = module;\r\n  this._modulePipe();\r\n\r\n  return this;\r\n};\r\n\r\n/**\r\n * Appends a symlink to the instance.\r\n *\r\n * This does NOT interact with filesystem and is used for programmatically creating symlinks.\r\n *\r\n * @param  {String} filepath The symlink path (within archive).\r\n * @param  {String} target The target path (within archive).\r\n * @return {this}\r\n */\r\nArchiver.prototype.symlink = function(filepath, target) {\r\n  if (this._state.finalize || this._state.aborted) {\r\n    this.emit('error', new ArchiverError('QUEUECLOSED'));\r\n    return this;\r\n  }\r\n\r\n  if (typeof filepath !== 'string' || filepath.length === 0) {\r\n    this.emit('error', new ArchiverError('SYMLINKFILEPATHREQUIRED'));\r\n    return this;\r\n  }\r\n\r\n  if (typeof target !== 'string' || target.length === 0) {\r\n    this.emit('error', new ArchiverError('SYMLINKTARGETREQUIRED', { filepath: filepath }));\r\n    return this;\r\n  }\r\n\r\n  if (!this._moduleSupports('symlink')) {\r\n    this.emit('error', new ArchiverError('SYMLINKNOTSUPPORTED', { filepath: filepath }));\r\n    return this;\r\n  }\r\n\r\n  var data = {};\r\n  data.type = 'symlink';\r\n  data.name = filepath.replace(/\\\\/g, '/');\r\n  data.linkname = target.replace(/\\\\/g, '/');\r\n  data.sourceType = 'buffer';\r\n\r\n  this._entriesCount++;\r\n  this._queue.push({\r\n    data: data,\r\n    source: Buffer.concat([])\r\n  });\r\n\r\n  return this;\r\n};\r\n\r\n/**\r\n * Returns the current length (in bytes) that has been emitted.\r\n *\r\n * @return {Number}\r\n */\r\nArchiver.prototype.pointer = function() {\r\n  return this._pointer;\r\n};\r\n\r\n/**\r\n * Middleware-like helper that has yet to be fully implemented.\r\n *\r\n * @private\r\n * @param  {Function} plugin\r\n * @return {this}\r\n */\r\nArchiver.prototype.use = function(plugin) {\r\n  this._streams.push(plugin);\r\n  return this;\r\n};\r\n\r\nmodule.exports = Archiver;\r\n\r\n/**\r\n * @typedef {Object} CoreOptions\r\n * @global\r\n * @property {Number} [statConcurrency=4] Sets the number of workers used to\r\n * process the internal fs stat queue.\r\n */\r\n\r\n/**\r\n * @typedef {Object} TransformOptions\r\n * @property {Boolean} [allowHalfOpen=true] If set to false, then the stream\r\n * will automatically end the readable side when the writable side ends and vice\r\n * versa.\r\n * @property {Boolean} [readableObjectMode=false] Sets objectMode for readable\r\n * side of the stream. Has no effect if objectMode is true.\r\n * @property {Boolean} [writableObjectMode=false] Sets objectMode for writable\r\n * side of the stream. Has no effect if objectMode is true.\r\n * @property {Boolean} [decodeStrings=true] Whether or not to decode strings\r\n * into Buffers before passing them to _write(). `Writable`\r\n * @property {String} [encoding=NULL] If specified, then buffers will be decoded\r\n * to strings using the specified encoding. `Readable`\r\n * @property {Number} [highWaterMark=16kb] The maximum number of bytes to store\r\n * in the internal buffer before ceasing to read from the underlying resource.\r\n * `Readable` `Writable`\r\n * @property {Boolean} [objectMode=false] Whether this stream should behave as a\r\n * stream of objects. Meaning that stream.read(n) returns a single value instead\r\n * of a Buffer of size n. `Readable` `Writable`\r\n */\r\n\r\n/**\r\n * @typedef {Object} EntryData\r\n * @property {String} name Sets the entry name including internal path.\r\n * @property {(String|Date)} [date=NOW()] Sets the entry date.\r\n * @property {Number} [mode=D:0755/F:0644] Sets the entry permissions.\r\n * @property {String} [prefix] Sets a path prefix for the entry name. Useful\r\n * when working with methods like `directory` or `glob`.\r\n * @property {fs.Stats} [stats] Sets the fs stat data for this entry allowing\r\n * for reduction of fs stat calls when stat data is already known.\r\n */\r\n\r\n/**\r\n * @typedef {Object} ErrorData\r\n * @property {String} message The message of the error.\r\n * @property {String} code The error code assigned to this error.\r\n * @property {String} data Additional data provided for reporting or debugging (where available).\r\n */\r\n\r\n/**\r\n * @typedef {Object} ProgressData\r\n * @property {Object} entries\r\n * @property {Number} entries.total Number of entries that have been appended.\r\n * @property {Number} entries.processed Number of entries that have been processed.\r\n * @property {Object} fs\r\n * @property {Number} fs.totalBytes Number of bytes that have been appended. Calculated asynchronously and might not be accurate: it growth while entries are added. (based on fs.Stats)\r\n * @property {Number} fs.processedBytes Number of bytes that have been processed. (based on fs.Stats)\r\n */\r\n"]},"metadata":{},"sourceType":"script"}