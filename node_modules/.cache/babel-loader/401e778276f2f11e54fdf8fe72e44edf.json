{"ast":null,"code":"'use strict';\n\nvar fs = require('graceful-fs'),\n    path = require('path'),\n    micromatch = require('micromatch').isMatch,\n    toString = Object.prototype.toString; // Standard helpers\n\n\nfunction isFunction(obj) {\n  return toString.call(obj) === '[object Function]';\n}\n\nfunction isString(obj) {\n  return toString.call(obj) === '[object String]';\n}\n\nfunction isUndefined(obj) {\n  return obj === void 0;\n}\n/**\n * Main function which ends up calling readdirRec and reads all files and directories in given root recursively.\n * @param { Object }   opts     Options to specify root (start directory), filters and recursion depth\n * @param { function } callback1  When callback2 is given calls back for each processed file - function (fileInfo) { ... },\n *                                when callback2 is not given, it behaves like explained in callback2\n * @param { function } callback2  Calls back once all files have been processed with an array of errors and file infos\n *                                function (err, fileInfos) { ... }\n */\n\n\nfunction readdir(opts, callback1, callback2) {\n  var stream,\n      handleError,\n      handleFatalError,\n      errors = [],\n      readdirResult = {\n    directories: [],\n    files: []\n  },\n      fileProcessed,\n      allProcessed,\n      realRoot,\n      aborted = false,\n      paused = false; // If no callbacks were given we will use a streaming interface\n\n  if (isUndefined(callback1)) {\n    var api = require('./stream-api')();\n\n    stream = api.stream;\n    callback1 = api.processEntry;\n    callback2 = api.done;\n    handleError = api.handleError;\n    handleFatalError = api.handleFatalError;\n    stream.on('close', function () {\n      aborted = true;\n    });\n    stream.on('pause', function () {\n      paused = true;\n    });\n    stream.on('resume', function () {\n      paused = false;\n    });\n  } else {\n    handleError = function (err) {\n      errors.push(err);\n    };\n\n    handleFatalError = function (err) {\n      handleError(err);\n      allProcessed(errors, null);\n    };\n  }\n\n  if (isUndefined(opts)) {\n    handleFatalError(new Error('Need to pass at least one argument: opts! \\n' + 'https://github.com/paulmillr/readdirp#options'));\n    return stream;\n  }\n\n  opts.root = opts.root || '.';\n\n  opts.fileFilter = opts.fileFilter || function () {\n    return true;\n  };\n\n  opts.directoryFilter = opts.directoryFilter || function () {\n    return true;\n  };\n\n  opts.depth = typeof opts.depth === 'undefined' ? 999999999 : opts.depth;\n  opts.entryType = opts.entryType || 'files';\n  var statfn = opts.lstat === true ? fs.lstat.bind(fs) : fs.stat.bind(fs);\n\n  if (isUndefined(callback2)) {\n    fileProcessed = function () {};\n\n    allProcessed = callback1;\n  } else {\n    fileProcessed = callback1;\n    allProcessed = callback2;\n  }\n\n  function normalizeFilter(filter) {\n    if (isUndefined(filter)) return undefined;\n\n    function isNegated(filters) {\n      function negated(f) {\n        return f.indexOf('!') === 0;\n      }\n\n      var some = filters.some(negated);\n\n      if (!some) {\n        return false;\n      } else {\n        if (filters.every(negated)) {\n          return true;\n        } else {\n          // if we detect illegal filters, bail out immediately\n          throw new Error('Cannot mix negated with non negated glob filters: ' + filters + '\\n' + 'https://github.com/paulmillr/readdirp#filters');\n        }\n      }\n    } // Turn all filters into a function\n\n\n    if (isFunction(filter)) {\n      return filter;\n    } else if (isString(filter)) {\n      return function (entryInfo) {\n        return micromatch(entryInfo.name, filter.trim());\n      };\n    } else if (filter && Array.isArray(filter)) {\n      if (filter) filter = filter.map(function (f) {\n        return f.trim();\n      });\n      return isNegated(filter) ? // use AND to concat multiple negated filters\n      function (entryInfo) {\n        return filter.every(function (f) {\n          return micromatch(entryInfo.name, f);\n        });\n      } : // use OR to concat multiple inclusive filters\n      function (entryInfo) {\n        return filter.some(function (f) {\n          return micromatch(entryInfo.name, f);\n        });\n      };\n    }\n  }\n\n  function processDir(currentDir, entries, callProcessed) {\n    if (aborted) return;\n    var total = entries.length,\n        processed = 0,\n        entryInfos = [];\n    fs.realpath(currentDir, function (err, realCurrentDir) {\n      if (aborted) return;\n\n      if (err) {\n        handleError(err);\n        callProcessed(entryInfos);\n        return;\n      }\n\n      var relDir = path.relative(realRoot, realCurrentDir);\n\n      if (entries.length === 0) {\n        callProcessed([]);\n      } else {\n        entries.forEach(function (entry) {\n          var fullPath = path.join(realCurrentDir, entry),\n              relPath = path.join(relDir, entry);\n          statfn(fullPath, function (err, stat) {\n            if (err) {\n              handleError(err);\n            } else {\n              entryInfos.push({\n                name: entry,\n                path: relPath // relative to root\n                ,\n                fullPath: fullPath,\n                parentDir: relDir // relative to root\n                ,\n                fullParentDir: realCurrentDir,\n                stat: stat\n              });\n            }\n\n            processed++;\n            if (processed === total) callProcessed(entryInfos);\n          });\n        });\n      }\n    });\n  }\n\n  function readdirRec(currentDir, depth, callCurrentDirProcessed) {\n    var args = arguments;\n    if (aborted) return;\n\n    if (paused) {\n      setImmediate(function () {\n        readdirRec.apply(null, args);\n      });\n      return;\n    }\n\n    fs.readdir(currentDir, function (err, entries) {\n      if (err) {\n        handleError(err);\n        callCurrentDirProcessed();\n        return;\n      }\n\n      processDir(currentDir, entries, function (entryInfos) {\n        var subdirs = entryInfos.filter(function (ei) {\n          return ei.stat.isDirectory() && opts.directoryFilter(ei);\n        });\n        subdirs.forEach(function (di) {\n          if (opts.entryType === 'directories' || opts.entryType === 'both' || opts.entryType === 'all') {\n            fileProcessed(di);\n          }\n\n          readdirResult.directories.push(di);\n        });\n        entryInfos.filter(function (ei) {\n          var isCorrectType = opts.entryType === 'all' ? !ei.stat.isDirectory() : ei.stat.isFile() || ei.stat.isSymbolicLink();\n          return isCorrectType && opts.fileFilter(ei);\n        }).forEach(function (fi) {\n          if (opts.entryType === 'files' || opts.entryType === 'both' || opts.entryType === 'all') {\n            fileProcessed(fi);\n          }\n\n          readdirResult.files.push(fi);\n        });\n        var pendingSubdirs = subdirs.length; // Be done if no more subfolders exist or we reached the maximum desired depth\n\n        if (pendingSubdirs === 0 || depth === opts.depth) {\n          callCurrentDirProcessed();\n        } else {\n          // recurse into subdirs, keeping track of which ones are done\n          // and call back once all are processed\n          subdirs.forEach(function (subdir) {\n            readdirRec(subdir.fullPath, depth + 1, function () {\n              pendingSubdirs = pendingSubdirs - 1;\n\n              if (pendingSubdirs === 0) {\n                callCurrentDirProcessed();\n              }\n            });\n          });\n        }\n      });\n    });\n  } // Validate and normalize filters\n\n\n  try {\n    opts.fileFilter = normalizeFilter(opts.fileFilter);\n    opts.directoryFilter = normalizeFilter(opts.directoryFilter);\n  } catch (err) {\n    // if we detect illegal filters, bail out immediately\n    handleFatalError(err);\n    return stream;\n  } // If filters were valid get on with the show\n\n\n  fs.realpath(opts.root, function (err, res) {\n    if (err) {\n      handleFatalError(err);\n      return stream;\n    }\n\n    realRoot = res;\n    readdirRec(opts.root, 0, function () {\n      // All errors are collected into the errors array\n      if (errors.length > 0) {\n        allProcessed(errors, readdirResult);\n      } else {\n        allProcessed(null, readdirResult);\n      }\n    });\n  });\n  return stream;\n}\n\nmodule.exports = readdir;","map":{"version":3,"sources":["/home/yanxiaoyang/react-project/PersonalWebsiteTest/node_modules/readdirp/readdirp.js"],"names":["fs","require","path","micromatch","isMatch","toString","Object","prototype","isFunction","obj","call","isString","isUndefined","readdir","opts","callback1","callback2","stream","handleError","handleFatalError","errors","readdirResult","directories","files","fileProcessed","allProcessed","realRoot","aborted","paused","api","processEntry","done","on","err","push","Error","root","fileFilter","directoryFilter","depth","entryType","statfn","lstat","bind","stat","normalizeFilter","filter","undefined","isNegated","filters","negated","f","indexOf","some","every","entryInfo","name","trim","Array","isArray","map","processDir","currentDir","entries","callProcessed","total","length","processed","entryInfos","realpath","realCurrentDir","relDir","relative","forEach","entry","fullPath","join","relPath","parentDir","fullParentDir","readdirRec","callCurrentDirProcessed","args","arguments","setImmediate","apply","subdirs","ei","isDirectory","di","isCorrectType","isFile","isSymbolicLink","fi","pendingSubdirs","subdir","res","module","exports"],"mappings":"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","sourcesContent":["'use strict';\n\nvar fs        =  require('graceful-fs')\n  , path      =  require('path')\n  , micromatch =  require('micromatch').isMatch\n  , toString  =  Object.prototype.toString\n  ;\n\n\n// Standard helpers\nfunction isFunction (obj) {\n  return toString.call(obj) === '[object Function]';\n}\n\nfunction isString (obj) {\n  return toString.call(obj) === '[object String]';\n}\n\nfunction isUndefined (obj) {\n  return obj === void 0;\n}\n\n/**\n * Main function which ends up calling readdirRec and reads all files and directories in given root recursively.\n * @param { Object }   opts     Options to specify root (start directory), filters and recursion depth\n * @param { function } callback1  When callback2 is given calls back for each processed file - function (fileInfo) { ... },\n *                                when callback2 is not given, it behaves like explained in callback2\n * @param { function } callback2  Calls back once all files have been processed with an array of errors and file infos\n *                                function (err, fileInfos) { ... }\n */\nfunction readdir(opts, callback1, callback2) {\n  var stream\n    , handleError\n    , handleFatalError\n    , errors = []\n    , readdirResult = {\n        directories: []\n      , files: []\n    }\n    , fileProcessed\n    , allProcessed\n    , realRoot\n    , aborted = false\n    , paused = false\n    ;\n\n  // If no callbacks were given we will use a streaming interface\n  if (isUndefined(callback1)) {\n    var api          =  require('./stream-api')();\n    stream           =  api.stream;\n    callback1        =  api.processEntry;\n    callback2        =  api.done;\n    handleError      =  api.handleError;\n    handleFatalError =  api.handleFatalError;\n\n    stream.on('close', function () { aborted = true; });\n    stream.on('pause', function () { paused = true; });\n    stream.on('resume', function () { paused = false; });\n  } else {\n    handleError      =  function (err) { errors.push(err); };\n    handleFatalError =  function (err) {\n      handleError(err);\n      allProcessed(errors, null);\n    };\n  }\n\n  if (isUndefined(opts)){\n    handleFatalError(new Error (\n      'Need to pass at least one argument: opts! \\n' +\n      'https://github.com/paulmillr/readdirp#options'\n      )\n    );\n    return stream;\n  }\n\n  opts.root            =  opts.root            || '.';\n  opts.fileFilter      =  opts.fileFilter      || function() { return true; };\n  opts.directoryFilter =  opts.directoryFilter || function() { return true; };\n  opts.depth           =  typeof opts.depth === 'undefined' ? 999999999 : opts.depth;\n  opts.entryType       =  opts.entryType       || 'files';\n\n  var statfn = opts.lstat === true ? fs.lstat.bind(fs) : fs.stat.bind(fs);\n\n  if (isUndefined(callback2)) {\n    fileProcessed = function() { };\n    allProcessed = callback1;\n  } else {\n    fileProcessed = callback1;\n    allProcessed = callback2;\n  }\n\n  function normalizeFilter (filter) {\n\n    if (isUndefined(filter)) return undefined;\n\n    function isNegated (filters) {\n\n      function negated(f) {\n        return f.indexOf('!') === 0;\n      }\n\n      var some = filters.some(negated);\n      if (!some) {\n        return false;\n      } else {\n        if (filters.every(negated)) {\n          return true;\n        } else {\n          // if we detect illegal filters, bail out immediately\n          throw new Error(\n            'Cannot mix negated with non negated glob filters: ' + filters + '\\n' +\n            'https://github.com/paulmillr/readdirp#filters'\n          );\n        }\n      }\n    }\n\n    // Turn all filters into a function\n    if (isFunction(filter)) {\n\n      return filter;\n\n    } else if (isString(filter)) {\n\n      return function (entryInfo) {\n        return micromatch(entryInfo.name, filter.trim());\n      };\n\n    } else if (filter && Array.isArray(filter)) {\n\n      if (filter) filter = filter.map(function (f) {\n        return f.trim();\n      });\n\n      return isNegated(filter) ?\n        // use AND to concat multiple negated filters\n        function (entryInfo) {\n          return filter.every(function (f) {\n            return micromatch(entryInfo.name, f);\n          });\n        }\n        :\n        // use OR to concat multiple inclusive filters\n        function (entryInfo) {\n          return filter.some(function (f) {\n            return micromatch(entryInfo.name, f);\n          });\n        };\n    }\n  }\n\n  function processDir(currentDir, entries, callProcessed) {\n    if (aborted) return;\n    var total = entries.length\n      , processed = 0\n      , entryInfos = []\n      ;\n\n    fs.realpath(currentDir, function(err, realCurrentDir) {\n      if (aborted) return;\n      if (err) {\n        handleError(err);\n        callProcessed(entryInfos);\n        return;\n      }\n\n      var relDir = path.relative(realRoot, realCurrentDir);\n\n      if (entries.length === 0) {\n        callProcessed([]);\n      } else {\n        entries.forEach(function (entry) {\n\n          var fullPath = path.join(realCurrentDir, entry)\n            , relPath  = path.join(relDir, entry);\n\n          statfn(fullPath, function (err, stat) {\n            if (err) {\n              handleError(err);\n            } else {\n              entryInfos.push({\n                  name          :  entry\n                , path          :  relPath   // relative to root\n                , fullPath      :  fullPath\n\n                , parentDir     :  relDir    // relative to root\n                , fullParentDir :  realCurrentDir\n\n                , stat          :  stat\n              });\n            }\n            processed++;\n            if (processed === total) callProcessed(entryInfos);\n          });\n        });\n      }\n    });\n  }\n\n  function readdirRec(currentDir, depth, callCurrentDirProcessed) {\n    var args = arguments;\n    if (aborted) return;\n    if (paused) {\n      setImmediate(function () {\n        readdirRec.apply(null, args);\n      })\n      return;\n    }\n\n    fs.readdir(currentDir, function (err, entries) {\n      if (err) {\n        handleError(err);\n        callCurrentDirProcessed();\n        return;\n      }\n\n      processDir(currentDir, entries, function(entryInfos) {\n\n        var subdirs = entryInfos\n          .filter(function (ei) { return ei.stat.isDirectory() && opts.directoryFilter(ei); });\n\n        subdirs.forEach(function (di) {\n          if(opts.entryType === 'directories' || opts.entryType === 'both' || opts.entryType === 'all') {\n            fileProcessed(di);\n          }\n          readdirResult.directories.push(di);\n        });\n\n        entryInfos\n          .filter(function(ei) {\n            var isCorrectType = opts.entryType === 'all' ?\n              !ei.stat.isDirectory() : ei.stat.isFile() || ei.stat.isSymbolicLink();\n            return isCorrectType && opts.fileFilter(ei);\n          })\n          .forEach(function (fi) {\n            if(opts.entryType === 'files' || opts.entryType === 'both' || opts.entryType === 'all') {\n              fileProcessed(fi);\n            }\n            readdirResult.files.push(fi);\n          });\n\n        var pendingSubdirs = subdirs.length;\n\n        // Be done if no more subfolders exist or we reached the maximum desired depth\n        if(pendingSubdirs === 0 || depth === opts.depth) {\n          callCurrentDirProcessed();\n        } else {\n          // recurse into subdirs, keeping track of which ones are done\n          // and call back once all are processed\n          subdirs.forEach(function (subdir) {\n            readdirRec(subdir.fullPath, depth + 1, function () {\n              pendingSubdirs = pendingSubdirs - 1;\n              if(pendingSubdirs === 0) {\n                callCurrentDirProcessed();\n              }\n            });\n          });\n        }\n      });\n    });\n  }\n\n  // Validate and normalize filters\n  try {\n    opts.fileFilter = normalizeFilter(opts.fileFilter);\n    opts.directoryFilter = normalizeFilter(opts.directoryFilter);\n  } catch (err) {\n    // if we detect illegal filters, bail out immediately\n    handleFatalError(err);\n    return stream;\n  }\n\n  // If filters were valid get on with the show\n  fs.realpath(opts.root, function(err, res) {\n    if (err) {\n      handleFatalError(err);\n      return stream;\n    }\n\n    realRoot = res;\n    readdirRec(opts.root, 0, function () {\n      // All errors are collected into the errors array\n      if (errors.length > 0) {\n        allProcessed(errors, readdirResult);\n      } else {\n        allProcessed(null, readdirResult);\n      }\n    });\n  });\n\n  return stream;\n}\n\nmodule.exports = readdir;\n"]},"metadata":{},"sourceType":"script"}