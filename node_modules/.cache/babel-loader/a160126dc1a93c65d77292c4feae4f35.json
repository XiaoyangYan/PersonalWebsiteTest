{"ast":null,"code":"var xtend = require('xtend');\n\nvar acorn = require('acorn-node');\n\nvar dash = require('dash-ast');\n\nvar getAssignedIdentifiers = require('get-assigned-identifiers');\n\nfunction visitFunction(node, state, ancestors) {\n  if (node.params.length > 0) {\n    var idents = [];\n\n    for (var i = 0; i < node.params.length; i++) {\n      var sub = getAssignedIdentifiers(node.params[i]);\n\n      for (var j = 0; j < sub.length; j++) idents.push(sub[j]);\n    }\n\n    declareNames(node, idents);\n  }\n\n  if (node.type === 'FunctionDeclaration') {\n    var parent = getScopeNode(ancestors, 'const');\n    declareNames(parent, [node.id]);\n  } else if (node.type === 'FunctionExpression' && node.id) {\n    declareNames(node, [node.id]);\n  }\n}\n\nvar scopeVisitor = {\n  VariableDeclaration: function (node, state, ancestors) {\n    var parent = getScopeNode(ancestors, node.kind);\n\n    for (var i = 0; i < node.declarations.length; i++) {\n      declareNames(parent, getAssignedIdentifiers(node.declarations[i].id));\n    }\n  },\n  FunctionExpression: visitFunction,\n  FunctionDeclaration: visitFunction,\n  ArrowFunctionExpression: visitFunction,\n  ClassDeclaration: function (node, state, ancestors) {\n    var parent = getScopeNode(ancestors, 'const');\n\n    if (node.id) {\n      declareNames(parent, [node.id]);\n    }\n  },\n  ImportDeclaration: function (node, state, ancestors) {\n    declareNames(ancestors[0]\n    /* root */\n    , getAssignedIdentifiers(node));\n  },\n  CatchClause: function (node) {\n    if (node.param) declareNames(node, [node.param]);\n  }\n};\nvar bindingVisitor = {\n  Identifier: function (node, state, ancestors) {\n    if (!state.identifiers) return;\n    var parent = ancestors[ancestors.length - 1];\n    if (parent.type === 'MemberExpression' && parent.property === node) return;\n    if (parent.type === 'Property' && !parent.computed && parent.key === node) return;\n    if (parent.type === 'MethodDefinition' && !parent.computed && parent.key === node) return;\n    if (parent.type === 'LabeledStatement' && parent.label === node) return;\n\n    if (!has(state.undeclared, node.name)) {\n      for (var i = ancestors.length - 1; i >= 0; i--) {\n        if (ancestors[i]._names !== undefined && has(ancestors[i]._names, node.name)) {\n          return;\n        }\n      }\n\n      state.undeclared[node.name] = true;\n    }\n\n    if (state.wildcard && !(parent.type === 'MemberExpression' && parent.object === node) && !(parent.type === 'VariableDeclarator' && parent.id === node) && !(parent.type === 'AssignmentExpression' && parent.left === node)) {\n      state.undeclaredProps[node.name + '.*'] = true;\n    }\n  },\n  MemberExpression: function (node, state) {\n    if (!state.properties) return;\n\n    if (node.object.type === 'Identifier' && has(state.undeclared, node.object.name)) {\n      var prop = !node.computed && node.property.type === 'Identifier' ? node.property.name : node.computed && node.property.type === 'Literal' ? node.property.value : null;\n      if (prop) state.undeclaredProps[node.object.name + '.' + prop] = true;\n    }\n  }\n};\n\nmodule.exports = function findUndeclared(src, opts) {\n  opts = xtend({\n    identifiers: true,\n    properties: true,\n    wildcard: false\n  }, opts);\n  var state = {\n    undeclared: {},\n    undeclaredProps: {},\n    identifiers: opts.identifiers,\n    properties: opts.properties,\n    wildcard: opts.wildcard\n  }; // Parse if `src` is not already an AST.\n\n  var ast = typeof src === 'object' && src !== null && typeof src.type === 'string' ? src : acorn.parse(src);\n  var parents = [];\n  dash(ast, {\n    enter: function (node, parent) {\n      if (parent) parents.push(parent);\n      var visit = scopeVisitor[node.type];\n      if (visit) visit(node, state, parents);\n    },\n    leave: function (node, parent) {\n      var visit = bindingVisitor[node.type];\n      if (visit) visit(node, state, parents);\n      if (parent) parents.pop();\n    }\n  });\n  return {\n    identifiers: Object.keys(state.undeclared),\n    properties: Object.keys(state.undeclaredProps)\n  };\n};\n\nfunction getScopeNode(parents, kind) {\n  for (var i = parents.length - 1; i >= 0; i--) {\n    if (parents[i].type === 'FunctionDeclaration' || parents[i].type === 'FunctionExpression' || parents[i].type === 'ArrowFunctionExpression' || parents[i].type === 'Program') {\n      return parents[i];\n    }\n\n    if (kind !== 'var' && parents[i].type === 'BlockStatement') {\n      return parents[i];\n    }\n  }\n}\n\nfunction declareNames(node, names) {\n  if (node._names === undefined) {\n    node._names = Object.create(null);\n  }\n\n  for (var i = 0; i < names.length; i++) {\n    node._names[names[i].name] = true;\n  }\n}\n\nfunction has(obj, name) {\n  return Object.prototype.hasOwnProperty.call(obj, name);\n}","map":{"version":3,"sources":["/home/yanxiaoyang/react-project/PersonalWebsiteTest/node_modules/undeclared-identifiers/index.js"],"names":["xtend","require","acorn","dash","getAssignedIdentifiers","visitFunction","node","state","ancestors","params","length","idents","i","sub","j","push","declareNames","type","parent","getScopeNode","id","scopeVisitor","VariableDeclaration","kind","declarations","FunctionExpression","FunctionDeclaration","ArrowFunctionExpression","ClassDeclaration","ImportDeclaration","CatchClause","param","bindingVisitor","Identifier","identifiers","property","computed","key","label","has","undeclared","name","_names","undefined","wildcard","object","left","undeclaredProps","MemberExpression","properties","prop","value","module","exports","findUndeclared","src","opts","ast","parse","parents","enter","visit","leave","pop","Object","keys","names","create","obj","prototype","hasOwnProperty","call"],"mappings":"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","sourcesContent":["var xtend = require('xtend')\nvar acorn = require('acorn-node')\nvar dash = require('dash-ast')\nvar getAssignedIdentifiers = require('get-assigned-identifiers')\n\nfunction visitFunction (node, state, ancestors) {\n  if (node.params.length > 0) {\n    var idents = []\n    for (var i = 0; i < node.params.length; i++) {\n      var sub = getAssignedIdentifiers(node.params[i])\n      for (var j = 0; j < sub.length; j++) idents.push(sub[j])\n    }\n    declareNames(node, idents)\n  }\n  if (node.type === 'FunctionDeclaration') {\n    var parent = getScopeNode(ancestors, 'const')\n    declareNames(parent, [node.id])\n  } else if (node.type === 'FunctionExpression' && node.id) {\n    declareNames(node, [node.id])\n  }\n}\n\nvar scopeVisitor = {\n  VariableDeclaration: function (node, state, ancestors) {\n    var parent = getScopeNode(ancestors, node.kind)\n    for (var i = 0; i < node.declarations.length; i++) {\n      declareNames(parent, getAssignedIdentifiers(node.declarations[i].id))\n    }\n  },\n  FunctionExpression: visitFunction,\n  FunctionDeclaration: visitFunction,\n  ArrowFunctionExpression: visitFunction,\n  ClassDeclaration: function (node, state, ancestors) {\n    var parent = getScopeNode(ancestors, 'const')\n    if (node.id) {\n      declareNames(parent, [node.id])\n    }\n  },\n  ImportDeclaration: function (node, state, ancestors) {\n    declareNames(ancestors[0] /* root */, getAssignedIdentifiers(node))\n  },\n  CatchClause: function (node) {\n    if (node.param) declareNames(node, [node.param])\n  }\n}\n\nvar bindingVisitor = {\n  Identifier: function (node, state, ancestors) {\n    if (!state.identifiers) return\n    var parent = ancestors[ancestors.length - 1]\n    if (parent.type === 'MemberExpression' && parent.property === node) return\n    if (parent.type === 'Property' && !parent.computed && parent.key === node) return\n    if (parent.type === 'MethodDefinition' && !parent.computed && parent.key === node) return\n    if (parent.type === 'LabeledStatement' && parent.label === node) return\n    if (!has(state.undeclared, node.name)) {\n      for (var i = ancestors.length - 1; i >= 0; i--) {\n        if (ancestors[i]._names !== undefined && has(ancestors[i]._names, node.name)) {\n          return\n        }\n      }\n\n      state.undeclared[node.name] = true\n    }\n\n    if (state.wildcard &&\n        !(parent.type === 'MemberExpression' && parent.object === node) &&\n        !(parent.type === 'VariableDeclarator' && parent.id === node) &&\n        !(parent.type === 'AssignmentExpression' && parent.left === node)) {\n      state.undeclaredProps[node.name + '.*'] = true\n    }\n  },\n  MemberExpression: function (node, state) {\n    if (!state.properties) return\n    if (node.object.type === 'Identifier' && has(state.undeclared, node.object.name)) {\n      var prop = !node.computed && node.property.type === 'Identifier'\n        ? node.property.name\n        : node.computed && node.property.type === 'Literal'\n          ? node.property.value\n          : null\n      if (prop) state.undeclaredProps[node.object.name + '.' + prop] = true\n    }\n  }\n}\n\nmodule.exports = function findUndeclared (src, opts) {\n  opts = xtend({\n    identifiers: true,\n    properties: true,\n    wildcard: false\n  }, opts)\n\n  var state = {\n    undeclared: {},\n    undeclaredProps: {},\n    identifiers: opts.identifiers,\n    properties: opts.properties,\n    wildcard: opts.wildcard\n  }\n\n  // Parse if `src` is not already an AST.\n  var ast = typeof src === 'object' && src !== null && typeof src.type === 'string'\n    ? src\n    : acorn.parse(src)\n\n  var parents = []\n  dash(ast, {\n    enter: function (node, parent) {\n      if (parent) parents.push(parent)\n      var visit = scopeVisitor[node.type]\n      if (visit) visit(node, state, parents)\n    },\n    leave: function (node, parent) {\n      var visit = bindingVisitor[node.type]\n      if (visit) visit(node, state, parents)\n      if (parent) parents.pop()\n    }\n  })\n\n  return {\n    identifiers: Object.keys(state.undeclared),\n    properties: Object.keys(state.undeclaredProps)\n  }\n}\n\nfunction getScopeNode (parents, kind) {\n  for (var i = parents.length - 1; i >= 0; i--) {\n    if (parents[i].type === 'FunctionDeclaration' || parents[i].type === 'FunctionExpression' ||\n        parents[i].type === 'ArrowFunctionExpression' || parents[i].type === 'Program') {\n      return parents[i]\n    }\n    if (kind !== 'var' && parents[i].type === 'BlockStatement') {\n      return parents[i]\n    }\n  }\n}\n\nfunction declareNames (node, names) {\n  if (node._names === undefined) {\n    node._names = Object.create(null)\n  }\n  for (var i = 0; i < names.length; i++) {\n    node._names[names[i].name] = true\n  }\n}\n\nfunction has (obj, name) { return Object.prototype.hasOwnProperty.call(obj, name) }\n"]},"metadata":{},"sourceType":"script"}