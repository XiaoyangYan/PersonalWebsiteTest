{"ast":null,"code":"'use strict';\n\nvar fs = require('fs');\n\nvar sysPath = require('path');\n\nvar readdirp = require('readdirp');\n\nvar fsevents;\n\ntry {\n  fsevents = require('fsevents');\n} catch (error) {} // fsevents instance helper functions\n// object to hold per-process fsevents instances\n// (may be shared across chokidar FSWatcher instances)\n\n\nvar FSEventsWatchers = Object.create(null); // Threshold of duplicate path prefixes at which to start\n// consolidating going forward\n\nvar consolidateThreshhold = 10; // Private function: Instantiates the fsevents interface\n// * path       - string, path to be watched\n// * callback   - function, called when fsevents is bound and ready\n// Returns new fsevents instance\n\nfunction createFSEventsInstance(path, callback) {\n  return new fsevents(path).on('fsevent', callback).start();\n} // Private function: Instantiates the fsevents interface or binds listeners\n// to an existing one covering the same file tree\n// * path       - string, path to be watched\n// * realPath   - string, real path (in case of symlinks)\n// * listener   - function, called when fsevents emits events\n// * rawEmitter - function, passes data to listeners of the 'raw' event\n// Returns close function\n\n\nfunction setFSEventsListener(path, realPath, listener, rawEmitter) {\n  var watchPath = sysPath.extname(path) ? sysPath.dirname(path) : path;\n  var watchContainer;\n  var parentPath = sysPath.dirname(watchPath); // If we've accumulated a substantial number of paths that\n  // could have been consolidated by watching one directory\n  // above the current one, create a watcher on the parent\n  // path instead, so that we do consolidate going forward.\n\n  if (couldConsolidate(parentPath)) {\n    watchPath = parentPath;\n  }\n\n  var resolvedPath = sysPath.resolve(path);\n  var hasSymlink = resolvedPath !== realPath;\n\n  function filteredListener(fullPath, flags, info) {\n    if (hasSymlink) fullPath = fullPath.replace(realPath, resolvedPath);\n    if (fullPath === resolvedPath || !fullPath.indexOf(resolvedPath + sysPath.sep)) listener(fullPath, flags, info);\n  } // check if there is already a watcher on a parent path\n  // modifies `watchPath` to the parent path when it finds a match\n\n\n  function watchedParent() {\n    return Object.keys(FSEventsWatchers).some(function (watchedPath) {\n      // condition is met when indexOf returns 0\n      if (!realPath.indexOf(sysPath.resolve(watchedPath) + sysPath.sep)) {\n        watchPath = watchedPath;\n        return true;\n      }\n    });\n  }\n\n  if (watchPath in FSEventsWatchers || watchedParent()) {\n    watchContainer = FSEventsWatchers[watchPath];\n    watchContainer.listeners.push(filteredListener);\n  } else {\n    watchContainer = FSEventsWatchers[watchPath] = {\n      listeners: [filteredListener],\n      rawEmitters: [rawEmitter],\n      watcher: createFSEventsInstance(watchPath, function (fullPath, flags) {\n        var info = fsevents.getInfo(fullPath, flags);\n        watchContainer.listeners.forEach(function (listener) {\n          listener(fullPath, flags, info);\n        });\n        watchContainer.rawEmitters.forEach(function (emitter) {\n          emitter(info.event, fullPath, info);\n        });\n      })\n    };\n  }\n\n  var listenerIndex = watchContainer.listeners.length - 1; // removes this instance's listeners and closes the underlying fsevents\n  // instance if there are no more listeners left\n\n  return function close() {\n    delete watchContainer.listeners[listenerIndex];\n    delete watchContainer.rawEmitters[listenerIndex];\n\n    if (!Object.keys(watchContainer.listeners).length) {\n      watchContainer.watcher.stop();\n      delete FSEventsWatchers[watchPath];\n    }\n  };\n} // Decide whether or not we should start a new higher-level\n// parent watcher\n\n\nfunction couldConsolidate(path) {\n  var keys = Object.keys(FSEventsWatchers);\n  var count = 0;\n\n  for (var i = 0, len = keys.length; i < len; ++i) {\n    var watchPath = keys[i];\n\n    if (watchPath.indexOf(path) === 0) {\n      count++;\n\n      if (count >= consolidateThreshhold) {\n        return true;\n      }\n    }\n  }\n\n  return false;\n} // returns boolean indicating whether fsevents can be used\n\n\nfunction canUse() {\n  return fsevents && Object.keys(FSEventsWatchers).length < 128;\n} // determines subdirectory traversal levels from root to path\n\n\nfunction depth(path, root) {\n  var i = 0;\n\n  while (!path.indexOf(root) && (path = sysPath.dirname(path)) !== root) i++;\n\n  return i;\n} // fake constructor for attaching fsevents-specific prototype methods that\n// will be copied to FSWatcher's prototype\n\n\nfunction FsEventsHandler() {} // Private method: Handle symlinks encountered during directory scan\n// * watchPath  - string, file/dir path to be watched with fsevents\n// * realPath   - string, real path (in case of symlinks)\n// * transform  - function, path transformer\n// * globFilter - function, path filter in case a glob pattern was provided\n// Returns close function for the watcher instance\n\n\nFsEventsHandler.prototype._watchWithFsEvents = function (watchPath, realPath, transform, globFilter) {\n  if (this._isIgnored(watchPath)) return;\n\n  var watchCallback = function (fullPath, flags, info) {\n    if (this.options.depth !== undefined && depth(fullPath, realPath) > this.options.depth) return;\n    var path = transform(sysPath.join(watchPath, sysPath.relative(watchPath, fullPath)));\n    if (globFilter && !globFilter(path)) return; // ensure directories are tracked\n\n    var parent = sysPath.dirname(path);\n    var item = sysPath.basename(path);\n\n    var watchedDir = this._getWatchedDir(info.type === 'directory' ? path : parent);\n\n    var checkIgnored = function (stats) {\n      if (this._isIgnored(path, stats)) {\n        this._ignoredPaths[path] = true;\n\n        if (stats && stats.isDirectory()) {\n          this._ignoredPaths[path + '/**/*'] = true;\n        }\n\n        return true;\n      } else {\n        delete this._ignoredPaths[path];\n        delete this._ignoredPaths[path + '/**/*'];\n      }\n    }.bind(this);\n\n    var handleEvent = function (event) {\n      if (checkIgnored()) return;\n\n      if (event === 'unlink') {\n        // suppress unlink events on never before seen files\n        if (info.type === 'directory' || watchedDir.has(item)) {\n          this._remove(parent, item);\n        }\n      } else {\n        if (event === 'add') {\n          // track new directories\n          if (info.type === 'directory') this._getWatchedDir(path);\n\n          if (info.type === 'symlink' && this.options.followSymlinks) {\n            // push symlinks back to the top of the stack to get handled\n            var curDepth = this.options.depth === undefined ? undefined : depth(fullPath, realPath) + 1;\n            return this._addToFsEvents(path, false, true, curDepth);\n          } else {\n            // track new paths\n            // (other than symlinks being followed, which will be tracked soon)\n            this._getWatchedDir(parent).add(item);\n          }\n        }\n\n        var eventName = info.type === 'directory' ? event + 'Dir' : event;\n\n        this._emit(eventName, path);\n\n        if (eventName === 'addDir') this._addToFsEvents(path, false, true);\n      }\n    }.bind(this);\n\n    function addOrChange() {\n      handleEvent(watchedDir.has(item) ? 'change' : 'add');\n    }\n\n    function checkFd() {\n      fs.open(path, 'r', function (error, fd) {\n        if (fd) fs.close(fd);\n        error && error.code !== 'EACCES' ? handleEvent('unlink') : addOrChange();\n      });\n    } // correct for wrong events emitted\n\n\n    var wrongEventFlags = [69888, 70400, 71424, 72704, 73472, 131328, 131840, 262912];\n\n    if (wrongEventFlags.indexOf(flags) !== -1 || info.event === 'unknown') {\n      if (typeof this.options.ignored === 'function') {\n        fs.stat(path, function (error, stats) {\n          if (checkIgnored(stats)) return;\n          stats ? addOrChange() : handleEvent('unlink');\n        });\n      } else {\n        checkFd();\n      }\n    } else {\n      switch (info.event) {\n        case 'created':\n        case 'modified':\n          return addOrChange();\n\n        case 'deleted':\n        case 'moved':\n          return checkFd();\n      }\n    }\n  }.bind(this);\n\n  var closer = setFSEventsListener(watchPath, realPath, watchCallback, this.emit.bind(this, 'raw'));\n\n  this._emitReady();\n\n  return closer;\n}; // Private method: Handle symlinks encountered during directory scan\n// * linkPath   - string, path to symlink\n// * fullPath   - string, absolute path to the symlink\n// * transform  - function, pre-existing path transformer\n// * curDepth   - int, level of subdirectories traversed to where symlink is\n// Returns nothing\n\n\nFsEventsHandler.prototype._handleFsEventsSymlink = function (linkPath, fullPath, transform, curDepth) {\n  // don't follow the same symlink more than once\n  if (this._symlinkPaths[fullPath]) return;else this._symlinkPaths[fullPath] = true;\n  this._readyCount++;\n  fs.realpath(linkPath, function (error, linkTarget) {\n    if (this._handleError(error) || this._isIgnored(linkTarget)) {\n      return this._emitReady();\n    }\n\n    this._readyCount++; // add the linkTarget for watching with a wrapper for transform\n    // that causes emitted paths to incorporate the link's path\n\n    this._addToFsEvents(linkTarget || linkPath, function (path) {\n      var dotSlash = '.' + sysPath.sep;\n      var aliasedPath = linkPath;\n\n      if (linkTarget && linkTarget !== dotSlash) {\n        aliasedPath = path.replace(linkTarget, linkPath);\n      } else if (path !== dotSlash) {\n        aliasedPath = sysPath.join(linkPath, path);\n      }\n\n      return transform(aliasedPath);\n    }, false, curDepth);\n  }.bind(this));\n}; // Private method: Handle added path with fsevents\n// * path       - string, file/directory path or glob pattern\n// * transform  - function, converts working path to what the user expects\n// * forceAdd   - boolean, ensure add is emitted\n// * priorDepth - int, level of subdirectories already traversed\n// Returns nothing\n\n\nFsEventsHandler.prototype._addToFsEvents = function (path, transform, forceAdd, priorDepth) {\n  // applies transform if provided, otherwise returns same value\n  var processPath = typeof transform === 'function' ? transform : function (val) {\n    return val;\n  };\n\n  var emitAdd = function (newPath, stats) {\n    var pp = processPath(newPath);\n    var isDir = stats.isDirectory();\n\n    var dirObj = this._getWatchedDir(sysPath.dirname(pp));\n\n    var base = sysPath.basename(pp); // ensure empty dirs get tracked\n\n    if (isDir) this._getWatchedDir(pp);\n    if (dirObj.has(base)) return;\n    dirObj.add(base);\n\n    if (!this.options.ignoreInitial || forceAdd === true) {\n      this._emit(isDir ? 'addDir' : 'add', pp, stats);\n    }\n  }.bind(this);\n\n  var wh = this._getWatchHelpers(path); // evaluate what is at the path we're being asked to watch\n\n\n  fs[wh.statMethod](wh.watchPath, function (error, stats) {\n    if (this._handleError(error) || this._isIgnored(wh.watchPath, stats)) {\n      this._emitReady();\n\n      return this._emitReady();\n    }\n\n    if (stats.isDirectory()) {\n      // emit addDir unless this is a glob parent\n      if (!wh.globFilter) emitAdd(processPath(path), stats); // don't recurse further if it would exceed depth setting\n\n      if (priorDepth && priorDepth > this.options.depth) return; // scan the contents of the dir\n\n      readdirp({\n        root: wh.watchPath,\n        entryType: 'all',\n        fileFilter: wh.filterPath,\n        directoryFilter: wh.filterDir,\n        lstat: true,\n        depth: this.options.depth - (priorDepth || 0)\n      }).on('data', function (entry) {\n        // need to check filterPath on dirs b/c filterDir is less restrictive\n        if (entry.stat.isDirectory() && !wh.filterPath(entry)) return;\n        var joinedPath = sysPath.join(wh.watchPath, entry.path);\n        var fullPath = entry.fullPath;\n\n        if (wh.followSymlinks && entry.stat.isSymbolicLink()) {\n          // preserve the current depth here since it can't be derived from\n          // real paths past the symlink\n          var curDepth = this.options.depth === undefined ? undefined : depth(joinedPath, sysPath.resolve(wh.watchPath)) + 1;\n\n          this._handleFsEventsSymlink(joinedPath, fullPath, processPath, curDepth);\n        } else {\n          emitAdd(joinedPath, entry.stat);\n        }\n      }.bind(this)).on('error', function () {// Ignore readdirp errors\n      }).on('end', this._emitReady);\n    } else {\n      emitAdd(wh.watchPath, stats);\n\n      this._emitReady();\n    }\n  }.bind(this));\n\n  if (this.options.persistent && forceAdd !== true) {\n    var initWatch = function (error, realPath) {\n      if (this.closed) return;\n\n      var closer = this._watchWithFsEvents(wh.watchPath, sysPath.resolve(realPath || wh.watchPath), processPath, wh.globFilter);\n\n      if (closer) this._closers[path] = closer;\n    }.bind(this);\n\n    if (typeof transform === 'function') {\n      // realpath has already been resolved\n      initWatch();\n    } else {\n      fs.realpath(wh.watchPath, initWatch);\n    }\n  }\n};\n\nmodule.exports = FsEventsHandler;\nmodule.exports.canUse = canUse;","map":{"version":3,"sources":["/home/yanxiaoyang/react-project/PersonalWebsiteTest/node_modules/rijs.resdir/node_modules/chokidar/lib/fsevents-handler.js"],"names":["fs","require","sysPath","readdirp","fsevents","error","FSEventsWatchers","Object","create","consolidateThreshhold","createFSEventsInstance","path","callback","on","start","setFSEventsListener","realPath","listener","rawEmitter","watchPath","extname","dirname","watchContainer","parentPath","couldConsolidate","resolvedPath","resolve","hasSymlink","filteredListener","fullPath","flags","info","replace","indexOf","sep","watchedParent","keys","some","watchedPath","listeners","push","rawEmitters","watcher","getInfo","forEach","emitter","event","listenerIndex","length","close","stop","count","i","len","canUse","depth","root","FsEventsHandler","prototype","_watchWithFsEvents","transform","globFilter","_isIgnored","watchCallback","options","undefined","join","relative","parent","item","basename","watchedDir","_getWatchedDir","type","checkIgnored","stats","_ignoredPaths","isDirectory","bind","handleEvent","has","_remove","followSymlinks","curDepth","_addToFsEvents","add","eventName","_emit","addOrChange","checkFd","open","fd","code","wrongEventFlags","ignored","stat","closer","emit","_emitReady","_handleFsEventsSymlink","linkPath","_symlinkPaths","_readyCount","realpath","linkTarget","_handleError","dotSlash","aliasedPath","forceAdd","priorDepth","processPath","val","emitAdd","newPath","pp","isDir","dirObj","base","ignoreInitial","wh","_getWatchHelpers","statMethod","entryType","fileFilter","filterPath","directoryFilter","filterDir","lstat","entry","joinedPath","isSymbolicLink","persistent","initWatch","closed","_closers","module","exports"],"mappings":"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","sourcesContent":["'use strict';\n\nvar fs = require('fs');\nvar sysPath = require('path');\nvar readdirp = require('readdirp');\nvar fsevents;\ntry { fsevents = require('fsevents'); } catch (error) {}\n\n// fsevents instance helper functions\n\n// object to hold per-process fsevents instances\n// (may be shared across chokidar FSWatcher instances)\nvar FSEventsWatchers = Object.create(null);\n\n// Threshold of duplicate path prefixes at which to start\n// consolidating going forward\nvar consolidateThreshhold = 10;\n\n// Private function: Instantiates the fsevents interface\n\n// * path       - string, path to be watched\n// * callback   - function, called when fsevents is bound and ready\n\n// Returns new fsevents instance\nfunction createFSEventsInstance(path, callback) {\n  return (new fsevents(path)).on('fsevent', callback).start();\n}\n\n// Private function: Instantiates the fsevents interface or binds listeners\n// to an existing one covering the same file tree\n\n// * path       - string, path to be watched\n// * realPath   - string, real path (in case of symlinks)\n// * listener   - function, called when fsevents emits events\n// * rawEmitter - function, passes data to listeners of the 'raw' event\n\n// Returns close function\nfunction setFSEventsListener(path, realPath, listener, rawEmitter) {\n  var watchPath = sysPath.extname(path) ? sysPath.dirname(path) : path;\n  var watchContainer;\n  var parentPath = sysPath.dirname(watchPath);\n\n  // If we've accumulated a substantial number of paths that\n  // could have been consolidated by watching one directory\n  // above the current one, create a watcher on the parent\n  // path instead, so that we do consolidate going forward.\n  if (couldConsolidate(parentPath)) {\n    watchPath = parentPath;\n  }\n\n  var resolvedPath = sysPath.resolve(path);\n  var hasSymlink = resolvedPath !== realPath;\n  function filteredListener(fullPath, flags, info) {\n    if (hasSymlink) fullPath = fullPath.replace(realPath, resolvedPath);\n    if (\n      fullPath === resolvedPath ||\n      !fullPath.indexOf(resolvedPath + sysPath.sep)\n    ) listener(fullPath, flags, info);\n  }\n\n  // check if there is already a watcher on a parent path\n  // modifies `watchPath` to the parent path when it finds a match\n  function watchedParent() {\n    return Object.keys(FSEventsWatchers).some(function(watchedPath) {\n      // condition is met when indexOf returns 0\n      if (!realPath.indexOf(sysPath.resolve(watchedPath) + sysPath.sep)) {\n        watchPath = watchedPath;\n        return true;\n      }\n    });\n  }\n\n  if (watchPath in FSEventsWatchers || watchedParent()) {\n    watchContainer = FSEventsWatchers[watchPath];\n    watchContainer.listeners.push(filteredListener);\n  } else {\n    watchContainer = FSEventsWatchers[watchPath] = {\n      listeners: [filteredListener],\n      rawEmitters: [rawEmitter],\n      watcher: createFSEventsInstance(watchPath, function(fullPath, flags) {\n        var info = fsevents.getInfo(fullPath, flags);\n        watchContainer.listeners.forEach(function(listener) {\n          listener(fullPath, flags, info);\n        });\n        watchContainer.rawEmitters.forEach(function(emitter) {\n          emitter(info.event, fullPath, info);\n        });\n      })\n    };\n  }\n  var listenerIndex = watchContainer.listeners.length - 1;\n\n  // removes this instance's listeners and closes the underlying fsevents\n  // instance if there are no more listeners left\n  return function close() {\n    delete watchContainer.listeners[listenerIndex];\n    delete watchContainer.rawEmitters[listenerIndex];\n    if (!Object.keys(watchContainer.listeners).length) {\n      watchContainer.watcher.stop();\n      delete FSEventsWatchers[watchPath];\n    }\n  };\n}\n\n// Decide whether or not we should start a new higher-level\n// parent watcher\nfunction couldConsolidate(path) {\n  var keys = Object.keys(FSEventsWatchers);\n  var count = 0;\n\n  for (var i = 0, len = keys.length; i < len; ++i) {\n    var watchPath = keys[i];\n    if (watchPath.indexOf(path) === 0) {\n      count++;\n      if (count >= consolidateThreshhold) {\n        return true;\n      }\n    }\n  }\n\n  return false;\n}\n\n// returns boolean indicating whether fsevents can be used\nfunction canUse() {\n  return fsevents && Object.keys(FSEventsWatchers).length < 128;\n}\n\n// determines subdirectory traversal levels from root to path\nfunction depth(path, root) {\n  var i = 0;\n  while (!path.indexOf(root) && (path = sysPath.dirname(path)) !== root) i++;\n  return i;\n}\n\n// fake constructor for attaching fsevents-specific prototype methods that\n// will be copied to FSWatcher's prototype\nfunction FsEventsHandler() {}\n\n// Private method: Handle symlinks encountered during directory scan\n\n// * watchPath  - string, file/dir path to be watched with fsevents\n// * realPath   - string, real path (in case of symlinks)\n// * transform  - function, path transformer\n// * globFilter - function, path filter in case a glob pattern was provided\n\n// Returns close function for the watcher instance\nFsEventsHandler.prototype._watchWithFsEvents =\nfunction(watchPath, realPath, transform, globFilter) {\n  if (this._isIgnored(watchPath)) return;\n  var watchCallback = function(fullPath, flags, info) {\n    if (\n      this.options.depth !== undefined &&\n      depth(fullPath, realPath) > this.options.depth\n    ) return;\n    var path = transform(sysPath.join(\n      watchPath, sysPath.relative(watchPath, fullPath)\n    ));\n    if (globFilter && !globFilter(path)) return;\n    // ensure directories are tracked\n    var parent = sysPath.dirname(path);\n    var item = sysPath.basename(path);\n    var watchedDir = this._getWatchedDir(\n      info.type === 'directory' ? path : parent\n    );\n    var checkIgnored = function(stats) {\n      if (this._isIgnored(path, stats)) {\n        this._ignoredPaths[path] = true;\n        if (stats && stats.isDirectory()) {\n          this._ignoredPaths[path + '/**/*'] = true;\n        }\n        return true;\n      } else {\n        delete this._ignoredPaths[path];\n        delete this._ignoredPaths[path + '/**/*'];\n      }\n    }.bind(this);\n\n    var handleEvent = function(event) {\n      if (checkIgnored()) return;\n\n      if (event === 'unlink') {\n        // suppress unlink events on never before seen files\n        if (info.type === 'directory' || watchedDir.has(item)) {\n          this._remove(parent, item);\n        }\n      } else {\n        if (event === 'add') {\n          // track new directories\n          if (info.type === 'directory') this._getWatchedDir(path);\n\n          if (info.type === 'symlink' && this.options.followSymlinks) {\n            // push symlinks back to the top of the stack to get handled\n            var curDepth = this.options.depth === undefined ?\n              undefined : depth(fullPath, realPath) + 1;\n            return this._addToFsEvents(path, false, true, curDepth);\n          } else {\n            // track new paths\n            // (other than symlinks being followed, which will be tracked soon)\n            this._getWatchedDir(parent).add(item);\n          }\n        }\n        var eventName = info.type === 'directory' ? event + 'Dir' : event;\n        this._emit(eventName, path);\n        if (eventName === 'addDir') this._addToFsEvents(path, false, true);\n      }\n    }.bind(this);\n\n    function addOrChange() {\n      handleEvent(watchedDir.has(item) ? 'change' : 'add');\n    }\n    function checkFd() {\n      fs.open(path, 'r', function(error, fd) {\n        if (fd) fs.close(fd);\n        error && error.code !== 'EACCES' ?\n          handleEvent('unlink') : addOrChange();\n      });\n    }\n    // correct for wrong events emitted\n    var wrongEventFlags = [\n      69888, 70400, 71424, 72704, 73472, 131328, 131840, 262912\n    ];\n    if (wrongEventFlags.indexOf(flags) !== -1 || info.event === 'unknown') {\n      if (typeof this.options.ignored === 'function') {\n        fs.stat(path, function(error, stats) {\n          if (checkIgnored(stats)) return;\n          stats ? addOrChange() : handleEvent('unlink');\n        });\n      } else {\n        checkFd();\n      }\n    } else {\n      switch (info.event) {\n      case 'created':\n      case 'modified':\n        return addOrChange();\n      case 'deleted':\n      case 'moved':\n        return checkFd();\n      }\n    }\n  }.bind(this);\n\n  var closer = setFSEventsListener(\n    watchPath,\n    realPath,\n    watchCallback,\n    this.emit.bind(this, 'raw')\n  );\n\n  this._emitReady();\n  return closer;\n};\n\n// Private method: Handle symlinks encountered during directory scan\n\n// * linkPath   - string, path to symlink\n// * fullPath   - string, absolute path to the symlink\n// * transform  - function, pre-existing path transformer\n// * curDepth   - int, level of subdirectories traversed to where symlink is\n\n// Returns nothing\nFsEventsHandler.prototype._handleFsEventsSymlink =\nfunction(linkPath, fullPath, transform, curDepth) {\n  // don't follow the same symlink more than once\n  if (this._symlinkPaths[fullPath]) return;\n  else this._symlinkPaths[fullPath] = true;\n\n  this._readyCount++;\n\n  fs.realpath(linkPath, function(error, linkTarget) {\n    if (this._handleError(error) || this._isIgnored(linkTarget)) {\n      return this._emitReady();\n    }\n\n    this._readyCount++;\n\n    // add the linkTarget for watching with a wrapper for transform\n    // that causes emitted paths to incorporate the link's path\n    this._addToFsEvents(linkTarget || linkPath, function(path) {\n      var dotSlash = '.' + sysPath.sep;\n      var aliasedPath = linkPath;\n      if (linkTarget && linkTarget !== dotSlash) {\n        aliasedPath = path.replace(linkTarget, linkPath);\n      } else if (path !== dotSlash) {\n        aliasedPath = sysPath.join(linkPath, path);\n      }\n      return transform(aliasedPath);\n    }, false, curDepth);\n  }.bind(this));\n};\n\n// Private method: Handle added path with fsevents\n\n// * path       - string, file/directory path or glob pattern\n// * transform  - function, converts working path to what the user expects\n// * forceAdd   - boolean, ensure add is emitted\n// * priorDepth - int, level of subdirectories already traversed\n\n// Returns nothing\nFsEventsHandler.prototype._addToFsEvents =\nfunction(path, transform, forceAdd, priorDepth) {\n\n  // applies transform if provided, otherwise returns same value\n  var processPath = typeof transform === 'function' ?\n    transform : function(val) { return val; };\n\n  var emitAdd = function(newPath, stats) {\n    var pp = processPath(newPath);\n    var isDir = stats.isDirectory();\n    var dirObj = this._getWatchedDir(sysPath.dirname(pp));\n    var base = sysPath.basename(pp);\n\n    // ensure empty dirs get tracked\n    if (isDir) this._getWatchedDir(pp);\n\n    if (dirObj.has(base)) return;\n    dirObj.add(base);\n\n    if (!this.options.ignoreInitial || forceAdd === true) {\n      this._emit(isDir ? 'addDir' : 'add', pp, stats);\n    }\n  }.bind(this);\n\n  var wh = this._getWatchHelpers(path);\n\n  // evaluate what is at the path we're being asked to watch\n  fs[wh.statMethod](wh.watchPath, function(error, stats) {\n    if (this._handleError(error) || this._isIgnored(wh.watchPath, stats)) {\n      this._emitReady();\n      return this._emitReady();\n    }\n\n    if (stats.isDirectory()) {\n      // emit addDir unless this is a glob parent\n      if (!wh.globFilter) emitAdd(processPath(path), stats);\n\n      // don't recurse further if it would exceed depth setting\n      if (priorDepth && priorDepth > this.options.depth) return;\n\n      // scan the contents of the dir\n      readdirp({\n        root: wh.watchPath,\n        entryType: 'all',\n        fileFilter: wh.filterPath,\n        directoryFilter: wh.filterDir,\n        lstat: true,\n        depth: this.options.depth - (priorDepth || 0)\n      }).on('data', function(entry) {\n        // need to check filterPath on dirs b/c filterDir is less restrictive\n        if (entry.stat.isDirectory() && !wh.filterPath(entry)) return;\n\n        var joinedPath = sysPath.join(wh.watchPath, entry.path);\n        var fullPath = entry.fullPath;\n\n        if (wh.followSymlinks && entry.stat.isSymbolicLink()) {\n          // preserve the current depth here since it can't be derived from\n          // real paths past the symlink\n          var curDepth = this.options.depth === undefined ?\n            undefined : depth(joinedPath, sysPath.resolve(wh.watchPath)) + 1;\n\n          this._handleFsEventsSymlink(joinedPath, fullPath, processPath, curDepth);\n        } else {\n          emitAdd(joinedPath, entry.stat);\n        }\n      }.bind(this)).on('error', function() {\n        // Ignore readdirp errors\n      }).on('end', this._emitReady);\n    } else {\n      emitAdd(wh.watchPath, stats);\n      this._emitReady();\n    }\n  }.bind(this));\n\n  if (this.options.persistent && forceAdd !== true) {\n    var initWatch = function(error, realPath) {\n      if (this.closed) return;\n      var closer = this._watchWithFsEvents(\n        wh.watchPath,\n        sysPath.resolve(realPath || wh.watchPath),\n        processPath,\n        wh.globFilter\n      );\n      if (closer) this._closers[path] = closer;\n    }.bind(this);\n\n    if (typeof transform === 'function') {\n      // realpath has already been resolved\n      initWatch();\n    } else {\n      fs.realpath(wh.watchPath, initWatch);\n    }\n  }\n};\n\nmodule.exports = FsEventsHandler;\nmodule.exports.canUse = canUse;\n"]},"metadata":{},"sourceType":"script"}