{"ast":null,"code":"'use strict';\n\nvar fs = require('fs');\n\nvar path = require('path');\n\nvar commentRx = /^\\s*\\/(?:\\/|\\*)[@#]\\s+sourceMappingURL=data:(?:application|text)\\/json;(?:charset[:=]\\S+;)?base64,(.*)$/mg;\nvar mapFileCommentRx = //Example (Extra space between slashes added to solve Safari bug. Exclude space in production):\n//     / /# sourceMappingURL=foo.js.map           /*# sourceMappingURL=foo.js.map */\n/(?:\\/\\/[@#][ \\t]+sourceMappingURL=([^\\s'\"]+?)[ \\t]*$)|(?:\\/\\*[@#][ \\t]+sourceMappingURL=([^\\*]+?)[ \\t]*(?:\\*\\/){1}[ \\t]*$)/mg;\n\nfunction decodeBase64(base64) {\n  return new Buffer(base64, 'base64').toString();\n}\n\nfunction stripComment(sm) {\n  return sm.split(',').pop();\n}\n\nfunction readFromFileMap(sm, dir) {\n  // NOTE: this will only work on the server since it attempts to read the map file\n  var r = mapFileCommentRx.exec(sm);\n  mapFileCommentRx.lastIndex = 0; // for some odd reason //# .. captures in 1 and /* .. */ in 2\n\n  var filename = r[1] || r[2];\n  var filepath = path.join(dir, filename);\n\n  try {\n    return fs.readFileSync(filepath, 'utf8');\n  } catch (e) {\n    throw new Error('An error occurred while trying to read the map file at ' + filepath + '\\n' + e);\n  }\n}\n\nfunction Converter(sm, opts) {\n  opts = opts || {};\n  if (opts.isFileComment) sm = readFromFileMap(sm, opts.commentFileDir);\n  if (opts.hasComment) sm = stripComment(sm);\n  if (opts.isEncoded) sm = decodeBase64(sm);\n  if (opts.isJSON || opts.isEncoded) sm = JSON.parse(sm);\n  this.sourcemap = sm;\n}\n\nfunction convertFromLargeSource(content) {\n  var lines = content.split('\\n');\n  var line; // find first line which contains a source map starting at end of content\n\n  for (var i = lines.length - 1; i > 0; i--) {\n    line = lines[i];\n    if (~line.indexOf('sourceMappingURL=data:')) return exports.fromComment(line);\n  }\n}\n\nConverter.prototype.toJSON = function (space) {\n  return JSON.stringify(this.sourcemap, null, space);\n};\n\nConverter.prototype.toBase64 = function () {\n  var json = this.toJSON();\n  return new Buffer(json).toString('base64');\n};\n\nConverter.prototype.toComment = function (options) {\n  var base64 = this.toBase64();\n  var data = 'sourceMappingURL=data:application/json;base64,' + base64;\n  return options && options.multiline ? '/*# ' + data + ' */' : '//# ' + data;\n}; // returns copy instead of original\n\n\nConverter.prototype.toObject = function () {\n  return JSON.parse(this.toJSON());\n};\n\nConverter.prototype.addProperty = function (key, value) {\n  if (this.sourcemap.hasOwnProperty(key)) throw new Error('property %s already exists on the sourcemap, use set property instead');\n  return this.setProperty(key, value);\n};\n\nConverter.prototype.setProperty = function (key, value) {\n  this.sourcemap[key] = value;\n  return this;\n};\n\nConverter.prototype.getProperty = function (key) {\n  return this.sourcemap[key];\n};\n\nexports.fromObject = function (obj) {\n  return new Converter(obj);\n};\n\nexports.fromJSON = function (json) {\n  return new Converter(json, {\n    isJSON: true\n  });\n};\n\nexports.fromBase64 = function (base64) {\n  return new Converter(base64, {\n    isEncoded: true\n  });\n};\n\nexports.fromComment = function (comment) {\n  comment = comment.replace(/^\\/\\*/g, '//').replace(/\\*\\/$/g, '');\n  return new Converter(comment, {\n    isEncoded: true,\n    hasComment: true\n  });\n};\n\nexports.fromMapFileComment = function (comment, dir) {\n  return new Converter(comment, {\n    commentFileDir: dir,\n    isFileComment: true,\n    isJSON: true\n  });\n}; // Finds last sourcemap comment in file or returns null if none was found\n\n\nexports.fromSource = function (content, largeSource) {\n  if (largeSource) {\n    var res = convertFromLargeSource(content);\n    return res ? res : null;\n  }\n\n  var m = content.match(commentRx);\n  commentRx.lastIndex = 0;\n  return m ? exports.fromComment(m.pop()) : null;\n}; // Finds last sourcemap comment in file or returns null if none was found\n\n\nexports.fromMapFileSource = function (content, dir) {\n  var m = content.match(mapFileCommentRx);\n  mapFileCommentRx.lastIndex = 0;\n  return m ? exports.fromMapFileComment(m.pop(), dir) : null;\n};\n\nexports.removeComments = function (src) {\n  commentRx.lastIndex = 0;\n  return src.replace(commentRx, '');\n};\n\nexports.removeMapFileComments = function (src) {\n  mapFileCommentRx.lastIndex = 0;\n  return src.replace(mapFileCommentRx, '');\n};\n\nObject.defineProperty(exports, 'commentRegex', {\n  get: function getCommentRegex() {\n    commentRx.lastIndex = 0;\n    return commentRx;\n  }\n});\nObject.defineProperty(exports, 'mapFileCommentRegex', {\n  get: function getMapFileCommentRegex() {\n    mapFileCommentRx.lastIndex = 0;\n    return mapFileCommentRx;\n  }\n});","map":{"version":3,"sources":["/home/yanxiaoyang/react-project/PersonalWebsiteTest/node_modules/combine-source-map/node_modules/convert-source-map/index.js"],"names":["fs","require","path","commentRx","mapFileCommentRx","decodeBase64","base64","Buffer","toString","stripComment","sm","split","pop","readFromFileMap","dir","r","exec","lastIndex","filename","filepath","join","readFileSync","e","Error","Converter","opts","isFileComment","commentFileDir","hasComment","isEncoded","isJSON","JSON","parse","sourcemap","convertFromLargeSource","content","lines","line","i","length","indexOf","exports","fromComment","prototype","toJSON","space","stringify","toBase64","json","toComment","options","data","multiline","toObject","addProperty","key","value","hasOwnProperty","setProperty","getProperty","fromObject","obj","fromJSON","fromBase64","comment","replace","fromMapFileComment","fromSource","largeSource","res","m","match","fromMapFileSource","removeComments","src","removeMapFileComments","Object","defineProperty","get","getCommentRegex","getMapFileCommentRegex"],"mappings":"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","sourcesContent":["'use strict';\nvar fs = require('fs');\nvar path = require('path');\n\nvar commentRx = /^\\s*\\/(?:\\/|\\*)[@#]\\s+sourceMappingURL=data:(?:application|text)\\/json;(?:charset[:=]\\S+;)?base64,(.*)$/mg;\nvar mapFileCommentRx =\n  //Example (Extra space between slashes added to solve Safari bug. Exclude space in production):\n  //     / /# sourceMappingURL=foo.js.map           /*# sourceMappingURL=foo.js.map */\n  /(?:\\/\\/[@#][ \\t]+sourceMappingURL=([^\\s'\"]+?)[ \\t]*$)|(?:\\/\\*[@#][ \\t]+sourceMappingURL=([^\\*]+?)[ \\t]*(?:\\*\\/){1}[ \\t]*$)/mg\n\nfunction decodeBase64(base64) {\n  return new Buffer(base64, 'base64').toString();\n}\n\nfunction stripComment(sm) {\n  return sm.split(',').pop();\n}\n\nfunction readFromFileMap(sm, dir) {\n  // NOTE: this will only work on the server since it attempts to read the map file\n\n  var r = mapFileCommentRx.exec(sm);\n  mapFileCommentRx.lastIndex = 0;\n\n  // for some odd reason //# .. captures in 1 and /* .. */ in 2\n  var filename = r[1] || r[2];\n  var filepath = path.join(dir, filename);\n\n  try {\n    return fs.readFileSync(filepath, 'utf8');\n  } catch (e) {\n    throw new Error('An error occurred while trying to read the map file at ' + filepath + '\\n' + e);\n  }\n}\n\nfunction Converter (sm, opts) {\n  opts = opts || {};\n\n  if (opts.isFileComment) sm = readFromFileMap(sm, opts.commentFileDir);\n  if (opts.hasComment) sm = stripComment(sm);\n  if (opts.isEncoded) sm = decodeBase64(sm);\n  if (opts.isJSON || opts.isEncoded) sm = JSON.parse(sm);\n\n  this.sourcemap = sm;\n}\n\nfunction convertFromLargeSource(content){\n  var lines = content.split('\\n');\n  var line;\n  // find first line which contains a source map starting at end of content\n  for (var i = lines.length - 1; i > 0; i--) {\n    line = lines[i]\n    if (~line.indexOf('sourceMappingURL=data:')) return exports.fromComment(line);\n  }\n}\n\nConverter.prototype.toJSON = function (space) {\n  return JSON.stringify(this.sourcemap, null, space);\n};\n\nConverter.prototype.toBase64 = function () {\n  var json = this.toJSON();\n  return new Buffer(json).toString('base64');\n};\n\nConverter.prototype.toComment = function (options) {\n  var base64 = this.toBase64();\n  var data = 'sourceMappingURL=data:application/json;base64,' + base64;\n  return options && options.multiline ? '/*# ' + data + ' */' : '//# ' + data;\n};\n\n// returns copy instead of original\nConverter.prototype.toObject = function () {\n  return JSON.parse(this.toJSON());\n};\n\nConverter.prototype.addProperty = function (key, value) {\n  if (this.sourcemap.hasOwnProperty(key)) throw new Error('property %s already exists on the sourcemap, use set property instead');\n  return this.setProperty(key, value);\n};\n\nConverter.prototype.setProperty = function (key, value) {\n  this.sourcemap[key] = value;\n  return this;\n};\n\nConverter.prototype.getProperty = function (key) {\n  return this.sourcemap[key];\n};\n\nexports.fromObject = function (obj) {\n  return new Converter(obj);\n};\n\nexports.fromJSON = function (json) {\n  return new Converter(json, { isJSON: true });\n};\n\nexports.fromBase64 = function (base64) {\n  return new Converter(base64, { isEncoded: true });\n};\n\nexports.fromComment = function (comment) {\n  comment = comment\n    .replace(/^\\/\\*/g, '//')\n    .replace(/\\*\\/$/g, '');\n\n  return new Converter(comment, { isEncoded: true, hasComment: true });\n};\n\nexports.fromMapFileComment = function (comment, dir) {\n  return new Converter(comment, { commentFileDir: dir, isFileComment: true, isJSON: true });\n};\n\n// Finds last sourcemap comment in file or returns null if none was found\nexports.fromSource = function (content, largeSource) {\n  if (largeSource) {\n    var res = convertFromLargeSource(content);\n    return res ? res : null;\n  }\n\n  var m = content.match(commentRx);\n  commentRx.lastIndex = 0;\n  return m ? exports.fromComment(m.pop()) : null;\n};\n\n// Finds last sourcemap comment in file or returns null if none was found\nexports.fromMapFileSource = function (content, dir) {\n  var m = content.match(mapFileCommentRx);\n  mapFileCommentRx.lastIndex = 0;\n  return m ? exports.fromMapFileComment(m.pop(), dir) : null;\n};\n\nexports.removeComments = function (src) {\n  commentRx.lastIndex = 0;\n  return src.replace(commentRx, '');\n};\n\nexports.removeMapFileComments = function (src) {\n  mapFileCommentRx.lastIndex = 0;\n  return src.replace(mapFileCommentRx, '');\n};\n\nObject.defineProperty(exports, 'commentRegex', {\n  get: function getCommentRegex () {\n    commentRx.lastIndex = 0;\n    return commentRx;\n  }\n});\n\nObject.defineProperty(exports, 'mapFileCommentRegex', {\n  get: function getMapFileCommentRegex () {\n    mapFileCommentRx.lastIndex = 0;\n    return mapFileCommentRx;\n  }\n});\n"]},"metadata":{},"sourceType":"script"}