{"ast":null,"code":"/*!\n * extglob <https://github.com/jonschlinkert/extglob>\n *\n * Copyright (c) 2015, Jon Schlinkert.\n * Licensed under the MIT License.\n */\n'use strict';\n/**\n * Module dependencies\n */\n\nvar isExtglob = require('is-extglob');\n\nvar re,\n    cache = {};\n/**\n * Expose `extglob`\n */\n\nmodule.exports = extglob;\n/**\n * Convert the given extglob `string` to a regex-compatible\n * string.\n *\n * ```js\n * var extglob = require('extglob');\n * extglob('!(a?(b))');\n * //=> '(?!a(?:b)?)[^/]*?'\n * ```\n *\n * @param {String} `str` The string to convert.\n * @param {Object} `options`\n *   @option {Boolean} [options] `esc` If `false` special characters will not be escaped. Defaults to `true`.\n *   @option {Boolean} [options] `regex` If `true` a regular expression is returned instead of a string.\n * @return {String}\n * @api public\n */\n\nfunction extglob(str, opts) {\n  opts = opts || {};\n  var o = {},\n      i = 0; // fix common character reversals\n  // '*!(.js)' => '*.!(js)'\n\n  str = str.replace(/!\\(([^\\w*()])/g, '$1!('); // support file extension negation\n\n  str = str.replace(/([*\\/])\\.!\\([*]\\)/g, function (m, ch) {\n    if (ch === '/') {\n      return escape('\\\\/[^.]+');\n    }\n\n    return escape('[^.]+');\n  }); // create a unique key for caching by\n  // combining the string and options\n\n  var key = str + String(!!opts.regex) + String(!!opts.contains) + String(!!opts.escape);\n\n  if (cache.hasOwnProperty(key)) {\n    return cache[key];\n  }\n\n  if (!(re instanceof RegExp)) {\n    re = regex();\n  }\n\n  opts.negate = false;\n  var m;\n\n  while (m = re.exec(str)) {\n    var prefix = m[1];\n    var inner = m[3];\n\n    if (prefix === '!') {\n      opts.negate = true;\n    }\n\n    var id = '__EXTGLOB_' + i++ + '__'; // use the prefix of the _last_ (outtermost) pattern\n\n    o[id] = wrap(inner, prefix, opts.escape);\n    str = str.split(m[0]).join(id);\n  }\n\n  var keys = Object.keys(o);\n  var len = keys.length; // we have to loop again to allow us to convert\n  // patterns in reverse order (starting with the\n  // innermost/last pattern first)\n\n  while (len--) {\n    var prop = keys[len];\n    str = str.split(prop).join(o[prop]);\n  }\n\n  var result = opts.regex ? toRegex(str, opts.contains, opts.negate) : str;\n  result = result.split('.').join('\\\\.'); // cache the result and return it\n\n  return cache[key] = result;\n}\n/**\n * Convert `string` to a regex string.\n *\n * @param  {String} `str`\n * @param  {String} `prefix` Character that determines how to wrap the string.\n * @param  {Boolean} `esc` If `false` special characters will not be escaped. Defaults to `true`.\n * @return {String}\n */\n\n\nfunction wrap(inner, prefix, esc) {\n  if (esc) inner = escape(inner);\n\n  switch (prefix) {\n    case '!':\n      return '(?!' + inner + ')[^/]' + (esc ? '%%%~' : '*?');\n\n    case '@':\n      return '(?:' + inner + ')';\n\n    case '+':\n      return '(?:' + inner + ')+';\n\n    case '*':\n      return '(?:' + inner + ')' + (esc ? '%%' : '*');\n\n    case '?':\n      return '(?:' + inner + '|)';\n\n    default:\n      return inner;\n  }\n}\n\nfunction escape(str) {\n  str = str.split('*').join('[^/]%%%~');\n  str = str.split('.').join('\\\\.');\n  return str;\n}\n/**\n * extglob regex.\n */\n\n\nfunction regex() {\n  return /(\\\\?[@?!+*$]\\\\?)(\\(([^()]*?)\\))/;\n}\n/**\n * Negation regex\n */\n\n\nfunction negate(str) {\n  return '(?!^' + str + ').*$';\n}\n/**\n * Create the regex to do the matching. If\n * the leading character in the `pattern` is `!`\n * a negation regex is returned.\n *\n * @param {String} `pattern`\n * @param {Boolean} `contains` Allow loose matching.\n * @param {Boolean} `isNegated` True if the pattern is a negation pattern.\n */\n\n\nfunction toRegex(pattern, contains, isNegated) {\n  var prefix = contains ? '^' : '';\n  var after = contains ? '$' : '';\n  pattern = '(?:' + pattern + ')' + after;\n\n  if (isNegated) {\n    pattern = prefix + negate(pattern);\n  }\n\n  return new RegExp(prefix + pattern);\n}","map":{"version":3,"sources":["/home/yanxiaoyang/react-project/PersonalWebsiteTest/node_modules/rijs.resdir/node_modules/extglob/index.js"],"names":["isExtglob","require","re","cache","module","exports","extglob","str","opts","o","i","replace","m","ch","escape","key","String","regex","contains","hasOwnProperty","RegExp","negate","exec","prefix","inner","id","wrap","split","join","keys","Object","len","length","prop","result","toRegex","esc","pattern","isNegated","after"],"mappings":"AAAA;;;;;;AAOA;AAEA;;;;AAIA,IAAIA,SAAS,GAAGC,OAAO,CAAC,YAAD,CAAvB;;AACA,IAAIC,EAAJ;AAAA,IAAQC,KAAK,GAAG,EAAhB;AAEA;;;;AAIAC,MAAM,CAACC,OAAP,GAAiBC,OAAjB;AAEA;;;;;;;;;;;;;;;;;;AAmBA,SAASA,OAAT,CAAiBC,GAAjB,EAAsBC,IAAtB,EAA4B;AAC1BA,EAAAA,IAAI,GAAGA,IAAI,IAAI,EAAf;AACA,MAAIC,CAAC,GAAG,EAAR;AAAA,MAAYC,CAAC,GAAG,CAAhB,CAF0B,CAI1B;AACA;;AACAH,EAAAA,GAAG,GAAGA,GAAG,CAACI,OAAJ,CAAY,gBAAZ,EAA8B,MAA9B,CAAN,CAN0B,CAQ1B;;AACAJ,EAAAA,GAAG,GAAGA,GAAG,CAACI,OAAJ,CAAY,oBAAZ,EAAkC,UAAUC,CAAV,EAAaC,EAAb,EAAiB;AACvD,QAAIA,EAAE,KAAK,GAAX,EAAgB;AACd,aAAOC,MAAM,CAAC,UAAD,CAAb;AACD;;AACD,WAAOA,MAAM,CAAC,OAAD,CAAb;AACD,GALK,CAAN,CAT0B,CAgB1B;AACA;;AACA,MAAIC,GAAG,GAAGR,GAAG,GACTS,MAAM,CAAC,CAAC,CAACR,IAAI,CAACS,KAAR,CADA,GAEND,MAAM,CAAC,CAAC,CAACR,IAAI,CAACU,QAAR,CAFA,GAGNF,MAAM,CAAC,CAAC,CAACR,IAAI,CAACM,MAAR,CAHV;;AAKA,MAAIX,KAAK,CAACgB,cAAN,CAAqBJ,GAArB,CAAJ,EAA+B;AAC7B,WAAOZ,KAAK,CAACY,GAAD,CAAZ;AACD;;AAED,MAAI,EAAEb,EAAE,YAAYkB,MAAhB,CAAJ,EAA6B;AAC3BlB,IAAAA,EAAE,GAAGe,KAAK,EAAV;AACD;;AAEDT,EAAAA,IAAI,CAACa,MAAL,GAAc,KAAd;AACA,MAAIT,CAAJ;;AAEA,SAAOA,CAAC,GAAGV,EAAE,CAACoB,IAAH,CAAQf,GAAR,CAAX,EAAyB;AACvB,QAAIgB,MAAM,GAAGX,CAAC,CAAC,CAAD,CAAd;AACA,QAAIY,KAAK,GAAGZ,CAAC,CAAC,CAAD,CAAb;;AACA,QAAIW,MAAM,KAAK,GAAf,EAAoB;AAClBf,MAAAA,IAAI,CAACa,MAAL,GAAc,IAAd;AACD;;AAED,QAAII,EAAE,GAAG,eAAgBf,CAAC,EAAjB,GAAuB,IAAhC,CAPuB,CAQvB;;AACAD,IAAAA,CAAC,CAACgB,EAAD,CAAD,GAAQC,IAAI,CAACF,KAAD,EAAQD,MAAR,EAAgBf,IAAI,CAACM,MAArB,CAAZ;AACAP,IAAAA,GAAG,GAAGA,GAAG,CAACoB,KAAJ,CAAUf,CAAC,CAAC,CAAD,CAAX,EAAgBgB,IAAhB,CAAqBH,EAArB,CAAN;AACD;;AAED,MAAII,IAAI,GAAGC,MAAM,CAACD,IAAP,CAAYpB,CAAZ,CAAX;AACA,MAAIsB,GAAG,GAAGF,IAAI,CAACG,MAAf,CAhD0B,CAkD1B;AACA;AACA;;AACA,SAAOD,GAAG,EAAV,EAAc;AACZ,QAAIE,IAAI,GAAGJ,IAAI,CAACE,GAAD,CAAf;AACAxB,IAAAA,GAAG,GAAGA,GAAG,CAACoB,KAAJ,CAAUM,IAAV,EAAgBL,IAAhB,CAAqBnB,CAAC,CAACwB,IAAD,CAAtB,CAAN;AACD;;AAED,MAAIC,MAAM,GAAG1B,IAAI,CAACS,KAAL,GACTkB,OAAO,CAAC5B,GAAD,EAAMC,IAAI,CAACU,QAAX,EAAqBV,IAAI,CAACa,MAA1B,CADE,GAETd,GAFJ;AAIA2B,EAAAA,MAAM,GAAGA,MAAM,CAACP,KAAP,CAAa,GAAb,EAAkBC,IAAlB,CAAuB,KAAvB,CAAT,CA9D0B,CAgE1B;;AACA,SAAQzB,KAAK,CAACY,GAAD,CAAL,GAAamB,MAArB;AACD;AAED;;;;;;;;;;AASA,SAASR,IAAT,CAAcF,KAAd,EAAqBD,MAArB,EAA6Ba,GAA7B,EAAkC;AAChC,MAAIA,GAAJ,EAASZ,KAAK,GAAGV,MAAM,CAACU,KAAD,CAAd;;AAET,UAAQD,MAAR;AACE,SAAK,GAAL;AACE,aAAO,QAAQC,KAAR,GAAgB,OAAhB,IAA2BY,GAAG,GAAG,MAAH,GAAY,IAA1C,CAAP;;AACF,SAAK,GAAL;AACE,aAAO,QAAQZ,KAAR,GAAgB,GAAvB;;AACF,SAAK,GAAL;AACE,aAAO,QAAQA,KAAR,GAAgB,IAAvB;;AACF,SAAK,GAAL;AACE,aAAO,QAAQA,KAAR,GAAgB,GAAhB,IAAuBY,GAAG,GAAG,IAAH,GAAU,GAApC,CAAP;;AACF,SAAK,GAAL;AACE,aAAO,QAAQZ,KAAR,GAAgB,IAAvB;;AACF;AACE,aAAOA,KAAP;AAZJ;AAcD;;AAED,SAASV,MAAT,CAAgBP,GAAhB,EAAqB;AACnBA,EAAAA,GAAG,GAAGA,GAAG,CAACoB,KAAJ,CAAU,GAAV,EAAeC,IAAf,CAAoB,UAApB,CAAN;AACArB,EAAAA,GAAG,GAAGA,GAAG,CAACoB,KAAJ,CAAU,GAAV,EAAeC,IAAf,CAAoB,KAApB,CAAN;AACA,SAAOrB,GAAP;AACD;AAED;;;;;AAIA,SAASU,KAAT,GAAiB;AACf,SAAO,iCAAP;AACD;AAED;;;;;AAIA,SAASI,MAAT,CAAgBd,GAAhB,EAAqB;AACnB,SAAO,SAASA,GAAT,GAAe,MAAtB;AACD;AAED;;;;;;;;;;;AAUA,SAAS4B,OAAT,CAAiBE,OAAjB,EAA0BnB,QAA1B,EAAoCoB,SAApC,EAA+C;AAC7C,MAAIf,MAAM,GAAGL,QAAQ,GAAG,GAAH,GAAS,EAA9B;AACA,MAAIqB,KAAK,GAAGrB,QAAQ,GAAG,GAAH,GAAS,EAA7B;AACAmB,EAAAA,OAAO,GAAI,QAAQA,OAAR,GAAkB,GAAlB,GAAwBE,KAAnC;;AACA,MAAID,SAAJ,EAAe;AACbD,IAAAA,OAAO,GAAGd,MAAM,GAAGF,MAAM,CAACgB,OAAD,CAAzB;AACD;;AACD,SAAO,IAAIjB,MAAJ,CAAWG,MAAM,GAAGc,OAApB,CAAP;AACD","sourcesContent":["/*!\n * extglob <https://github.com/jonschlinkert/extglob>\n *\n * Copyright (c) 2015, Jon Schlinkert.\n * Licensed under the MIT License.\n */\n\n'use strict';\n\n/**\n * Module dependencies\n */\n\nvar isExtglob = require('is-extglob');\nvar re, cache = {};\n\n/**\n * Expose `extglob`\n */\n\nmodule.exports = extglob;\n\n/**\n * Convert the given extglob `string` to a regex-compatible\n * string.\n *\n * ```js\n * var extglob = require('extglob');\n * extglob('!(a?(b))');\n * //=> '(?!a(?:b)?)[^/]*?'\n * ```\n *\n * @param {String} `str` The string to convert.\n * @param {Object} `options`\n *   @option {Boolean} [options] `esc` If `false` special characters will not be escaped. Defaults to `true`.\n *   @option {Boolean} [options] `regex` If `true` a regular expression is returned instead of a string.\n * @return {String}\n * @api public\n */\n\n\nfunction extglob(str, opts) {\n  opts = opts || {};\n  var o = {}, i = 0;\n\n  // fix common character reversals\n  // '*!(.js)' => '*.!(js)'\n  str = str.replace(/!\\(([^\\w*()])/g, '$1!(');\n\n  // support file extension negation\n  str = str.replace(/([*\\/])\\.!\\([*]\\)/g, function (m, ch) {\n    if (ch === '/') {\n      return escape('\\\\/[^.]+');\n    }\n    return escape('[^.]+');\n  });\n\n  // create a unique key for caching by\n  // combining the string and options\n  var key = str\n    + String(!!opts.regex)\n    + String(!!opts.contains)\n    + String(!!opts.escape);\n\n  if (cache.hasOwnProperty(key)) {\n    return cache[key];\n  }\n\n  if (!(re instanceof RegExp)) {\n    re = regex();\n  }\n\n  opts.negate = false;\n  var m;\n\n  while (m = re.exec(str)) {\n    var prefix = m[1];\n    var inner = m[3];\n    if (prefix === '!') {\n      opts.negate = true;\n    }\n\n    var id = '__EXTGLOB_' + (i++) + '__';\n    // use the prefix of the _last_ (outtermost) pattern\n    o[id] = wrap(inner, prefix, opts.escape);\n    str = str.split(m[0]).join(id);\n  }\n\n  var keys = Object.keys(o);\n  var len = keys.length;\n\n  // we have to loop again to allow us to convert\n  // patterns in reverse order (starting with the\n  // innermost/last pattern first)\n  while (len--) {\n    var prop = keys[len];\n    str = str.split(prop).join(o[prop]);\n  }\n\n  var result = opts.regex\n    ? toRegex(str, opts.contains, opts.negate)\n    : str;\n\n  result = result.split('.').join('\\\\.');\n\n  // cache the result and return it\n  return (cache[key] = result);\n}\n\n/**\n * Convert `string` to a regex string.\n *\n * @param  {String} `str`\n * @param  {String} `prefix` Character that determines how to wrap the string.\n * @param  {Boolean} `esc` If `false` special characters will not be escaped. Defaults to `true`.\n * @return {String}\n */\n\nfunction wrap(inner, prefix, esc) {\n  if (esc) inner = escape(inner);\n\n  switch (prefix) {\n    case '!':\n      return '(?!' + inner + ')[^/]' + (esc ? '%%%~' : '*?');\n    case '@':\n      return '(?:' + inner + ')';\n    case '+':\n      return '(?:' + inner + ')+';\n    case '*':\n      return '(?:' + inner + ')' + (esc ? '%%' : '*')\n    case '?':\n      return '(?:' + inner + '|)';\n    default:\n      return inner;\n  }\n}\n\nfunction escape(str) {\n  str = str.split('*').join('[^/]%%%~');\n  str = str.split('.').join('\\\\.');\n  return str;\n}\n\n/**\n * extglob regex.\n */\n\nfunction regex() {\n  return /(\\\\?[@?!+*$]\\\\?)(\\(([^()]*?)\\))/;\n}\n\n/**\n * Negation regex\n */\n\nfunction negate(str) {\n  return '(?!^' + str + ').*$';\n}\n\n/**\n * Create the regex to do the matching. If\n * the leading character in the `pattern` is `!`\n * a negation regex is returned.\n *\n * @param {String} `pattern`\n * @param {Boolean} `contains` Allow loose matching.\n * @param {Boolean} `isNegated` True if the pattern is a negation pattern.\n */\n\nfunction toRegex(pattern, contains, isNegated) {\n  var prefix = contains ? '^' : '';\n  var after = contains ? '$' : '';\n  pattern = ('(?:' + pattern + ')' + after);\n  if (isNegated) {\n    pattern = prefix + negate(pattern);\n  }\n  return new RegExp(prefix + pattern);\n}\n"]},"metadata":{},"sourceType":"script"}