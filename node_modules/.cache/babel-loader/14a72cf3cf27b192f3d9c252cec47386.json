{"ast":null,"code":"/*!\n * micromatch <https://github.com/jonschlinkert/micromatch>\n *\n * Copyright (c) 2014-2015, Jon Schlinkert.\n * Licensed under the MIT License.\n */\n'use strict';\n\nvar utils = require('./utils');\n\nvar Glob = require('./glob');\n/**\n * Expose `expand`\n */\n\n\nmodule.exports = expand;\n/**\n * Expand a glob pattern to resolve braces and\n * similar patterns before converting to regex.\n *\n * @param  {String|Array} `pattern`\n * @param  {Array} `files`\n * @param  {Options} `opts`\n * @return {Array}\n */\n\nfunction expand(pattern, options) {\n  if (typeof pattern !== 'string') {\n    throw new TypeError('micromatch.expand(): argument should be a string.');\n  }\n\n  var glob = new Glob(pattern, options || {});\n  var opts = glob.options;\n\n  if (!utils.isGlob(pattern)) {\n    glob.pattern = glob.pattern.replace(/([\\/.])/g, '\\\\$1');\n    return glob;\n  }\n\n  glob.pattern = glob.pattern.replace(/(\\+)(?!\\()/g, '\\\\$1');\n  glob.pattern = glob.pattern.split('$').join('\\\\$');\n\n  if (typeof opts.braces !== 'boolean' && typeof opts.nobraces !== 'boolean') {\n    opts.braces = true;\n  }\n\n  if (glob.pattern === '.*') {\n    return {\n      pattern: '\\\\.' + star,\n      tokens: tok,\n      options: opts\n    };\n  }\n\n  if (glob.pattern === '*') {\n    return {\n      pattern: oneStar(opts.dot),\n      tokens: tok,\n      options: opts\n    };\n  } // parse the glob pattern into tokens\n\n\n  glob.parse();\n  var tok = glob.tokens;\n  tok.is.negated = opts.negated; // dotfile handling\n\n  if ((opts.dotfiles === true || tok.is.dotfile) && opts.dot !== false) {\n    opts.dotfiles = true;\n    opts.dot = true;\n  }\n\n  if ((opts.dotdirs === true || tok.is.dotdir) && opts.dot !== false) {\n    opts.dotdirs = true;\n    opts.dot = true;\n  } // check for braces with a dotfile pattern\n\n\n  if (/[{,]\\./.test(glob.pattern)) {\n    opts.makeRe = false;\n    opts.dot = true;\n  }\n\n  if (opts.nonegate !== true) {\n    opts.negated = glob.negated;\n  } // if the leading character is a dot or a slash, escape it\n\n\n  if (glob.pattern.charAt(0) === '.' && glob.pattern.charAt(1) !== '/') {\n    glob.pattern = '\\\\' + glob.pattern;\n  }\n  /**\n   * Extended globs\n   */\n  // expand braces, e.g `{1..5}`\n\n\n  glob.track('before braces');\n\n  if (tok.is.braces) {\n    glob.braces();\n  }\n\n  glob.track('after braces'); // expand extglobs, e.g `foo/!(a|b)`\n\n  glob.track('before extglob');\n\n  if (tok.is.extglob) {\n    glob.extglob();\n  }\n\n  glob.track('after extglob'); // expand brackets, e.g `[[:alpha:]]`\n\n  glob.track('before brackets');\n\n  if (tok.is.brackets) {\n    glob.brackets();\n  }\n\n  glob.track('after brackets'); // special patterns\n\n  glob._replace('[!', '[^');\n\n  glob._replace('(?', '(%~');\n\n  glob._replace(/\\[\\]/, '\\\\[\\\\]');\n\n  glob._replace('/[', '/' + (opts.dot ? dotfiles : nodot) + '[', true);\n\n  glob._replace('/?', '/' + (opts.dot ? dotfiles : nodot) + '[^/]', true);\n\n  glob._replace('/.', '/(?=.)\\\\.', true); // windows drives\n\n\n  glob._replace(/^(\\w):([\\\\\\/]+?)/gi, '(?=.)$1:$2', true); // negate slashes in exclusion ranges\n\n\n  if (glob.pattern.indexOf('[^') !== -1) {\n    glob.pattern = negateSlash(glob.pattern);\n  }\n\n  if (opts.globstar !== false && glob.pattern === '**') {\n    glob.pattern = globstar(opts.dot);\n  } else {\n    glob.pattern = balance(glob.pattern, '[', ']');\n    glob.escape(glob.pattern); // if the pattern has `**`\n\n    if (tok.is.globstar) {\n      glob.pattern = collapse(glob.pattern, '/**');\n      glob.pattern = collapse(glob.pattern, '**/');\n\n      glob._replace('/**/', '(?:/' + globstar(opts.dot) + '/|/)', true);\n\n      glob._replace(/\\*{2,}/g, '**'); // 'foo/*'\n\n\n      glob._replace(/(\\w+)\\*(?!\\/)/g, '$1[^/]*?', true);\n\n      glob._replace(/\\*\\*\\/\\*(\\w)/g, globstar(opts.dot) + '\\\\/' + (opts.dot ? dotfiles : nodot) + '[^/]*?$1', true);\n\n      if (opts.dot !== true) {\n        glob._replace(/\\*\\*\\/(.)/g, '(?:**\\\\/|)$1');\n      } // 'foo/**' or '{**,*}', but not 'foo**'\n\n\n      if (tok.path.dirname !== '' || /,\\*\\*|\\*\\*,/.test(glob.orig)) {\n        glob._replace('**', globstar(opts.dot), true);\n      }\n    } // ends with /*\n\n\n    glob._replace(/\\/\\*$/, '\\\\/' + oneStar(opts.dot), true); // ends with *, no slashes\n\n\n    glob._replace(/(?!\\/)\\*$/, star, true); // has 'n*.' (partial wildcard w/ file extension)\n\n\n    glob._replace(/([^\\/]+)\\*/, '$1' + oneStar(true), true); // has '*'\n\n\n    glob._replace('*', oneStar(opts.dot), true);\n\n    glob._replace('?.', '?\\\\.', true);\n\n    glob._replace('?:', '?:', true);\n\n    glob._replace(/\\?+/g, function (match) {\n      var len = match.length;\n\n      if (len === 1) {\n        return qmark;\n      }\n\n      return qmark + '{' + len + '}';\n    }); // escape '.abc' => '\\\\.abc'\n\n\n    glob._replace(/\\.([*\\w]+)/g, '\\\\.$1'); // fix '[^\\\\\\\\/]'\n\n\n    glob._replace(/\\[\\^[\\\\\\/]+\\]/g, qmark); // '///' => '\\/'\n\n\n    glob._replace(/\\/+/g, '\\\\/'); // '\\\\\\\\\\\\' => '\\\\'\n\n\n    glob._replace(/\\\\{2,}/g, '\\\\');\n  } // unescape previously escaped patterns\n\n\n  glob.unescape(glob.pattern);\n\n  glob._replace('__UNESC_STAR__', '*'); // escape dots that follow qmarks\n\n\n  glob._replace('?.', '?\\\\.'); // remove unnecessary slashes in character classes\n\n\n  glob._replace('[^\\\\/]', qmark);\n\n  if (glob.pattern.length > 1) {\n    if (/^[\\[?*]/.test(glob.pattern)) {\n      // only prepend the string if we don't want to match dotfiles\n      glob.pattern = (opts.dot ? dotfiles : nodot) + glob.pattern;\n    }\n  }\n\n  return glob;\n}\n/**\n * Collapse repeated character sequences.\n *\n * ```js\n * collapse('a/../../../b', '../');\n * //=> 'a/../b'\n * ```\n *\n * @param  {String} `str`\n * @param  {String} `ch` Character sequence to collapse\n * @return {String}\n */\n\n\nfunction collapse(str, ch) {\n  var res = str.split(ch);\n  var isFirst = res[0] === '';\n  var isLast = res[res.length - 1] === '';\n  res = res.filter(Boolean);\n  if (isFirst) res.unshift('');\n  if (isLast) res.push('');\n  return res.join(ch);\n}\n/**\n * Negate slashes in exclusion ranges, per glob spec:\n *\n * ```js\n * negateSlash('[^foo]');\n * //=> '[^\\\\/foo]'\n * ```\n *\n * @param  {String} `str` glob pattern\n * @return {String}\n */\n\n\nfunction negateSlash(str) {\n  return str.replace(/\\[\\^([^\\]]*?)\\]/g, function (match, inner) {\n    if (inner.indexOf('/') === -1) {\n      inner = '\\\\/' + inner;\n    }\n\n    return '[^' + inner + ']';\n  });\n}\n/**\n * Escape imbalanced braces/bracket. This is a very\n * basic, naive implementation that only does enough\n * to serve the purpose.\n */\n\n\nfunction balance(str, a, b) {\n  var aarr = str.split(a);\n  var alen = aarr.join('').length;\n  var blen = str.split(b).join('').length;\n\n  if (alen !== blen) {\n    str = aarr.join('\\\\' + a);\n    return str.split(b).join('\\\\' + b);\n  }\n\n  return str;\n}\n/**\n * Special patterns to be converted to regex.\n * Heuristics are used to simplify patterns\n * and speed up processing.\n */\n\n/* eslint no-multi-spaces: 0 */\n\n\nvar qmark = '[^/]';\nvar star = qmark + '*?';\nvar nodot = '(?!\\\\.)(?=.)';\nvar dotfileGlob = '(?:\\\\/|^)\\\\.{1,2}($|\\\\/)';\nvar dotfiles = '(?!' + dotfileGlob + ')(?=.)';\nvar twoStarDot = '(?:(?!' + dotfileGlob + ').)*?';\n/**\n * Create a regex for `*`.\n *\n * If `dot` is true, or the pattern does not begin with\n * a leading star, then return the simpler regex.\n */\n\nfunction oneStar(dotfile) {\n  return dotfile ? '(?!' + dotfileGlob + ')(?=.)' + star : nodot + star;\n}\n\nfunction globstar(dotfile) {\n  if (dotfile) {\n    return twoStarDot;\n  }\n\n  return '(?:(?!(?:\\\\/|^)\\\\.).)*?';\n}","map":{"version":3,"sources":["/home/yanxiaoyang/react-project/PersonalWebsiteTest/node_modules/rijs.resdir/node_modules/micromatch/lib/expand.js"],"names":["utils","require","Glob","module","exports","expand","pattern","options","TypeError","glob","opts","isGlob","replace","split","join","braces","nobraces","star","tokens","tok","oneStar","dot","parse","is","negated","dotfiles","dotfile","dotdirs","dotdir","test","makeRe","nonegate","charAt","track","extglob","brackets","_replace","nodot","indexOf","negateSlash","globstar","balance","escape","collapse","path","dirname","orig","match","len","length","qmark","unescape","str","ch","res","isFirst","isLast","filter","Boolean","unshift","push","inner","a","b","aarr","alen","blen","dotfileGlob","twoStarDot"],"mappings":"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","sourcesContent":["/*!\n * micromatch <https://github.com/jonschlinkert/micromatch>\n *\n * Copyright (c) 2014-2015, Jon Schlinkert.\n * Licensed under the MIT License.\n */\n\n'use strict';\n\nvar utils = require('./utils');\nvar Glob = require('./glob');\n\n/**\n * Expose `expand`\n */\n\nmodule.exports = expand;\n\n/**\n * Expand a glob pattern to resolve braces and\n * similar patterns before converting to regex.\n *\n * @param  {String|Array} `pattern`\n * @param  {Array} `files`\n * @param  {Options} `opts`\n * @return {Array}\n */\n\nfunction expand(pattern, options) {\n  if (typeof pattern !== 'string') {\n    throw new TypeError('micromatch.expand(): argument should be a string.');\n  }\n\n  var glob = new Glob(pattern, options || {});\n  var opts = glob.options;\n\n  if (!utils.isGlob(pattern)) {\n    glob.pattern = glob.pattern.replace(/([\\/.])/g, '\\\\$1');\n    return glob;\n  }\n\n  glob.pattern = glob.pattern.replace(/(\\+)(?!\\()/g, '\\\\$1');\n  glob.pattern = glob.pattern.split('$').join('\\\\$');\n\n  if (typeof opts.braces !== 'boolean' && typeof opts.nobraces !== 'boolean') {\n    opts.braces = true;\n  }\n\n  if (glob.pattern === '.*') {\n    return {\n      pattern: '\\\\.' + star,\n      tokens: tok,\n      options: opts\n    };\n  }\n\n  if (glob.pattern === '*') {\n    return {\n      pattern: oneStar(opts.dot),\n      tokens: tok,\n      options: opts\n    };\n  }\n\n  // parse the glob pattern into tokens\n  glob.parse();\n  var tok = glob.tokens;\n  tok.is.negated = opts.negated;\n\n  // dotfile handling\n  if ((opts.dotfiles === true || tok.is.dotfile) && opts.dot !== false) {\n    opts.dotfiles = true;\n    opts.dot = true;\n  }\n\n  if ((opts.dotdirs === true || tok.is.dotdir) && opts.dot !== false) {\n    opts.dotdirs = true;\n    opts.dot = true;\n  }\n\n  // check for braces with a dotfile pattern\n  if (/[{,]\\./.test(glob.pattern)) {\n    opts.makeRe = false;\n    opts.dot = true;\n  }\n\n  if (opts.nonegate !== true) {\n    opts.negated = glob.negated;\n  }\n\n  // if the leading character is a dot or a slash, escape it\n  if (glob.pattern.charAt(0) === '.' && glob.pattern.charAt(1) !== '/') {\n    glob.pattern = '\\\\' + glob.pattern;\n  }\n\n  /**\n   * Extended globs\n   */\n\n  // expand braces, e.g `{1..5}`\n  glob.track('before braces');\n  if (tok.is.braces) {\n    glob.braces();\n  }\n  glob.track('after braces');\n\n  // expand extglobs, e.g `foo/!(a|b)`\n  glob.track('before extglob');\n  if (tok.is.extglob) {\n    glob.extglob();\n  }\n  glob.track('after extglob');\n\n  // expand brackets, e.g `[[:alpha:]]`\n  glob.track('before brackets');\n  if (tok.is.brackets) {\n    glob.brackets();\n  }\n  glob.track('after brackets');\n\n  // special patterns\n  glob._replace('[!', '[^');\n  glob._replace('(?', '(%~');\n  glob._replace(/\\[\\]/, '\\\\[\\\\]');\n  glob._replace('/[', '/' + (opts.dot ? dotfiles : nodot) + '[', true);\n  glob._replace('/?', '/' + (opts.dot ? dotfiles : nodot) + '[^/]', true);\n  glob._replace('/.', '/(?=.)\\\\.', true);\n\n  // windows drives\n  glob._replace(/^(\\w):([\\\\\\/]+?)/gi, '(?=.)$1:$2', true);\n\n  // negate slashes in exclusion ranges\n  if (glob.pattern.indexOf('[^') !== -1) {\n    glob.pattern = negateSlash(glob.pattern);\n  }\n\n  if (opts.globstar !== false && glob.pattern === '**') {\n    glob.pattern = globstar(opts.dot);\n\n  } else {\n    glob.pattern = balance(glob.pattern, '[', ']');\n    glob.escape(glob.pattern);\n\n    // if the pattern has `**`\n    if (tok.is.globstar) {\n      glob.pattern = collapse(glob.pattern, '/**');\n      glob.pattern = collapse(glob.pattern, '**/');\n      glob._replace('/**/', '(?:/' + globstar(opts.dot) + '/|/)', true);\n      glob._replace(/\\*{2,}/g, '**');\n\n      // 'foo/*'\n      glob._replace(/(\\w+)\\*(?!\\/)/g, '$1[^/]*?', true);\n      glob._replace(/\\*\\*\\/\\*(\\w)/g, globstar(opts.dot) + '\\\\/' + (opts.dot ? dotfiles : nodot) + '[^/]*?$1', true);\n\n      if (opts.dot !== true) {\n        glob._replace(/\\*\\*\\/(.)/g, '(?:**\\\\/|)$1');\n      }\n\n      // 'foo/**' or '{**,*}', but not 'foo**'\n      if (tok.path.dirname !== '' || /,\\*\\*|\\*\\*,/.test(glob.orig)) {\n        glob._replace('**', globstar(opts.dot), true);\n      }\n    }\n\n    // ends with /*\n    glob._replace(/\\/\\*$/, '\\\\/' + oneStar(opts.dot), true);\n    // ends with *, no slashes\n    glob._replace(/(?!\\/)\\*$/, star, true);\n    // has 'n*.' (partial wildcard w/ file extension)\n    glob._replace(/([^\\/]+)\\*/, '$1' + oneStar(true), true);\n    // has '*'\n    glob._replace('*', oneStar(opts.dot), true);\n    glob._replace('?.', '?\\\\.', true);\n    glob._replace('?:', '?:', true);\n\n    glob._replace(/\\?+/g, function(match) {\n      var len = match.length;\n      if (len === 1) {\n        return qmark;\n      }\n      return qmark + '{' + len + '}';\n    });\n\n    // escape '.abc' => '\\\\.abc'\n    glob._replace(/\\.([*\\w]+)/g, '\\\\.$1');\n    // fix '[^\\\\\\\\/]'\n    glob._replace(/\\[\\^[\\\\\\/]+\\]/g, qmark);\n    // '///' => '\\/'\n    glob._replace(/\\/+/g, '\\\\/');\n    // '\\\\\\\\\\\\' => '\\\\'\n    glob._replace(/\\\\{2,}/g, '\\\\');\n  }\n\n  // unescape previously escaped patterns\n  glob.unescape(glob.pattern);\n  glob._replace('__UNESC_STAR__', '*');\n\n  // escape dots that follow qmarks\n  glob._replace('?.', '?\\\\.');\n\n  // remove unnecessary slashes in character classes\n  glob._replace('[^\\\\/]', qmark);\n\n  if (glob.pattern.length > 1) {\n    if (/^[\\[?*]/.test(glob.pattern)) {\n      // only prepend the string if we don't want to match dotfiles\n      glob.pattern = (opts.dot ? dotfiles : nodot) + glob.pattern;\n    }\n  }\n\n  return glob;\n}\n\n/**\n * Collapse repeated character sequences.\n *\n * ```js\n * collapse('a/../../../b', '../');\n * //=> 'a/../b'\n * ```\n *\n * @param  {String} `str`\n * @param  {String} `ch` Character sequence to collapse\n * @return {String}\n */\n\nfunction collapse(str, ch) {\n  var res = str.split(ch);\n  var isFirst = res[0] === '';\n  var isLast = res[res.length - 1] === '';\n  res = res.filter(Boolean);\n  if (isFirst) res.unshift('');\n  if (isLast) res.push('');\n  return res.join(ch);\n}\n\n/**\n * Negate slashes in exclusion ranges, per glob spec:\n *\n * ```js\n * negateSlash('[^foo]');\n * //=> '[^\\\\/foo]'\n * ```\n *\n * @param  {String} `str` glob pattern\n * @return {String}\n */\n\nfunction negateSlash(str) {\n  return str.replace(/\\[\\^([^\\]]*?)\\]/g, function(match, inner) {\n    if (inner.indexOf('/') === -1) {\n      inner = '\\\\/' + inner;\n    }\n    return '[^' + inner + ']';\n  });\n}\n\n/**\n * Escape imbalanced braces/bracket. This is a very\n * basic, naive implementation that only does enough\n * to serve the purpose.\n */\n\nfunction balance(str, a, b) {\n  var aarr = str.split(a);\n  var alen = aarr.join('').length;\n  var blen = str.split(b).join('').length;\n\n  if (alen !== blen) {\n    str = aarr.join('\\\\' + a);\n    return str.split(b).join('\\\\' + b);\n  }\n  return str;\n}\n\n/**\n * Special patterns to be converted to regex.\n * Heuristics are used to simplify patterns\n * and speed up processing.\n */\n\n/* eslint no-multi-spaces: 0 */\nvar qmark       = '[^/]';\nvar star        = qmark + '*?';\nvar nodot       = '(?!\\\\.)(?=.)';\nvar dotfileGlob = '(?:\\\\/|^)\\\\.{1,2}($|\\\\/)';\nvar dotfiles    = '(?!' + dotfileGlob + ')(?=.)';\nvar twoStarDot  = '(?:(?!' + dotfileGlob + ').)*?';\n\n/**\n * Create a regex for `*`.\n *\n * If `dot` is true, or the pattern does not begin with\n * a leading star, then return the simpler regex.\n */\n\nfunction oneStar(dotfile) {\n  return dotfile ? '(?!' + dotfileGlob + ')(?=.)' + star : (nodot + star);\n}\n\nfunction globstar(dotfile) {\n  if (dotfile) { return twoStarDot; }\n  return '(?:(?!(?:\\\\/|^)\\\\.).)*?';\n}\n"]},"metadata":{},"sourceType":"script"}