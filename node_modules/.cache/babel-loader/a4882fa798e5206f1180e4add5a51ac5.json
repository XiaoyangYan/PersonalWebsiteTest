{"ast":null,"code":"var __slice = Array.prototype.slice,\n    Q = require('q'),\n    _ = require('lodash'),\n    EventEmitter = require('events').EventEmitter,\n    slice = Array.prototype.slice.call.bind(Array.prototype.slice),\n    utils = require('./utils'); // The method below returns no result, so we are able hijack the result to\n// preserve the element scope.\n// This alows for thing like: field.click().clear().input('hello').getValue()\n\n\nvar elementChainableMethods = ['clear', 'click', 'doubleClick', 'doubleclick', 'flick', 'tap', 'sendKeys', 'submit', 'type', 'keys', 'moveTo', 'sleep', 'noop']; // gets the list of methods to be promisified.\n\nfunction filterPromisedMethods(Obj) {\n  return _(Obj).functionsIn().filter(function (fname) {\n    return !fname.match('^newElement$|^toJSON$|^toString$|^_') && !EventEmitter.prototype[fname];\n  }).value();\n}\n\nmodule.exports = function (WebDriver, Element, chainable) {\n  // wraps element + browser call in an enriched promise.\n  // This is the same as in the first promise version, but enrichment +\n  // event logging were added.\n  function wrap(fn, fname) {\n    return function () {\n      var _this = this;\n\n      var callback;\n      var args = slice(arguments);\n      var deferred = Q.defer();\n      deferred.promise.then(function () {\n        _this.emit(\"promise\", _this, fname, args, \"finished\");\n      }); // Remove any undefined values from the end of the arguments array\n      // as these interfere with our callback detection below\n\n      for (var i = args.length - 1; i >= 0 && args[i] === undefined; i--) {\n        args.pop();\n      } // If the last argument is a function assume that it's a callback\n      // (Based on the API as of 2012/12/1 this assumption is always correct)\n\n\n      if (typeof args[args.length - 1] === 'function') {\n        // Remove to replace it with our callback and then call it\n        // appropriately when the promise is resolved or rejected\n        callback = args.pop();\n        deferred.promise.then(function (value) {\n          callback(null, value);\n        }, function (error) {\n          callback(error);\n        });\n      }\n\n      args.push(deferred.makeNodeResolver());\n\n      _this.emit(\"promise\", _this, fname, args, \"calling\");\n\n      fn.apply(this, args);\n\n      if (chainable) {\n        return this._enrich(deferred.promise);\n      } else {\n        return deferred.promise;\n      }\n    };\n  } // Element replacement.\n\n\n  var PromiseElement = function () {\n    var args = 1 <= arguments.length ? __slice.call(arguments, 0) : [];\n    return Element.apply(this, args);\n  };\n\n  PromiseElement.prototype = Object.create(Element.prototype);\n  PromiseElement.prototype.isPromised = true; // WebDriver replacement.\n\n  var PromiseWebdriver = function () {\n    var args = 1 <= arguments.length ? __slice.call(arguments, 0) : [];\n    return WebDriver.apply(this, args);\n  };\n\n  PromiseWebdriver.prototype = Object.create(WebDriver.prototype);\n  PromiseWebdriver.prototype.isPromised = true;\n  PromiseWebdriver.prototype.defaultChainingScope = 'browser';\n\n  PromiseWebdriver.prototype.getDefaultChainingScope = function () {\n    return this.defaultChainingScope;\n  }; // wrapping browser methods with promises.\n\n\n  _(filterPromisedMethods(WebDriver.prototype)).each(function (fname) {\n    PromiseWebdriver.prototype[fname] = wrap(WebDriver.prototype[fname], fname);\n  }); // wrapping element methods with promises.\n\n\n  _(filterPromisedMethods(Element.prototype)).each(function (fname) {\n    PromiseElement.prototype[fname] = wrap(Element.prototype[fname], fname);\n  });\n\n  PromiseWebdriver.prototype.newElement = function (jsonWireElement) {\n    return new PromiseElement(jsonWireElement, this);\n  }; // enriches a promise with the browser + element methods.\n\n\n  PromiseWebdriver.prototype._enrich = function (obj, currentEl) {\n    var _this = this; // There are cases were enrich may be called on non-promise objects.\n    // It is easier and safer to check within the method.\n\n\n    if (utils.isPromise(obj) && !obj.__wd_promise_enriched) {\n      var promise = obj; // __wd_promise_enriched is there to avoid enriching twice.\n\n      promise.__wd_promise_enriched = true; // making sure all the sub-promises are also enriched.\n\n      _(promise).functionsIn() // promiseDispatch is used a lot, and we know it doesn't need to be enriched\n      .filter(function (fname) {\n        return fname !== 'promiseDispatch';\n      }).each(function (fname) {\n        var _orig = promise[fname];\n\n        promise[fname] = function () {\n          var subobj = _orig.apply(this, __slice.call(arguments, 0));\n\n          return this._enrich(subobj, currentEl);\n        };\n      }); // we get the list of methods dynamically.\n\n\n      var promisedMethods = filterPromisedMethods(Object.getPrototypeOf(_this));\n      _this.sampleElement = _this.sampleElement || _this.newElement(1);\n      var elementPromisedMethods = filterPromisedMethods(Object.getPrototypeOf(_this.sampleElement));\n\n      var allPromisedMethods = _.union(promisedMethods, elementPromisedMethods); // adding browser + element methods to the current promise.\n\n\n      _(allPromisedMethods).each(function (fname) {\n        promise[fname] = function () {\n          var args = __slice.call(arguments, 0); // This is a hint to figure out if we need to call a browser method or\n          // an element method.\n          // \"<\" --> browser method\n          // \">\" --> element method\n\n\n          var scopeHint;\n\n          if (args && args[0] && typeof args[0] === 'string' && args[0].match(/^[<>]$/)) {\n            scopeHint = args[0];\n            args = _.drop(args);\n          }\n\n          return this.then(function (res) {\n            var el; // if the result is an element it has priority\n\n            if (Element && res instanceof Element) {\n              el = res;\n            } // if we are within an element\n\n\n            el = el || currentEl; // testing the water for the next call scope\n\n            var isBrowserMethod = _.indexOf(promisedMethods, fname) >= 0;\n            var isElementMethod = el && _.indexOf(elementPromisedMethods, fname) >= 0;\n\n            if (!isBrowserMethod && !isElementMethod) {\n              // doesn't look good\n              throw new Error(\"Invalid method \" + fname);\n            }\n\n            if (isBrowserMethod && isElementMethod) {\n              // we need to resolve the conflict.\n              if (scopeHint === '<') {\n                isElementMethod = false;\n              } else if (scopeHint === '>') {\n                isBrowserMethod = false;\n              } else if (fname.match(/element/) || Element && args[0] instanceof Element) {\n                // method with element locators are browser scoped by default.\n                if (_this.defaultChainingScope === 'element') {\n                  isBrowserMethod = false;\n                } else {\n                  isElementMethod = false;\n                } // default\n\n              } else if (Element && args[0] instanceof Element) {\n                // When an element is passed, we are in the global scope.\n                isElementMethod = false;\n              } else {\n                // otherwise we stay in the element scope to allow sequential calls\n                isBrowserMethod = false;\n              }\n            }\n\n            if (isElementMethod) {\n              // element method case.\n              return el[fname].apply(el, args).then(function (res) {\n                if (_.indexOf(elementChainableMethods, fname) >= 0) {\n                  // method like click, where no result is expected, we return\n                  // the element to make it chainable\n                  return el;\n                } else {\n                  return res; // we have no choice but loosing the scope\n                }\n              });\n            } else {\n              // browser case.\n              return _this[fname].apply(_this, args);\n            }\n          });\n        };\n      }); // transfering _enrich\n\n\n      promise._enrich = function (target) {\n        return _this._enrich(target, currentEl);\n      }; // gets the element at index (starting at 0)\n\n\n      promise.at = function (i) {\n        return _this._enrich(promise.then(function (vals) {\n          return vals[i];\n        }), currentEl);\n      }; // gets the element at index (starting at 0)\n\n\n      promise.last = function () {\n        return promise.then(function (vals) {\n          return vals[vals.length - 1];\n        });\n      }; // gets nth element (starting at 1)\n\n\n      promise.nth = function (i) {\n        return promise.at(i - 1);\n      }; // gets the first element\n\n\n      promise.first = function () {\n        return promise.nth(1);\n      }; // gets the first element\n\n\n      promise.second = function () {\n        return promise.nth(2);\n      }; // gets the first element\n\n\n      promise.third = function () {\n        return promise.nth(3);\n      }; // print error\n\n\n      promise.printError = function (prepend) {\n        prepend = prepend || \"\";\n        return _this._enrich(promise.catch(function (err) {\n          console.log(prepend + err); // eslint-disable-line no-console\n\n          throw err;\n        }), currentEl);\n      }; // print\n\n\n      promise.print = function (prepend) {\n        prepend = prepend || \"\";\n        return _this._enrich(promise.then(function (val) {\n          console.log(prepend + val); // eslint-disable-line no-console\n        }), currentEl);\n      };\n    }\n\n    return obj;\n  };\n  /**\n   * Starts the chain (promised driver only)\n   * browser.chain()\n   * element.chain()\n   */\n\n\n  PromiseWebdriver.prototype.chain = PromiseWebdriver.prototype.noop;\n  PromiseElement.prototype.chain = PromiseElement.prototype.noop;\n  /**\n   * Resolves the promise (promised driver only)\n   * browser.resolve(promise)\n   * element.resolve(promise)\n   */\n\n  PromiseWebdriver.prototype.resolve = function (promise) {\n    var qPromise = new Q(promise);\n\n    this._enrich(qPromise);\n\n    return qPromise;\n  };\n\n  PromiseElement.prototype.resolve = function (promise) {\n    var qPromise = new Q(promise);\n\n    this._enrich(qPromise);\n\n    return qPromise;\n  }; // used to by chai-as-promised and custom methods\n\n\n  PromiseElement.prototype._enrich = function (target) {\n    if (chainable) {\n      return this.browser._enrich(target, this);\n    }\n  }; // used to wrap custom methods\n\n\n  PromiseWebdriver._wrapAsync = wrap; // helper to allow easier promise debugging.\n\n  PromiseWebdriver.prototype._debugPromise = function () {\n    this.on('promise', function (context, method, args, status) {\n      args = _.clone(args);\n\n      if (context instanceof PromiseWebdriver) {\n        context = '';\n      } else {\n        context = ' [element ' + context.value + ']';\n      }\n\n      if (typeof _.last(args) === 'function') {\n        args.pop();\n      }\n\n      args = ' ( ' + _(args).map(function (arg) {\n        if (arg instanceof Element) {\n          return arg.toString();\n        } else if (typeof arg === 'object') {\n          return JSON.stringify(arg);\n        } else {\n          return arg;\n        }\n      }).join(', ') + ' )';\n      console.log(' --> ' + status + context + \" \" + method + args); // eslint-disable-line no-console\n    });\n  };\n\n  return {\n    PromiseWebdriver: PromiseWebdriver,\n    PromiseElement: PromiseElement\n  };\n};","map":{"version":3,"sources":["/home/yanxiaoyang/react-project/PersonalWebsiteTest/node_modules/wd/lib/promise-webdriver.js"],"names":["__slice","Array","prototype","slice","Q","require","_","EventEmitter","call","bind","utils","elementChainableMethods","filterPromisedMethods","Obj","functionsIn","filter","fname","match","value","module","exports","WebDriver","Element","chainable","wrap","fn","_this","callback","args","arguments","deferred","defer","promise","then","emit","i","length","undefined","pop","error","push","makeNodeResolver","apply","_enrich","PromiseElement","Object","create","isPromised","PromiseWebdriver","defaultChainingScope","getDefaultChainingScope","each","newElement","jsonWireElement","obj","currentEl","isPromise","__wd_promise_enriched","_orig","subobj","promisedMethods","getPrototypeOf","sampleElement","elementPromisedMethods","allPromisedMethods","union","scopeHint","drop","res","el","isBrowserMethod","indexOf","isElementMethod","Error","target","at","vals","last","nth","first","second","third","printError","prepend","catch","err","console","log","print","val","chain","noop","resolve","qPromise","browser","_wrapAsync","_debugPromise","on","context","method","status","clone","map","arg","toString","JSON","stringify","join"],"mappings":"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","sourcesContent":["var __slice = Array.prototype.slice,\n    Q = require('q'),\n    _ = require('lodash'),\n    EventEmitter = require('events').EventEmitter,\n    slice = Array.prototype.slice.call.bind(Array.prototype.slice),\n    utils = require('./utils');\n\n// The method below returns no result, so we are able hijack the result to\n// preserve the element scope.\n// This alows for thing like: field.click().clear().input('hello').getValue()\nvar elementChainableMethods = ['clear','click','doubleClick','doubleclick',\n  'flick','tap','sendKeys','submit','type','keys','moveTo','sleep','noop'];\n\n// gets the list of methods to be promisified.\nfunction filterPromisedMethods(Obj) {\n  return _(Obj).functionsIn().filter(function(fname) {\n    return  !fname.match('^newElement$|^toJSON$|^toString$|^_') &&\n            !EventEmitter.prototype[fname];\n  }).value();\n}\n\nmodule.exports = function(WebDriver, Element, chainable) {\n\n  // wraps element + browser call in an enriched promise.\n  // This is the same as in the first promise version, but enrichment +\n  // event logging were added.\n  function wrap(fn, fname) {\n    return function() {\n      var _this = this;\n      var callback;\n      var args = slice(arguments);\n      var deferred = Q.defer();\n      deferred.promise.then(function() {\n        _this.emit(\"promise\", _this, fname , args , \"finished\");\n      });\n\n\n      // Remove any undefined values from the end of the arguments array\n      // as these interfere with our callback detection below\n      for (var i = args.length - 1; i >= 0 && args[i] === undefined; i--) {\n        args.pop();\n      }\n\n      // If the last argument is a function assume that it's a callback\n      // (Based on the API as of 2012/12/1 this assumption is always correct)\n      if(typeof args[args.length - 1] === 'function')\n      {\n        // Remove to replace it with our callback and then call it\n        // appropriately when the promise is resolved or rejected\n        callback = args.pop();\n        deferred.promise.then(function(value) {\n          callback(null, value);\n        }, function(error) {\n          callback(error);\n        });\n      }\n\n      args.push(deferred.makeNodeResolver());\n      _this.emit(\"promise\", _this, fname , args , \"calling\");\n      fn.apply(this, args);\n\n      if(chainable) {\n        return this._enrich(deferred.promise);\n      } else {\n        return deferred.promise;\n      }\n    };\n  }\n\n  // Element replacement.\n  var PromiseElement = function() {\n    var args = 1 <= arguments.length ? __slice.call(arguments, 0) : [];\n    return Element.apply(this, args);\n  };\n  PromiseElement.prototype = Object.create(Element.prototype);\n  PromiseElement.prototype.isPromised = true;\n\n  // WebDriver replacement.\n  var PromiseWebdriver = function() {\n    var args = 1 <= arguments.length ? __slice.call(arguments, 0) : [];\n    return WebDriver.apply(this, args);\n  };\n  PromiseWebdriver.prototype = Object.create(WebDriver.prototype);\n  PromiseWebdriver.prototype.isPromised = true;\n  PromiseWebdriver.prototype.defaultChainingScope = 'browser';\n\n  PromiseWebdriver.prototype.getDefaultChainingScope = function() {\n    return this.defaultChainingScope;\n  };\n\n\n  // wrapping browser methods with promises.\n  _(filterPromisedMethods(WebDriver.prototype)).each(function(fname) {\n    PromiseWebdriver.prototype[fname] = wrap(WebDriver.prototype[fname], fname);\n  });\n\n  // wrapping element methods with promises.\n  _(filterPromisedMethods(Element.prototype)).each(function(fname) {\n    PromiseElement.prototype[fname] = wrap(Element.prototype[fname], fname);\n  });\n\n  PromiseWebdriver.prototype.newElement = function(jsonWireElement) {\n    return new PromiseElement(jsonWireElement, this);\n  };\n\n  // enriches a promise with the browser + element methods.\n  PromiseWebdriver.prototype._enrich = function(obj, currentEl) {\n    var _this = this;\n    // There are cases were enrich may be called on non-promise objects.\n    // It is easier and safer to check within the method.\n    if (utils.isPromise(obj) && !obj.__wd_promise_enriched) {\n\n      var promise = obj;\n\n      // __wd_promise_enriched is there to avoid enriching twice.\n      promise.__wd_promise_enriched = true;\n\n\n      // making sure all the sub-promises are also enriched.\n\n      _(promise).functionsIn()\n        // promiseDispatch is used a lot, and we know it doesn't need to be enriched\n        .filter(function(fname) { return fname !== 'promiseDispatch'; })\n        .each(function(fname) {\n          var _orig = promise[fname];\n          promise[fname] = function() {\n            var subobj = _orig.apply(this, __slice.call(arguments, 0));\n\n            return this._enrich(\n              subobj, currentEl);\n          };\n        });\n\n      // we get the list of methods dynamically.\n      var promisedMethods = filterPromisedMethods(Object.getPrototypeOf(_this));\n      _this.sampleElement = _this.sampleElement || _this.newElement(1);\n      var elementPromisedMethods = filterPromisedMethods(Object.getPrototypeOf(_this.sampleElement));\n      var allPromisedMethods = _.union(promisedMethods, elementPromisedMethods);\n\n      // adding browser + element methods to the current promise.\n      _(allPromisedMethods).each(function(fname) {\n        promise[fname] = function() {\n          var args = __slice.call(arguments, 0);\n          // This is a hint to figure out if we need to call a browser method or\n          // an element method.\n          // \"<\" --> browser method\n          // \">\" --> element method\n          var scopeHint;\n          if(args && args[0] && typeof args[0] === 'string' && args[0].match(/^[<>]$/)) {\n            scopeHint = args[0];\n            args = _.drop(args);\n          }\n\n          return this.then(function(res) {\n            var el;\n            // if the result is an element it has priority\n            if(Element && res instanceof Element) {\n              el = res; }\n            // if we are within an element\n            el = el || currentEl;\n\n            // testing the water for the next call scope\n            var isBrowserMethod =\n              _.indexOf(promisedMethods, fname) >= 0;\n            var isElementMethod =\n              el && _.indexOf(elementPromisedMethods, fname) >= 0;\n            if(!isBrowserMethod && !isElementMethod) {\n              // doesn't look good\n              throw new Error(\"Invalid method \" + fname);\n            }\n\n            if(isBrowserMethod && isElementMethod) {\n              // we need to resolve the conflict.\n              if(scopeHint === '<') {\n                isElementMethod = false;\n              } else if(scopeHint === '>') {\n                isBrowserMethod = false;\n              } else if(fname.match(/element/) || (Element && args[0] instanceof Element)) {\n                // method with element locators are browser scoped by default.\n                if(_this.defaultChainingScope === 'element') { isBrowserMethod = false; }\n                else { isElementMethod = false; } // default\n              } else if(Element && args[0] instanceof Element) {\n                // When an element is passed, we are in the global scope.\n                isElementMethod = false;\n              } else {\n                // otherwise we stay in the element scope to allow sequential calls\n                isBrowserMethod = false;\n              }\n            }\n\n            if(isElementMethod) {\n              // element method case.\n              return el[fname].apply(el, args).then(function(res) {\n                if(_.indexOf(elementChainableMethods, fname) >= 0) {\n                  // method like click, where no result is expected, we return\n                  // the element to make it chainable\n                  return el;\n                } else {\n                  return res; // we have no choice but loosing the scope\n                }\n              });\n            }else{\n              // browser case.\n              return _this[fname].apply(_this, args);\n            }\n          });\n        };\n      });\n      // transfering _enrich\n      promise._enrich = function(target) {\n        return _this._enrich(target, currentEl);\n      };\n\n      // gets the element at index (starting at 0)\n      promise.at = function(i) {\n        return _this._enrich( promise.then(function(vals) {\n          return vals[i];\n        }), currentEl);\n      };\n\n      // gets the element at index (starting at 0)\n      promise.last = function() {\n        return promise.then(function(vals) {\n          return vals[vals.length - 1];\n        });\n      };\n\n      // gets nth element (starting at 1)\n      promise.nth = function(i) {\n        return promise.at(i - 1);\n      };\n\n      // gets the first element\n      promise.first = function() {\n        return promise.nth(1);\n      };\n\n      // gets the first element\n      promise.second = function() {\n        return promise.nth(2);\n      };\n\n      // gets the first element\n      promise.third = function() {\n        return promise.nth(3);\n      };\n\n      // print error\n      promise.printError = function(prepend) {\n        prepend = prepend || \"\";\n        return _this._enrich( promise.catch(function(err) {\n          console.log(prepend + err); // eslint-disable-line no-console\n          throw err;\n        }), currentEl);\n      };\n\n      // print\n      promise.print = function(prepend) {\n        prepend = prepend || \"\";\n        return _this._enrich( promise.then(function(val) {\n          console.log(prepend + val); // eslint-disable-line no-console\n        }), currentEl);\n      };\n    }\n    return obj;\n  };\n\n  /**\n   * Starts the chain (promised driver only)\n   * browser.chain()\n   * element.chain()\n   */\n  PromiseWebdriver.prototype.chain = PromiseWebdriver.prototype.noop;\n  PromiseElement.prototype.chain = PromiseElement.prototype.noop;\n\n  /**\n   * Resolves the promise (promised driver only)\n   * browser.resolve(promise)\n   * element.resolve(promise)\n   */\n  PromiseWebdriver.prototype.resolve = function(promise) {\n    var qPromise = new Q(promise);\n    this._enrich(qPromise);\n    return qPromise;\n  };\n  PromiseElement.prototype.resolve = function(promise) {\n    var qPromise = new Q(promise);\n    this._enrich(qPromise);\n    return qPromise;\n  };\n\n\n  // used to by chai-as-promised and custom methods\n  PromiseElement.prototype._enrich = function(target) {\n    if(chainable) { return this.browser._enrich(target, this); }\n  };\n\n  // used to wrap custom methods\n  PromiseWebdriver._wrapAsync = wrap;\n\n  // helper to allow easier promise debugging.\n  PromiseWebdriver.prototype._debugPromise = function() {\n    this.on('promise', function(context, method, args, status) {\n      args = _.clone(args);\n      if(context instanceof PromiseWebdriver) {\n        context = '';\n      } else {\n        context = ' [element ' + context.value + ']';\n      }\n      if(typeof _.last(args) === 'function') {\n        args.pop();\n      }\n      args = ' ( ' + _(args).map(function(arg) {\n        if(arg instanceof Element) {\n          return arg.toString();\n        } else if(typeof arg === 'object') {\n          return JSON.stringify(arg);\n        } else {\n          return arg;\n        }\n      }).join(', ') + ' )';\n      console.log(' --> ' + status + context + \" \" + method + args); // eslint-disable-line no-console\n    });\n  };\n\n  return {\n    PromiseWebdriver: PromiseWebdriver,\n    PromiseElement: PromiseElement\n  };\n};\n"]},"metadata":{},"sourceType":"script"}