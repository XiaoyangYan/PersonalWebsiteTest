{"ast":null,"code":"/**\r\n * archiver-utils\r\n *\r\n * Copyright (c) 2012-2014 Chris Talkington, contributors.\r\n * Licensed under the MIT license.\r\n * https://github.com/archiverjs/node-archiver/blob/master/LICENSE-MIT\r\n */\nvar fs = require('graceful-fs');\n\nvar path = require('path');\n\nvar flatten = require('lodash.flatten');\n\nvar difference = require('lodash.difference');\n\nvar union = require('lodash.union');\n\nvar isPlainObject = require('lodash.isplainobject');\n\nvar glob = require('glob');\n\nvar file = module.exports = {};\nvar pathSeparatorRe = /[\\/\\\\]/g; // Process specified wildcard glob patterns or filenames against a\n// callback, excluding and uniquing files in the result set.\n\nvar processPatterns = function (patterns, fn) {\n  // Filepaths to return.\n  var result = []; // Iterate over flattened patterns array.\n\n  flatten(patterns).forEach(function (pattern) {\n    // If the first character is ! it should be omitted\n    var exclusion = pattern.indexOf('!') === 0; // If the pattern is an exclusion, remove the !\n\n    if (exclusion) {\n      pattern = pattern.slice(1);\n    } // Find all matching files for this pattern.\n\n\n    var matches = fn(pattern);\n\n    if (exclusion) {\n      // If an exclusion, remove matching files.\n      result = difference(result, matches);\n    } else {\n      // Otherwise add matching files.\n      result = union(result, matches);\n    }\n  });\n  return result;\n}; // True if the file path exists.\n\n\nfile.exists = function () {\n  var filepath = path.join.apply(path, arguments);\n  return fs.existsSync(filepath);\n}; // Return an array of all file paths that match the given wildcard patterns.\n\n\nfile.expand = function (...args) {\n  // If the first argument is an options object, save those options to pass\n  // into the File.prototype.glob.sync method.\n  var options = isPlainObject(args[0]) ? args.shift() : {}; // Use the first argument if it's an Array, otherwise convert the arguments\n  // object to an array and use that.\n\n  var patterns = Array.isArray(args[0]) ? args[0] : args; // Return empty set if there are no patterns or filepaths.\n\n  if (patterns.length === 0) {\n    return [];\n  } // Return all matching filepaths.\n\n\n  var matches = processPatterns(patterns, function (pattern) {\n    // Find all matching files for this pattern.\n    return glob.sync(pattern, options);\n  }); // Filter result set?\n\n  if (options.filter) {\n    matches = matches.filter(function (filepath) {\n      filepath = path.join(options.cwd || '', filepath);\n\n      try {\n        if (typeof options.filter === 'function') {\n          return options.filter(filepath);\n        } else {\n          // If the file is of the right type and exists, this should work.\n          return fs.statSync(filepath)[options.filter]();\n        }\n      } catch (e) {\n        // Otherwise, it's probably not the right type.\n        return false;\n      }\n    });\n  }\n\n  return matches;\n}; // Build a multi task \"files\" object dynamically.\n\n\nfile.expandMapping = function (patterns, destBase, options) {\n  options = Object.assign({\n    rename: function (destBase, destPath) {\n      return path.join(destBase || '', destPath);\n    }\n  }, options);\n  var files = [];\n  var fileByDest = {}; // Find all files matching pattern, using passed-in options.\n\n  file.expand(options, patterns).forEach(function (src) {\n    var destPath = src; // Flatten?\n\n    if (options.flatten) {\n      destPath = path.basename(destPath);\n    } // Change the extension?\n\n\n    if (options.ext) {\n      destPath = destPath.replace(/(\\.[^\\/]*)?$/, options.ext);\n    } // Generate destination filename.\n\n\n    var dest = options.rename(destBase, destPath, options); // Prepend cwd to src path if necessary.\n\n    if (options.cwd) {\n      src = path.join(options.cwd, src);\n    } // Normalize filepaths to be unix-style.\n\n\n    dest = dest.replace(pathSeparatorRe, '/');\n    src = src.replace(pathSeparatorRe, '/'); // Map correct src path to dest path.\n\n    if (fileByDest[dest]) {\n      // If dest already exists, push this src onto that dest's src array.\n      fileByDest[dest].src.push(src);\n    } else {\n      // Otherwise create a new src-dest file mapping object.\n      files.push({\n        src: [src],\n        dest: dest\n      }); // And store a reference for later use.\n\n      fileByDest[dest] = files[files.length - 1];\n    }\n  });\n  return files;\n}; // reusing bits of grunt's multi-task source normalization\n\n\nfile.normalizeFilesArray = function (data) {\n  var files = [];\n  data.forEach(function (obj) {\n    var prop;\n\n    if ('src' in obj || 'dest' in obj) {\n      files.push(obj);\n    }\n  });\n\n  if (files.length === 0) {\n    return [];\n  }\n\n  files = _(files).chain().forEach(function (obj) {\n    if (!('src' in obj) || !obj.src) {\n      return;\n    } // Normalize .src properties to flattened array.\n\n\n    if (Array.isArray(obj.src)) {\n      obj.src = flatten(obj.src);\n    } else {\n      obj.src = [obj.src];\n    }\n  }).map(function (obj) {\n    // Build options object, removing unwanted properties.\n    var expandOptions = Object.assign({}, obj);\n    delete expandOptions.src;\n    delete expandOptions.dest; // Expand file mappings.\n\n    if (obj.expand) {\n      return file.expandMapping(obj.src, obj.dest, expandOptions).map(function (mapObj) {\n        // Copy obj properties to result.\n        var result = Object.assign({}, obj); // Make a clone of the orig obj available.\n\n        result.orig = Object.assign({}, obj); // Set .src and .dest, processing both as templates.\n\n        result.src = mapObj.src;\n        result.dest = mapObj.dest; // Remove unwanted properties.\n\n        ['expand', 'cwd', 'flatten', 'rename', 'ext'].forEach(function (prop) {\n          delete result[prop];\n        });\n        return result;\n      });\n    } // Copy obj properties to result, adding an .orig property.\n\n\n    var result = Object.assign({}, obj); // Make a clone of the orig obj available.\n\n    result.orig = Object.assign({}, obj);\n\n    if ('src' in result) {\n      // Expose an expand-on-demand getter method as .src.\n      Object.defineProperty(result, 'src', {\n        enumerable: true,\n        get: function fn() {\n          var src;\n\n          if (!('result' in fn)) {\n            src = obj.src; // If src is an array, flatten it. Otherwise, make it into an array.\n\n            src = Array.isArray(src) ? flatten(src) : [src]; // Expand src files, memoizing result.\n\n            fn.result = file.expand(expandOptions, src);\n          }\n\n          return fn.result;\n        }\n      });\n    }\n\n    if ('dest' in result) {\n      result.dest = obj.dest;\n    }\n\n    return result;\n  }).flatten().value();\n  return files;\n};","map":{"version":3,"sources":["/home/yanxiaoyang/react-project/PersonalWebsiteTest/node_modules/archiver-utils/file.js"],"names":["fs","require","path","flatten","difference","union","isPlainObject","glob","file","module","exports","pathSeparatorRe","processPatterns","patterns","fn","result","forEach","pattern","exclusion","indexOf","slice","matches","exists","filepath","join","apply","arguments","existsSync","expand","args","options","shift","Array","isArray","length","sync","filter","cwd","statSync","e","expandMapping","destBase","Object","assign","rename","destPath","files","fileByDest","src","basename","ext","replace","dest","push","normalizeFilesArray","data","obj","prop","_","chain","map","expandOptions","mapObj","orig","defineProperty","enumerable","get","value"],"mappings":"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","sourcesContent":["/**\r\n * archiver-utils\r\n *\r\n * Copyright (c) 2012-2014 Chris Talkington, contributors.\r\n * Licensed under the MIT license.\r\n * https://github.com/archiverjs/node-archiver/blob/master/LICENSE-MIT\r\n */\r\nvar fs = require('graceful-fs');\r\nvar path = require('path');\r\n\r\nvar flatten = require('lodash.flatten');\r\nvar difference = require('lodash.difference');\r\nvar union = require('lodash.union');\r\nvar isPlainObject = require('lodash.isplainobject');\r\n\r\nvar glob = require('glob');\r\n\r\nvar file = module.exports = {};\r\n\r\nvar pathSeparatorRe = /[\\/\\\\]/g;\r\n\r\n// Process specified wildcard glob patterns or filenames against a\r\n// callback, excluding and uniquing files in the result set.\r\nvar processPatterns = function(patterns, fn) {\r\n  // Filepaths to return.\r\n  var result = [];\r\n  // Iterate over flattened patterns array.\r\n  flatten(patterns).forEach(function(pattern) {\r\n    // If the first character is ! it should be omitted\r\n    var exclusion = pattern.indexOf('!') === 0;\r\n    // If the pattern is an exclusion, remove the !\r\n    if (exclusion) { pattern = pattern.slice(1); }\r\n    // Find all matching files for this pattern.\r\n    var matches = fn(pattern);\r\n    if (exclusion) {\r\n      // If an exclusion, remove matching files.\r\n      result = difference(result, matches);\r\n    } else {\r\n      // Otherwise add matching files.\r\n      result = union(result, matches);\r\n    }\r\n  });\r\n  return result;\r\n};\r\n\r\n// True if the file path exists.\r\nfile.exists = function() {\r\n  var filepath = path.join.apply(path, arguments);\r\n  return fs.existsSync(filepath);\r\n};\r\n\r\n// Return an array of all file paths that match the given wildcard patterns.\r\nfile.expand = function(...args) {\r\n  // If the first argument is an options object, save those options to pass\r\n  // into the File.prototype.glob.sync method.\r\n  var options = isPlainObject(args[0]) ? args.shift() : {};\r\n  // Use the first argument if it's an Array, otherwise convert the arguments\r\n  // object to an array and use that.\r\n  var patterns = Array.isArray(args[0]) ? args[0] : args;\r\n  // Return empty set if there are no patterns or filepaths.\r\n  if (patterns.length === 0) { return []; }\r\n  // Return all matching filepaths.\r\n  var matches = processPatterns(patterns, function(pattern) {\r\n    // Find all matching files for this pattern.\r\n    return glob.sync(pattern, options);\r\n  });\r\n  // Filter result set?\r\n  if (options.filter) {\r\n    matches = matches.filter(function(filepath) {\r\n      filepath = path.join(options.cwd || '', filepath);\r\n      try {\r\n        if (typeof options.filter === 'function') {\r\n          return options.filter(filepath);\r\n        } else {\r\n          // If the file is of the right type and exists, this should work.\r\n          return fs.statSync(filepath)[options.filter]();\r\n        }\r\n      } catch(e) {\r\n        // Otherwise, it's probably not the right type.\r\n        return false;\r\n      }\r\n    });\r\n  }\r\n  return matches;\r\n};\r\n\r\n// Build a multi task \"files\" object dynamically.\r\nfile.expandMapping = function(patterns, destBase, options) {\r\n  options = Object.assign({\r\n    rename: function(destBase, destPath) {\r\n      return path.join(destBase || '', destPath);\r\n    }\r\n  }, options);\r\n  var files = [];\r\n  var fileByDest = {};\r\n  // Find all files matching pattern, using passed-in options.\r\n  file.expand(options, patterns).forEach(function(src) {\r\n    var destPath = src;\r\n    // Flatten?\r\n    if (options.flatten) {\r\n      destPath = path.basename(destPath);\r\n    }\r\n    // Change the extension?\r\n    if (options.ext) {\r\n      destPath = destPath.replace(/(\\.[^\\/]*)?$/, options.ext);\r\n    }\r\n    // Generate destination filename.\r\n    var dest = options.rename(destBase, destPath, options);\r\n    // Prepend cwd to src path if necessary.\r\n    if (options.cwd) { src = path.join(options.cwd, src); }\r\n    // Normalize filepaths to be unix-style.\r\n    dest = dest.replace(pathSeparatorRe, '/');\r\n    src = src.replace(pathSeparatorRe, '/');\r\n    // Map correct src path to dest path.\r\n    if (fileByDest[dest]) {\r\n      // If dest already exists, push this src onto that dest's src array.\r\n      fileByDest[dest].src.push(src);\r\n    } else {\r\n      // Otherwise create a new src-dest file mapping object.\r\n      files.push({\r\n        src: [src],\r\n        dest: dest,\r\n      });\r\n      // And store a reference for later use.\r\n      fileByDest[dest] = files[files.length - 1];\r\n    }\r\n  });\r\n  return files;\r\n};\r\n\r\n// reusing bits of grunt's multi-task source normalization\r\nfile.normalizeFilesArray = function(data) {\r\n  var files = [];\r\n\r\n  data.forEach(function(obj) {\r\n    var prop;\r\n    if ('src' in obj || 'dest' in obj) {\r\n      files.push(obj);\r\n    }\r\n  });\r\n\r\n  if (files.length === 0) {\r\n    return [];\r\n  }\r\n\r\n  files = _(files).chain().forEach(function(obj) {\r\n    if (!('src' in obj) || !obj.src) { return; }\r\n    // Normalize .src properties to flattened array.\r\n    if (Array.isArray(obj.src)) {\r\n      obj.src = flatten(obj.src);\r\n    } else {\r\n      obj.src = [obj.src];\r\n    }\r\n  }).map(function(obj) {\r\n    // Build options object, removing unwanted properties.\r\n    var expandOptions = Object.assign({}, obj);\r\n    delete expandOptions.src;\r\n    delete expandOptions.dest;\r\n\r\n    // Expand file mappings.\r\n    if (obj.expand) {\r\n      return file.expandMapping(obj.src, obj.dest, expandOptions).map(function(mapObj) {\r\n        // Copy obj properties to result.\r\n        var result = Object.assign({}, obj);\r\n        // Make a clone of the orig obj available.\r\n        result.orig = Object.assign({}, obj);\r\n        // Set .src and .dest, processing both as templates.\r\n        result.src = mapObj.src;\r\n        result.dest = mapObj.dest;\r\n        // Remove unwanted properties.\r\n        ['expand', 'cwd', 'flatten', 'rename', 'ext'].forEach(function(prop) {\r\n          delete result[prop];\r\n        });\r\n        return result;\r\n      });\r\n    }\r\n\r\n    // Copy obj properties to result, adding an .orig property.\r\n    var result = Object.assign({}, obj);\r\n    // Make a clone of the orig obj available.\r\n    result.orig = Object.assign({}, obj);\r\n\r\n    if ('src' in result) {\r\n      // Expose an expand-on-demand getter method as .src.\r\n      Object.defineProperty(result, 'src', {\r\n        enumerable: true,\r\n        get: function fn() {\r\n          var src;\r\n          if (!('result' in fn)) {\r\n            src = obj.src;\r\n            // If src is an array, flatten it. Otherwise, make it into an array.\r\n            src = Array.isArray(src) ? flatten(src) : [src];\r\n            // Expand src files, memoizing result.\r\n            fn.result = file.expand(expandOptions, src);\r\n          }\r\n          return fn.result;\r\n        }\r\n      });\r\n    }\r\n\r\n    if ('dest' in result) {\r\n      result.dest = obj.dest;\r\n    }\r\n\r\n    return result;\r\n  }).flatten().value();\r\n\r\n  return files;\r\n};\r\n"]},"metadata":{},"sourceType":"script"}