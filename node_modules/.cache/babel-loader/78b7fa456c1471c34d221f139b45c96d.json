{"ast":null,"code":"/* Generated by `npm run build`, do not edit! */\n\"use strict\";\n\nvar tt = require(\"acorn\").tokTypes;\n\nvar skipWhiteSpace = /(?:\\s|\\/\\/.*|\\/\\*[^]*?\\*\\/)*/g;\n\nvar nextTokenIsDot = function (parser) {\n  skipWhiteSpace.lastIndex = parser.pos;\n  var skip = skipWhiteSpace.exec(parser.input);\n  var next = parser.pos + skip[0].length;\n  return parser.input.slice(next, next + 1) === \".\";\n};\n\nmodule.exports = function (Parser) {\n  return (\n    /*@__PURE__*/\n    function (Parser) {\n      function anonymous() {\n        Parser.apply(this, arguments);\n      }\n\n      if (Parser) anonymous.__proto__ = Parser;\n      anonymous.prototype = Object.create(Parser && Parser.prototype);\n      anonymous.prototype.constructor = anonymous;\n\n      anonymous.prototype.parseExprAtom = function parseExprAtom(refDestructuringErrors) {\n        if (this.type !== tt._import || !nextTokenIsDot(this)) {\n          return Parser.prototype.parseExprAtom.call(this, refDestructuringErrors);\n        }\n\n        if (!this.options.allowImportExportEverywhere && !this.inModule) {\n          this.raise(this.start, \"'import' and 'export' may appear only with 'sourceType: module'\");\n        }\n\n        var node = this.startNode();\n        node.meta = this.parseIdent(true);\n        this.expect(tt.dot);\n        node.property = this.parseIdent(true);\n\n        if (node.property.name !== \"meta\") {\n          this.raiseRecoverable(node.property.start, \"The only valid meta property for import is import.meta\");\n        }\n\n        return this.finishNode(node, \"MetaProperty\");\n      };\n\n      anonymous.prototype.parseStatement = function parseStatement(context, topLevel, exports) {\n        if (this.type !== tt._import || !nextTokenIsDot(this)) {\n          return Parser.prototype.parseStatement.call(this, context, topLevel, exports);\n        }\n\n        var node = this.startNode();\n        var expr = this.parseExpression();\n        return this.parseExpressionStatement(node, expr);\n      };\n\n      return anonymous;\n    }(Parser)\n  );\n};","map":{"version":3,"sources":["/home/yanxiaoyang/react-project/PersonalWebsiteTest/node_modules/acorn-node/lib/import-meta/index.js"],"names":["tt","require","tokTypes","skipWhiteSpace","nextTokenIsDot","parser","lastIndex","pos","skip","exec","input","next","length","slice","module","exports","Parser","anonymous","apply","arguments","__proto__","prototype","Object","create","constructor","parseExprAtom","refDestructuringErrors","type","_import","call","options","allowImportExportEverywhere","inModule","raise","start","node","startNode","meta","parseIdent","expect","dot","property","name","raiseRecoverable","finishNode","parseStatement","context","topLevel","expr","parseExpression","parseExpressionStatement"],"mappings":"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","sourcesContent":["/* Generated by `npm run build`, do not edit! */\n\n\"use strict\"\n\nvar tt = require(\"acorn\").tokTypes\n\nvar skipWhiteSpace = /(?:\\s|\\/\\/.*|\\/\\*[^]*?\\*\\/)*/g\n\nvar nextTokenIsDot = function (parser) {\n  skipWhiteSpace.lastIndex = parser.pos\n  var skip = skipWhiteSpace.exec(parser.input)\n  var next = parser.pos + skip[0].length\n  return parser.input.slice(next, next + 1) === \".\"\n}\n\nmodule.exports = function(Parser) {\n  return /*@__PURE__*/(function (Parser) {\n    function anonymous () {\n      Parser.apply(this, arguments);\n    }\n\n    if ( Parser ) anonymous.__proto__ = Parser;\n    anonymous.prototype = Object.create( Parser && Parser.prototype );\n    anonymous.prototype.constructor = anonymous;\n\n    anonymous.prototype.parseExprAtom = function parseExprAtom (refDestructuringErrors) {\n      if (this.type !== tt._import || !nextTokenIsDot(this)) { return Parser.prototype.parseExprAtom.call(this, refDestructuringErrors) }\n\n      if (!this.options.allowImportExportEverywhere && !this.inModule) {\n        this.raise(this.start, \"'import' and 'export' may appear only with 'sourceType: module'\")\n      }\n\n      var node = this.startNode()\n      node.meta = this.parseIdent(true)\n      this.expect(tt.dot)\n      node.property = this.parseIdent(true)\n      if (node.property.name !== \"meta\") {\n        this.raiseRecoverable(node.property.start, \"The only valid meta property for import is import.meta\")\n      }\n      return this.finishNode(node, \"MetaProperty\")\n    };\n\n    anonymous.prototype.parseStatement = function parseStatement (context, topLevel, exports) {\n      if (this.type !== tt._import || !nextTokenIsDot(this)) {\n        return Parser.prototype.parseStatement.call(this, context, topLevel, exports)\n      }\n\n      var node = this.startNode()\n      var expr = this.parseExpression()\n      return this.parseExpressionStatement(node, expr)\n    };\n\n    return anonymous;\n  }(Parser))\n}\n"]},"metadata":{},"sourceType":"script"}