{"ast":null,"code":"// Copyright Joyent, Inc. and other Node contributors.\n//\n// Permission is hereby granted, free of charge, to any person obtaining a\n// copy of this software and associated documentation files (the\n// \"Software\"), to deal in the Software without restriction, including\n// without limitation the rights to use, copy, modify, merge, publish,\n// distribute, sublicense, and/or sell copies of the Software, and to permit\n// persons to whom the Software is furnished to do so, subject to the\n// following conditions:\n//\n// The above copyright notice and this permission notice shall be included\n// in all copies or substantial portions of the Software.\n//\n// THE SOFTWARE IS PROVIDED \"AS IS\", WITHOUT WARRANTY OF ANY KIND, EXPRESS\n// OR IMPLIED, INCLUDING BUT NOT LIMITED TO THE WARRANTIES OF\n// MERCHANTABILITY, FITNESS FOR A PARTICULAR PURPOSE AND NONINFRINGEMENT. IN\n// NO EVENT SHALL THE AUTHORS OR COPYRIGHT HOLDERS BE LIABLE FOR ANY CLAIM,\n// DAMAGES OR OTHER LIABILITY, WHETHER IN AN ACTION OF CONTRACT, TORT OR\n// OTHERWISE, ARISING FROM, OUT OF OR IN CONNECTION WITH THE SOFTWARE OR THE\n// USE OR OTHER DEALINGS IN THE SOFTWARE.\nvar Transform = require('_stream_transform');\n\nvar binding = require('./binding');\n\nvar util = require('util');\n\nvar assert = require('assert').ok; // zlib doesn't provide these, so kludge them in following the same\n// const naming scheme zlib uses.\n\n\nbinding.Z_MIN_WINDOWBITS = 8;\nbinding.Z_MAX_WINDOWBITS = 15;\nbinding.Z_DEFAULT_WINDOWBITS = 15; // fewer than 64 bytes per chunk is stupid.\n// technically it could work with as few as 8, but even 64 bytes\n// is absurdly low.  Usually a MB or more is best.\n\nbinding.Z_MIN_CHUNK = 64;\nbinding.Z_MAX_CHUNK = Infinity;\nbinding.Z_DEFAULT_CHUNK = 16 * 1024;\nbinding.Z_MIN_MEMLEVEL = 1;\nbinding.Z_MAX_MEMLEVEL = 9;\nbinding.Z_DEFAULT_MEMLEVEL = 8;\nbinding.Z_MIN_LEVEL = -1;\nbinding.Z_MAX_LEVEL = 9;\nbinding.Z_DEFAULT_LEVEL = binding.Z_DEFAULT_COMPRESSION; // expose all the zlib constants\n\nObject.keys(binding).forEach(function (k) {\n  if (k.match(/^Z/)) exports[k] = binding[k];\n}); // translation table for return codes.\n\nexports.codes = {\n  Z_OK: binding.Z_OK,\n  Z_STREAM_END: binding.Z_STREAM_END,\n  Z_NEED_DICT: binding.Z_NEED_DICT,\n  Z_ERRNO: binding.Z_ERRNO,\n  Z_STREAM_ERROR: binding.Z_STREAM_ERROR,\n  Z_DATA_ERROR: binding.Z_DATA_ERROR,\n  Z_MEM_ERROR: binding.Z_MEM_ERROR,\n  Z_BUF_ERROR: binding.Z_BUF_ERROR,\n  Z_VERSION_ERROR: binding.Z_VERSION_ERROR\n};\nObject.keys(exports.codes).forEach(function (k) {\n  exports.codes[exports.codes[k]] = k;\n});\nexports.Deflate = Deflate;\nexports.Inflate = Inflate;\nexports.Gzip = Gzip;\nexports.Gunzip = Gunzip;\nexports.DeflateRaw = DeflateRaw;\nexports.InflateRaw = InflateRaw;\nexports.Unzip = Unzip;\n\nexports.createDeflate = function (o) {\n  return new Deflate(o);\n};\n\nexports.createInflate = function (o) {\n  return new Inflate(o);\n};\n\nexports.createDeflateRaw = function (o) {\n  return new DeflateRaw(o);\n};\n\nexports.createInflateRaw = function (o) {\n  return new InflateRaw(o);\n};\n\nexports.createGzip = function (o) {\n  return new Gzip(o);\n};\n\nexports.createGunzip = function (o) {\n  return new Gunzip(o);\n};\n\nexports.createUnzip = function (o) {\n  return new Unzip(o);\n}; // Convenience methods.\n// compress/decompress a string or buffer in one step.\n\n\nexports.deflate = function (buffer, opts, callback) {\n  if (typeof opts === 'function') {\n    callback = opts;\n    opts = {};\n  }\n\n  return zlibBuffer(new Deflate(opts), buffer, callback);\n};\n\nexports.deflateSync = function (buffer, opts) {\n  return zlibBufferSync(new Deflate(opts), buffer);\n};\n\nexports.gzip = function (buffer, opts, callback) {\n  if (typeof opts === 'function') {\n    callback = opts;\n    opts = {};\n  }\n\n  return zlibBuffer(new Gzip(opts), buffer, callback);\n};\n\nexports.gzipSync = function (buffer, opts) {\n  return zlibBufferSync(new Gzip(opts), buffer);\n};\n\nexports.deflateRaw = function (buffer, opts, callback) {\n  if (typeof opts === 'function') {\n    callback = opts;\n    opts = {};\n  }\n\n  return zlibBuffer(new DeflateRaw(opts), buffer, callback);\n};\n\nexports.deflateRawSync = function (buffer, opts) {\n  return zlibBufferSync(new DeflateRaw(opts), buffer);\n};\n\nexports.unzip = function (buffer, opts, callback) {\n  if (typeof opts === 'function') {\n    callback = opts;\n    opts = {};\n  }\n\n  return zlibBuffer(new Unzip(opts), buffer, callback);\n};\n\nexports.unzipSync = function (buffer, opts) {\n  return zlibBufferSync(new Unzip(opts), buffer);\n};\n\nexports.inflate = function (buffer, opts, callback) {\n  if (typeof opts === 'function') {\n    callback = opts;\n    opts = {};\n  }\n\n  return zlibBuffer(new Inflate(opts), buffer, callback);\n};\n\nexports.inflateSync = function (buffer, opts) {\n  return zlibBufferSync(new Inflate(opts), buffer);\n};\n\nexports.gunzip = function (buffer, opts, callback) {\n  if (typeof opts === 'function') {\n    callback = opts;\n    opts = {};\n  }\n\n  return zlibBuffer(new Gunzip(opts), buffer, callback);\n};\n\nexports.gunzipSync = function (buffer, opts) {\n  return zlibBufferSync(new Gunzip(opts), buffer);\n};\n\nexports.inflateRaw = function (buffer, opts, callback) {\n  if (typeof opts === 'function') {\n    callback = opts;\n    opts = {};\n  }\n\n  return zlibBuffer(new InflateRaw(opts), buffer, callback);\n};\n\nexports.inflateRawSync = function (buffer, opts) {\n  return zlibBufferSync(new InflateRaw(opts), buffer);\n};\n\nfunction zlibBuffer(engine, buffer, callback) {\n  var buffers = [];\n  var nread = 0;\n  engine.on('error', onError);\n  engine.on('end', onEnd);\n  engine.end(buffer);\n  flow();\n\n  function flow() {\n    var chunk;\n\n    while (null !== (chunk = engine.read())) {\n      buffers.push(chunk);\n      nread += chunk.length;\n    }\n\n    engine.once('readable', flow);\n  }\n\n  function onError(err) {\n    engine.removeListener('end', onEnd);\n    engine.removeListener('readable', flow);\n    callback(err);\n  }\n\n  function onEnd() {\n    var buf = Buffer.concat(buffers, nread);\n    buffers = [];\n    callback(null, buf);\n    engine.close();\n  }\n}\n\nfunction zlibBufferSync(engine, buffer) {\n  if (typeof buffer === 'string') buffer = new Buffer(buffer);\n  if (!Buffer.isBuffer(buffer)) throw new TypeError('Not a string or buffer');\n  var flushFlag = binding.Z_FINISH;\n  return engine._processChunk(buffer, flushFlag);\n} // generic zlib\n// minimal 2-byte header\n\n\nfunction Deflate(opts) {\n  if (!(this instanceof Deflate)) return new Deflate(opts);\n  Zlib.call(this, opts, binding.DEFLATE);\n}\n\nfunction Inflate(opts) {\n  if (!(this instanceof Inflate)) return new Inflate(opts);\n  Zlib.call(this, opts, binding.INFLATE);\n} // gzip - bigger header, same deflate compression\n\n\nfunction Gzip(opts) {\n  if (!(this instanceof Gzip)) return new Gzip(opts);\n  Zlib.call(this, opts, binding.GZIP);\n}\n\nfunction Gunzip(opts) {\n  if (!(this instanceof Gunzip)) return new Gunzip(opts);\n  Zlib.call(this, opts, binding.GUNZIP);\n} // raw - no header\n\n\nfunction DeflateRaw(opts) {\n  if (!(this instanceof DeflateRaw)) return new DeflateRaw(opts);\n  Zlib.call(this, opts, binding.DEFLATERAW);\n}\n\nfunction InflateRaw(opts) {\n  if (!(this instanceof InflateRaw)) return new InflateRaw(opts);\n  Zlib.call(this, opts, binding.INFLATERAW);\n} // auto-detect header.\n\n\nfunction Unzip(opts) {\n  if (!(this instanceof Unzip)) return new Unzip(opts);\n  Zlib.call(this, opts, binding.UNZIP);\n} // the Zlib class they all inherit from\n// This thing manages the queue of requests, and returns\n// true or false if there is anything in the queue when\n// you call the .write() method.\n\n\nfunction Zlib(opts, mode) {\n  this._opts = opts = opts || {};\n  this._chunkSize = opts.chunkSize || exports.Z_DEFAULT_CHUNK;\n  Transform.call(this, opts);\n\n  if (opts.flush) {\n    if (opts.flush !== binding.Z_NO_FLUSH && opts.flush !== binding.Z_PARTIAL_FLUSH && opts.flush !== binding.Z_SYNC_FLUSH && opts.flush !== binding.Z_FULL_FLUSH && opts.flush !== binding.Z_FINISH && opts.flush !== binding.Z_BLOCK) {\n      throw new Error('Invalid flush flag: ' + opts.flush);\n    }\n  }\n\n  this._flushFlag = opts.flush || binding.Z_NO_FLUSH;\n\n  if (opts.chunkSize) {\n    if (opts.chunkSize < exports.Z_MIN_CHUNK || opts.chunkSize > exports.Z_MAX_CHUNK) {\n      throw new Error('Invalid chunk size: ' + opts.chunkSize);\n    }\n  }\n\n  if (opts.windowBits) {\n    if (opts.windowBits < exports.Z_MIN_WINDOWBITS || opts.windowBits > exports.Z_MAX_WINDOWBITS) {\n      throw new Error('Invalid windowBits: ' + opts.windowBits);\n    }\n  }\n\n  if (opts.level) {\n    if (opts.level < exports.Z_MIN_LEVEL || opts.level > exports.Z_MAX_LEVEL) {\n      throw new Error('Invalid compression level: ' + opts.level);\n    }\n  }\n\n  if (opts.memLevel) {\n    if (opts.memLevel < exports.Z_MIN_MEMLEVEL || opts.memLevel > exports.Z_MAX_MEMLEVEL) {\n      throw new Error('Invalid memLevel: ' + opts.memLevel);\n    }\n  }\n\n  if (opts.strategy) {\n    if (opts.strategy != exports.Z_FILTERED && opts.strategy != exports.Z_HUFFMAN_ONLY && opts.strategy != exports.Z_RLE && opts.strategy != exports.Z_FIXED && opts.strategy != exports.Z_DEFAULT_STRATEGY) {\n      throw new Error('Invalid strategy: ' + opts.strategy);\n    }\n  }\n\n  if (opts.dictionary) {\n    if (!Buffer.isBuffer(opts.dictionary)) {\n      throw new Error('Invalid dictionary: it should be a Buffer instance');\n    }\n  }\n\n  this._binding = new binding.Zlib(mode);\n  var self = this;\n  this._hadError = false;\n\n  this._binding.onerror = function (message, errno) {\n    // there is no way to cleanly recover.\n    // continuing only obscures problems.\n    self._binding = null;\n    self._hadError = true;\n    var error = new Error(message);\n    error.errno = errno;\n    error.code = exports.codes[errno];\n    self.emit('error', error);\n  };\n\n  var level = exports.Z_DEFAULT_COMPRESSION;\n  if (typeof opts.level === 'number') level = opts.level;\n  var strategy = exports.Z_DEFAULT_STRATEGY;\n  if (typeof opts.strategy === 'number') strategy = opts.strategy;\n\n  this._binding.init(opts.windowBits || exports.Z_DEFAULT_WINDOWBITS, level, opts.memLevel || exports.Z_DEFAULT_MEMLEVEL, strategy, opts.dictionary);\n\n  this._buffer = new Buffer(this._chunkSize);\n  this._offset = 0;\n  this._closed = false;\n  this._level = level;\n  this._strategy = strategy;\n  this.once('end', this.close);\n}\n\nutil.inherits(Zlib, Transform);\n\nZlib.prototype.params = function (level, strategy, callback) {\n  if (level < exports.Z_MIN_LEVEL || level > exports.Z_MAX_LEVEL) {\n    throw new RangeError('Invalid compression level: ' + level);\n  }\n\n  if (strategy != exports.Z_FILTERED && strategy != exports.Z_HUFFMAN_ONLY && strategy != exports.Z_RLE && strategy != exports.Z_FIXED && strategy != exports.Z_DEFAULT_STRATEGY) {\n    throw new TypeError('Invalid strategy: ' + strategy);\n  }\n\n  if (this._level !== level || this._strategy !== strategy) {\n    var self = this;\n    this.flush(binding.Z_SYNC_FLUSH, function () {\n      self._binding.params(level, strategy);\n\n      if (!self._hadError) {\n        self._level = level;\n        self._strategy = strategy;\n        if (callback) callback();\n      }\n    });\n  } else {\n    process.nextTick(callback);\n  }\n};\n\nZlib.prototype.reset = function () {\n  return this._binding.reset();\n}; // This is the _flush function called by the transform class,\n// internally, when the last chunk has been written.\n\n\nZlib.prototype._flush = function (callback) {\n  this._transform(new Buffer(0), '', callback);\n};\n\nZlib.prototype.flush = function (kind, callback) {\n  var ws = this._writableState;\n\n  if (typeof kind === 'function' || kind === void 0 && !callback) {\n    callback = kind;\n    kind = binding.Z_FULL_FLUSH;\n  }\n\n  if (ws.ended) {\n    if (callback) process.nextTick(callback);\n  } else if (ws.ending) {\n    if (callback) this.once('end', callback);\n  } else if (ws.needDrain) {\n    var self = this;\n    this.once('drain', function () {\n      self.flush(callback);\n    });\n  } else {\n    this._flushFlag = kind;\n    this.write(new Buffer(0), '', callback);\n  }\n};\n\nZlib.prototype.close = function (callback) {\n  if (callback) process.nextTick(callback);\n  if (this._closed) return;\n  this._closed = true;\n\n  this._binding.close();\n\n  var self = this;\n  process.nextTick(function () {\n    self.emit('close');\n  });\n};\n\nZlib.prototype._transform = function (chunk, encoding, cb) {\n  var flushFlag;\n  var ws = this._writableState;\n  var ending = ws.ending || ws.ended;\n  var last = ending && (!chunk || ws.length === chunk.length);\n  if (!chunk === null && !Buffer.isBuffer(chunk)) return cb(new Error('invalid input')); // If it's the last chunk, or a final flush, we use the Z_FINISH flush flag.\n  // If it's explicitly flushing at some other time, then we use\n  // Z_FULL_FLUSH. Otherwise, use Z_NO_FLUSH for maximum compression\n  // goodness.\n\n  if (last) flushFlag = binding.Z_FINISH;else {\n    flushFlag = this._flushFlag; // once we've flushed the last of the queue, stop flushing and\n    // go back to the normal behavior.\n\n    if (chunk.length >= ws.length) {\n      this._flushFlag = this._opts.flush || binding.Z_NO_FLUSH;\n    }\n  }\n  var self = this;\n\n  this._processChunk(chunk, flushFlag, cb);\n};\n\nZlib.prototype._processChunk = function (chunk, flushFlag, cb) {\n  var availInBefore = chunk && chunk.length;\n  var availOutBefore = this._chunkSize - this._offset;\n  var inOff = 0;\n  var self = this;\n  var async = typeof cb === 'function';\n\n  if (!async) {\n    var buffers = [];\n    var nread = 0;\n    var error;\n    this.on('error', function (er) {\n      error = er;\n    });\n\n    do {\n      var res = this._binding.writeSync(flushFlag, chunk, // in\n      inOff, // in_off\n      availInBefore, // in_len\n      this._buffer, // out\n      this._offset, //out_off\n      availOutBefore); // out_len\n\n    } while (!this._hadError && callback(res[0], res[1]));\n\n    if (this._hadError) {\n      throw error;\n    }\n\n    var buf = Buffer.concat(buffers, nread);\n    this.close();\n    return buf;\n  }\n\n  var req = this._binding.write(flushFlag, chunk, // in\n  inOff, // in_off\n  availInBefore, // in_len\n  this._buffer, // out\n  this._offset, //out_off\n  availOutBefore); // out_len\n\n\n  req.buffer = chunk;\n  req.callback = callback;\n\n  function callback(availInAfter, availOutAfter) {\n    if (self._hadError) return;\n    var have = availOutBefore - availOutAfter;\n    assert(have >= 0, 'have should not go down');\n\n    if (have > 0) {\n      var out = self._buffer.slice(self._offset, self._offset + have);\n\n      self._offset += have; // serve some output to the consumer.\n\n      if (async) {\n        self.push(out);\n      } else {\n        buffers.push(out);\n        nread += out.length;\n      }\n    } // exhausted the output buffer, or used all the input create a new one.\n\n\n    if (availOutAfter === 0 || self._offset >= self._chunkSize) {\n      availOutBefore = self._chunkSize;\n      self._offset = 0;\n      self._buffer = new Buffer(self._chunkSize);\n    }\n\n    if (availOutAfter === 0) {\n      // Not actually done.  Need to reprocess.\n      // Also, update the availInBefore to the availInAfter value,\n      // so that if we have to hit it a third (fourth, etc.) time,\n      // it'll have the correct byte counts.\n      inOff += availInBefore - availInAfter;\n      availInBefore = availInAfter;\n      if (!async) return true;\n\n      var newReq = self._binding.write(flushFlag, chunk, inOff, availInBefore, self._buffer, self._offset, self._chunkSize);\n\n      newReq.callback = callback; // this same function\n\n      newReq.buffer = chunk;\n      return;\n    }\n\n    if (!async) return false; // finished with the chunk.\n\n    cb();\n  }\n};\n\nutil.inherits(Deflate, Zlib);\nutil.inherits(Inflate, Zlib);\nutil.inherits(Gzip, Zlib);\nutil.inherits(Gunzip, Zlib);\nutil.inherits(DeflateRaw, Zlib);\nutil.inherits(InflateRaw, Zlib);\nutil.inherits(Unzip, Zlib);","map":{"version":3,"sources":["/home/yanxiaoyang/react-project/PersonalWebsiteTest/node_modules/browserify/node_modules/browserify-zlib/src/index.js"],"names":["Transform","require","binding","util","assert","ok","Z_MIN_WINDOWBITS","Z_MAX_WINDOWBITS","Z_DEFAULT_WINDOWBITS","Z_MIN_CHUNK","Z_MAX_CHUNK","Infinity","Z_DEFAULT_CHUNK","Z_MIN_MEMLEVEL","Z_MAX_MEMLEVEL","Z_DEFAULT_MEMLEVEL","Z_MIN_LEVEL","Z_MAX_LEVEL","Z_DEFAULT_LEVEL","Z_DEFAULT_COMPRESSION","Object","keys","forEach","k","match","exports","codes","Z_OK","Z_STREAM_END","Z_NEED_DICT","Z_ERRNO","Z_STREAM_ERROR","Z_DATA_ERROR","Z_MEM_ERROR","Z_BUF_ERROR","Z_VERSION_ERROR","Deflate","Inflate","Gzip","Gunzip","DeflateRaw","InflateRaw","Unzip","createDeflate","o","createInflate","createDeflateRaw","createInflateRaw","createGzip","createGunzip","createUnzip","deflate","buffer","opts","callback","zlibBuffer","deflateSync","zlibBufferSync","gzip","gzipSync","deflateRaw","deflateRawSync","unzip","unzipSync","inflate","inflateSync","gunzip","gunzipSync","inflateRaw","inflateRawSync","engine","buffers","nread","on","onError","onEnd","end","flow","chunk","read","push","length","once","err","removeListener","buf","Buffer","concat","close","isBuffer","TypeError","flushFlag","Z_FINISH","_processChunk","Zlib","call","DEFLATE","INFLATE","GZIP","GUNZIP","DEFLATERAW","INFLATERAW","UNZIP","mode","_opts","_chunkSize","chunkSize","flush","Z_NO_FLUSH","Z_PARTIAL_FLUSH","Z_SYNC_FLUSH","Z_FULL_FLUSH","Z_BLOCK","Error","_flushFlag","windowBits","level","memLevel","strategy","Z_FILTERED","Z_HUFFMAN_ONLY","Z_RLE","Z_FIXED","Z_DEFAULT_STRATEGY","dictionary","_binding","self","_hadError","onerror","message","errno","error","code","emit","init","_buffer","_offset","_closed","_level","_strategy","inherits","prototype","params","RangeError","process","nextTick","reset","_flush","_transform","kind","ws","_writableState","ended","ending","needDrain","write","encoding","cb","last","availInBefore","availOutBefore","inOff","async","er","res","writeSync","req","availInAfter","availOutAfter","have","out","slice","newReq"],"mappings":"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","sourcesContent":["// Copyright Joyent, Inc. and other Node contributors.\n//\n// Permission is hereby granted, free of charge, to any person obtaining a\n// copy of this software and associated documentation files (the\n// \"Software\"), to deal in the Software without restriction, including\n// without limitation the rights to use, copy, modify, merge, publish,\n// distribute, sublicense, and/or sell copies of the Software, and to permit\n// persons to whom the Software is furnished to do so, subject to the\n// following conditions:\n//\n// The above copyright notice and this permission notice shall be included\n// in all copies or substantial portions of the Software.\n//\n// THE SOFTWARE IS PROVIDED \"AS IS\", WITHOUT WARRANTY OF ANY KIND, EXPRESS\n// OR IMPLIED, INCLUDING BUT NOT LIMITED TO THE WARRANTIES OF\n// MERCHANTABILITY, FITNESS FOR A PARTICULAR PURPOSE AND NONINFRINGEMENT. IN\n// NO EVENT SHALL THE AUTHORS OR COPYRIGHT HOLDERS BE LIABLE FOR ANY CLAIM,\n// DAMAGES OR OTHER LIABILITY, WHETHER IN AN ACTION OF CONTRACT, TORT OR\n// OTHERWISE, ARISING FROM, OUT OF OR IN CONNECTION WITH THE SOFTWARE OR THE\n// USE OR OTHER DEALINGS IN THE SOFTWARE.\n\nvar Transform = require('_stream_transform');\n\nvar binding = require('./binding');\nvar util = require('util');\nvar assert = require('assert').ok;\n\n// zlib doesn't provide these, so kludge them in following the same\n// const naming scheme zlib uses.\nbinding.Z_MIN_WINDOWBITS = 8;\nbinding.Z_MAX_WINDOWBITS = 15;\nbinding.Z_DEFAULT_WINDOWBITS = 15;\n\n// fewer than 64 bytes per chunk is stupid.\n// technically it could work with as few as 8, but even 64 bytes\n// is absurdly low.  Usually a MB or more is best.\nbinding.Z_MIN_CHUNK = 64;\nbinding.Z_MAX_CHUNK = Infinity;\nbinding.Z_DEFAULT_CHUNK = (16 * 1024);\n\nbinding.Z_MIN_MEMLEVEL = 1;\nbinding.Z_MAX_MEMLEVEL = 9;\nbinding.Z_DEFAULT_MEMLEVEL = 8;\n\nbinding.Z_MIN_LEVEL = -1;\nbinding.Z_MAX_LEVEL = 9;\nbinding.Z_DEFAULT_LEVEL = binding.Z_DEFAULT_COMPRESSION;\n\n// expose all the zlib constants\nObject.keys(binding).forEach(function(k) {\n  if (k.match(/^Z/)) exports[k] = binding[k];\n});\n\n// translation table for return codes.\nexports.codes = {\n  Z_OK: binding.Z_OK,\n  Z_STREAM_END: binding.Z_STREAM_END,\n  Z_NEED_DICT: binding.Z_NEED_DICT,\n  Z_ERRNO: binding.Z_ERRNO,\n  Z_STREAM_ERROR: binding.Z_STREAM_ERROR,\n  Z_DATA_ERROR: binding.Z_DATA_ERROR,\n  Z_MEM_ERROR: binding.Z_MEM_ERROR,\n  Z_BUF_ERROR: binding.Z_BUF_ERROR,\n  Z_VERSION_ERROR: binding.Z_VERSION_ERROR\n};\n\nObject.keys(exports.codes).forEach(function(k) {\n  exports.codes[exports.codes[k]] = k;\n});\n\nexports.Deflate = Deflate;\nexports.Inflate = Inflate;\nexports.Gzip = Gzip;\nexports.Gunzip = Gunzip;\nexports.DeflateRaw = DeflateRaw;\nexports.InflateRaw = InflateRaw;\nexports.Unzip = Unzip;\n\nexports.createDeflate = function(o) {\n  return new Deflate(o);\n};\n\nexports.createInflate = function(o) {\n  return new Inflate(o);\n};\n\nexports.createDeflateRaw = function(o) {\n  return new DeflateRaw(o);\n};\n\nexports.createInflateRaw = function(o) {\n  return new InflateRaw(o);\n};\n\nexports.createGzip = function(o) {\n  return new Gzip(o);\n};\n\nexports.createGunzip = function(o) {\n  return new Gunzip(o);\n};\n\nexports.createUnzip = function(o) {\n  return new Unzip(o);\n};\n\n\n// Convenience methods.\n// compress/decompress a string or buffer in one step.\nexports.deflate = function(buffer, opts, callback) {\n  if (typeof opts === 'function') {\n    callback = opts;\n    opts = {};\n  }\n  return zlibBuffer(new Deflate(opts), buffer, callback);\n};\n\nexports.deflateSync = function(buffer, opts) {\n  return zlibBufferSync(new Deflate(opts), buffer);\n};\n\nexports.gzip = function(buffer, opts, callback) {\n  if (typeof opts === 'function') {\n    callback = opts;\n    opts = {};\n  }\n  return zlibBuffer(new Gzip(opts), buffer, callback);\n};\n\nexports.gzipSync = function(buffer, opts) {\n  return zlibBufferSync(new Gzip(opts), buffer);\n};\n\nexports.deflateRaw = function(buffer, opts, callback) {\n  if (typeof opts === 'function') {\n    callback = opts;\n    opts = {};\n  }\n  return zlibBuffer(new DeflateRaw(opts), buffer, callback);\n};\n\nexports.deflateRawSync = function(buffer, opts) {\n  return zlibBufferSync(new DeflateRaw(opts), buffer);\n};\n\nexports.unzip = function(buffer, opts, callback) {\n  if (typeof opts === 'function') {\n    callback = opts;\n    opts = {};\n  }\n  return zlibBuffer(new Unzip(opts), buffer, callback);\n};\n\nexports.unzipSync = function(buffer, opts) {\n  return zlibBufferSync(new Unzip(opts), buffer);\n};\n\nexports.inflate = function(buffer, opts, callback) {\n  if (typeof opts === 'function') {\n    callback = opts;\n    opts = {};\n  }\n  return zlibBuffer(new Inflate(opts), buffer, callback);\n};\n\nexports.inflateSync = function(buffer, opts) {\n  return zlibBufferSync(new Inflate(opts), buffer);\n};\n\nexports.gunzip = function(buffer, opts, callback) {\n  if (typeof opts === 'function') {\n    callback = opts;\n    opts = {};\n  }\n  return zlibBuffer(new Gunzip(opts), buffer, callback);\n};\n\nexports.gunzipSync = function(buffer, opts) {\n  return zlibBufferSync(new Gunzip(opts), buffer);\n};\n\nexports.inflateRaw = function(buffer, opts, callback) {\n  if (typeof opts === 'function') {\n    callback = opts;\n    opts = {};\n  }\n  return zlibBuffer(new InflateRaw(opts), buffer, callback);\n};\n\nexports.inflateRawSync = function(buffer, opts) {\n  return zlibBufferSync(new InflateRaw(opts), buffer);\n};\n\nfunction zlibBuffer(engine, buffer, callback) {\n  var buffers = [];\n  var nread = 0;\n\n  engine.on('error', onError);\n  engine.on('end', onEnd);\n\n  engine.end(buffer);\n  flow();\n\n  function flow() {\n    var chunk;\n    while (null !== (chunk = engine.read())) {\n      buffers.push(chunk);\n      nread += chunk.length;\n    }\n    engine.once('readable', flow);\n  }\n\n  function onError(err) {\n    engine.removeListener('end', onEnd);\n    engine.removeListener('readable', flow);\n    callback(err);\n  }\n\n  function onEnd() {\n    var buf = Buffer.concat(buffers, nread);\n    buffers = [];\n    callback(null, buf);\n    engine.close();\n  }\n}\n\nfunction zlibBufferSync(engine, buffer) {\n  if (typeof buffer === 'string')\n    buffer = new Buffer(buffer);\n  if (!Buffer.isBuffer(buffer))\n    throw new TypeError('Not a string or buffer');\n\n  var flushFlag = binding.Z_FINISH;\n\n  return engine._processChunk(buffer, flushFlag);\n}\n\n// generic zlib\n// minimal 2-byte header\nfunction Deflate(opts) {\n  if (!(this instanceof Deflate)) return new Deflate(opts);\n  Zlib.call(this, opts, binding.DEFLATE);\n}\n\nfunction Inflate(opts) {\n  if (!(this instanceof Inflate)) return new Inflate(opts);\n  Zlib.call(this, opts, binding.INFLATE);\n}\n\n\n\n// gzip - bigger header, same deflate compression\nfunction Gzip(opts) {\n  if (!(this instanceof Gzip)) return new Gzip(opts);\n  Zlib.call(this, opts, binding.GZIP);\n}\n\nfunction Gunzip(opts) {\n  if (!(this instanceof Gunzip)) return new Gunzip(opts);\n  Zlib.call(this, opts, binding.GUNZIP);\n}\n\n\n\n// raw - no header\nfunction DeflateRaw(opts) {\n  if (!(this instanceof DeflateRaw)) return new DeflateRaw(opts);\n  Zlib.call(this, opts, binding.DEFLATERAW);\n}\n\nfunction InflateRaw(opts) {\n  if (!(this instanceof InflateRaw)) return new InflateRaw(opts);\n  Zlib.call(this, opts, binding.INFLATERAW);\n}\n\n\n// auto-detect header.\nfunction Unzip(opts) {\n  if (!(this instanceof Unzip)) return new Unzip(opts);\n  Zlib.call(this, opts, binding.UNZIP);\n}\n\n\n// the Zlib class they all inherit from\n// This thing manages the queue of requests, and returns\n// true or false if there is anything in the queue when\n// you call the .write() method.\n\nfunction Zlib(opts, mode) {\n  this._opts = opts = opts || {};\n  this._chunkSize = opts.chunkSize || exports.Z_DEFAULT_CHUNK;\n\n  Transform.call(this, opts);\n\n  if (opts.flush) {\n    if (opts.flush !== binding.Z_NO_FLUSH &&\n        opts.flush !== binding.Z_PARTIAL_FLUSH &&\n        opts.flush !== binding.Z_SYNC_FLUSH &&\n        opts.flush !== binding.Z_FULL_FLUSH &&\n        opts.flush !== binding.Z_FINISH &&\n        opts.flush !== binding.Z_BLOCK) {\n      throw new Error('Invalid flush flag: ' + opts.flush);\n    }\n  }\n  this._flushFlag = opts.flush || binding.Z_NO_FLUSH;\n\n  if (opts.chunkSize) {\n    if (opts.chunkSize < exports.Z_MIN_CHUNK ||\n        opts.chunkSize > exports.Z_MAX_CHUNK) {\n      throw new Error('Invalid chunk size: ' + opts.chunkSize);\n    }\n  }\n\n  if (opts.windowBits) {\n    if (opts.windowBits < exports.Z_MIN_WINDOWBITS ||\n        opts.windowBits > exports.Z_MAX_WINDOWBITS) {\n      throw new Error('Invalid windowBits: ' + opts.windowBits);\n    }\n  }\n\n  if (opts.level) {\n    if (opts.level < exports.Z_MIN_LEVEL ||\n        opts.level > exports.Z_MAX_LEVEL) {\n      throw new Error('Invalid compression level: ' + opts.level);\n    }\n  }\n\n  if (opts.memLevel) {\n    if (opts.memLevel < exports.Z_MIN_MEMLEVEL ||\n        opts.memLevel > exports.Z_MAX_MEMLEVEL) {\n      throw new Error('Invalid memLevel: ' + opts.memLevel);\n    }\n  }\n\n  if (opts.strategy) {\n    if (opts.strategy != exports.Z_FILTERED &&\n        opts.strategy != exports.Z_HUFFMAN_ONLY &&\n        opts.strategy != exports.Z_RLE &&\n        opts.strategy != exports.Z_FIXED &&\n        opts.strategy != exports.Z_DEFAULT_STRATEGY) {\n      throw new Error('Invalid strategy: ' + opts.strategy);\n    }\n  }\n\n  if (opts.dictionary) {\n    if (!Buffer.isBuffer(opts.dictionary)) {\n      throw new Error('Invalid dictionary: it should be a Buffer instance');\n    }\n  }\n\n  this._binding = new binding.Zlib(mode);\n\n  var self = this;\n  this._hadError = false;\n  this._binding.onerror = function(message, errno) {\n    // there is no way to cleanly recover.\n    // continuing only obscures problems.\n    self._binding = null;\n    self._hadError = true;\n\n    var error = new Error(message);\n    error.errno = errno;\n    error.code = exports.codes[errno];\n    self.emit('error', error);\n  };\n\n  var level = exports.Z_DEFAULT_COMPRESSION;\n  if (typeof opts.level === 'number') level = opts.level;\n\n  var strategy = exports.Z_DEFAULT_STRATEGY;\n  if (typeof opts.strategy === 'number') strategy = opts.strategy;\n\n  this._binding.init(opts.windowBits || exports.Z_DEFAULT_WINDOWBITS,\n                     level,\n                     opts.memLevel || exports.Z_DEFAULT_MEMLEVEL,\n                     strategy,\n                     opts.dictionary);\n\n  this._buffer = new Buffer(this._chunkSize);\n  this._offset = 0;\n  this._closed = false;\n  this._level = level;\n  this._strategy = strategy;\n\n  this.once('end', this.close);\n}\n\nutil.inherits(Zlib, Transform);\n\nZlib.prototype.params = function(level, strategy, callback) {\n  if (level < exports.Z_MIN_LEVEL ||\n      level > exports.Z_MAX_LEVEL) {\n    throw new RangeError('Invalid compression level: ' + level);\n  }\n  if (strategy != exports.Z_FILTERED &&\n      strategy != exports.Z_HUFFMAN_ONLY &&\n      strategy != exports.Z_RLE &&\n      strategy != exports.Z_FIXED &&\n      strategy != exports.Z_DEFAULT_STRATEGY) {\n    throw new TypeError('Invalid strategy: ' + strategy);\n  }\n\n  if (this._level !== level || this._strategy !== strategy) {\n    var self = this;\n    this.flush(binding.Z_SYNC_FLUSH, function() {\n      self._binding.params(level, strategy);\n      if (!self._hadError) {\n        self._level = level;\n        self._strategy = strategy;\n        if (callback) callback();\n      }\n    });\n  } else {\n    process.nextTick(callback);\n  }\n};\n\nZlib.prototype.reset = function() {\n  return this._binding.reset();\n};\n\n// This is the _flush function called by the transform class,\n// internally, when the last chunk has been written.\nZlib.prototype._flush = function(callback) {\n  this._transform(new Buffer(0), '', callback);\n};\n\nZlib.prototype.flush = function(kind, callback) {\n  var ws = this._writableState;\n\n  if (typeof kind === 'function' || (kind === void 0 && !callback)) {\n    callback = kind;\n    kind = binding.Z_FULL_FLUSH;\n  }\n\n  if (ws.ended) {\n    if (callback)\n      process.nextTick(callback);\n  } else if (ws.ending) {\n    if (callback)\n      this.once('end', callback);\n  } else if (ws.needDrain) {\n    var self = this;\n    this.once('drain', function() {\n      self.flush(callback);\n    });\n  } else {\n    this._flushFlag = kind;\n    this.write(new Buffer(0), '', callback);\n  }\n};\n\nZlib.prototype.close = function(callback) {\n  if (callback)\n    process.nextTick(callback);\n\n  if (this._closed)\n    return;\n\n  this._closed = true;\n\n  this._binding.close();\n\n  var self = this;\n  process.nextTick(function() {\n    self.emit('close');\n  });\n};\n\nZlib.prototype._transform = function(chunk, encoding, cb) {\n  var flushFlag;\n  var ws = this._writableState;\n  var ending = ws.ending || ws.ended;\n  var last = ending && (!chunk || ws.length === chunk.length);\n\n  if (!chunk === null && !Buffer.isBuffer(chunk))\n    return cb(new Error('invalid input'));\n\n  // If it's the last chunk, or a final flush, we use the Z_FINISH flush flag.\n  // If it's explicitly flushing at some other time, then we use\n  // Z_FULL_FLUSH. Otherwise, use Z_NO_FLUSH for maximum compression\n  // goodness.\n  if (last)\n    flushFlag = binding.Z_FINISH;\n  else {\n    flushFlag = this._flushFlag;\n    // once we've flushed the last of the queue, stop flushing and\n    // go back to the normal behavior.\n    if (chunk.length >= ws.length) {\n      this._flushFlag = this._opts.flush || binding.Z_NO_FLUSH;\n    }\n  }\n\n  var self = this;\n  this._processChunk(chunk, flushFlag, cb);\n};\n\nZlib.prototype._processChunk = function(chunk, flushFlag, cb) {\n  var availInBefore = chunk && chunk.length;\n  var availOutBefore = this._chunkSize - this._offset;\n  var inOff = 0;\n\n  var self = this;\n\n  var async = typeof cb === 'function';\n\n  if (!async) {\n    var buffers = [];\n    var nread = 0;\n\n    var error;\n    this.on('error', function(er) {\n      error = er;\n    });\n\n    do {\n      var res = this._binding.writeSync(flushFlag,\n                                        chunk, // in\n                                        inOff, // in_off\n                                        availInBefore, // in_len\n                                        this._buffer, // out\n                                        this._offset, //out_off\n                                        availOutBefore); // out_len\n    } while (!this._hadError && callback(res[0], res[1]));\n\n    if (this._hadError) {\n      throw error;\n    }\n\n    var buf = Buffer.concat(buffers, nread);\n    this.close();\n\n    return buf;\n  }\n\n  var req = this._binding.write(flushFlag,\n                                chunk, // in\n                                inOff, // in_off\n                                availInBefore, // in_len\n                                this._buffer, // out\n                                this._offset, //out_off\n                                availOutBefore); // out_len\n\n  req.buffer = chunk;\n  req.callback = callback;\n\n  function callback(availInAfter, availOutAfter) {\n    if (self._hadError)\n      return;\n\n    var have = availOutBefore - availOutAfter;\n    assert(have >= 0, 'have should not go down');\n\n    if (have > 0) {\n      var out = self._buffer.slice(self._offset, self._offset + have);\n      self._offset += have;\n      // serve some output to the consumer.\n      if (async) {\n        self.push(out);\n      } else {\n        buffers.push(out);\n        nread += out.length;\n      }\n    }\n\n    // exhausted the output buffer, or used all the input create a new one.\n    if (availOutAfter === 0 || self._offset >= self._chunkSize) {\n      availOutBefore = self._chunkSize;\n      self._offset = 0;\n      self._buffer = new Buffer(self._chunkSize);\n    }\n\n    if (availOutAfter === 0) {\n      // Not actually done.  Need to reprocess.\n      // Also, update the availInBefore to the availInAfter value,\n      // so that if we have to hit it a third (fourth, etc.) time,\n      // it'll have the correct byte counts.\n      inOff += (availInBefore - availInAfter);\n      availInBefore = availInAfter;\n\n      if (!async)\n        return true;\n\n      var newReq = self._binding.write(flushFlag,\n                                       chunk,\n                                       inOff,\n                                       availInBefore,\n                                       self._buffer,\n                                       self._offset,\n                                       self._chunkSize);\n      newReq.callback = callback; // this same function\n      newReq.buffer = chunk;\n      return;\n    }\n\n    if (!async)\n      return false;\n\n    // finished with the chunk.\n    cb();\n  }\n};\n\nutil.inherits(Deflate, Zlib);\nutil.inherits(Inflate, Zlib);\nutil.inherits(Gzip, Zlib);\nutil.inherits(Gunzip, Zlib);\nutil.inherits(DeflateRaw, Zlib);\nutil.inherits(InflateRaw, Zlib);\nutil.inherits(Unzip, Zlib);\n"]},"metadata":{},"sourceType":"script"}