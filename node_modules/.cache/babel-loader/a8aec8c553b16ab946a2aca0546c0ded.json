{"ast":null,"code":"var acorn = require('acorn');\n\nvar walk = require('acorn/dist/walk');\n\nvar defined = require('defined');\n\nvar requireRe = /\\brequire\\b/;\n\nfunction parse(src, opts) {\n  if (!opts) opts = {};\n  return acorn.parse(src, {\n    ecmaVersion: defined(opts.ecmaVersion, 9),\n    sourceType: opts.sourceType,\n    ranges: defined(opts.ranges, opts.range),\n    locations: defined(opts.locations, opts.loc),\n    allowReserved: defined(opts.allowReserved, true),\n    allowReturnOutsideFunction: defined(opts.allowReturnOutsideFunction, true),\n    allowImportExportEverywhere: defined(opts.allowImportExportEverywhere, true),\n    allowHashBang: defined(opts.allowHashBang, true)\n  });\n}\n\nvar exports = module.exports = function (src, opts) {\n  return exports.find(src, opts).strings;\n};\n\nexports.find = function (src, opts) {\n  if (!opts) opts = {};\n  var word = opts.word === undefined ? 'require' : opts.word;\n  if (typeof src !== 'string') src = String(src);\n\n  var isRequire = opts.isRequire || function (node) {\n    return node.callee.type === 'Identifier' && node.callee.name === word;\n  };\n\n  var modules = {\n    strings: [],\n    expressions: []\n  };\n  if (opts.nodes) modules.nodes = [];\n  var wordRe = word === 'require' ? requireRe : RegExp('\\\\b' + word + '\\\\b');\n  if (!wordRe.test(src)) return modules;\n  var ast = parse(src, opts.parse);\n\n  function visit(node, st, c) {\n    var hasRequire = wordRe.test(src.slice(node.start, node.end));\n    if (!hasRequire) return;\n    walk.base[node.type](node, st, c);\n    if (node.type !== 'CallExpression') return;\n\n    if (isRequire(node)) {\n      if (node.arguments.length) {\n        var arg = node.arguments[0];\n\n        if (arg.type === 'Literal') {\n          modules.strings.push(arg.value);\n        } else if (arg.type === 'TemplateLiteral' && arg.quasis.length === 1 && arg.expressions.length === 0) {\n          modules.strings.push(arg.quasis[0].value.raw);\n        } else {\n          modules.expressions.push(src.slice(arg.start, arg.end));\n        }\n      }\n\n      if (opts.nodes) modules.nodes.push(node);\n    }\n  }\n\n  walk.recursive(ast, null, {\n    Statement: visit,\n    Expression: visit\n  });\n  return modules;\n};","map":{"version":3,"sources":["/home/yanxiaoyang/react-project/PersonalWebsiteTest/node_modules/detective/index.js"],"names":["acorn","require","walk","defined","requireRe","parse","src","opts","ecmaVersion","sourceType","ranges","range","locations","loc","allowReserved","allowReturnOutsideFunction","allowImportExportEverywhere","allowHashBang","exports","module","find","strings","word","undefined","String","isRequire","node","callee","type","name","modules","expressions","nodes","wordRe","RegExp","test","ast","visit","st","c","hasRequire","slice","start","end","base","arguments","length","arg","push","value","quasis","raw","recursive","Statement","Expression"],"mappings":"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","sourcesContent":["var acorn = require('acorn');\nvar walk = require('acorn/dist/walk');\nvar defined = require('defined');\n\nvar requireRe = /\\brequire\\b/;\n\nfunction parse (src, opts) {\n    if (!opts) opts = {};\n    return acorn.parse(src, {\n        ecmaVersion: defined(opts.ecmaVersion, 9),\n        sourceType: opts.sourceType,\n        ranges: defined(opts.ranges, opts.range),\n        locations: defined(opts.locations, opts.loc),\n        allowReserved: defined(opts.allowReserved, true),\n        allowReturnOutsideFunction: defined(\n            opts.allowReturnOutsideFunction, true\n        ),\n        allowImportExportEverywhere: defined(\n            opts.allowImportExportEverywhere, true\n        ),\n        allowHashBang: defined(opts.allowHashBang, true)\n    });\n}\n\nvar exports = module.exports = function (src, opts) {\n    return exports.find(src, opts).strings;\n};\n\nexports.find = function (src, opts) {\n    if (!opts) opts = {};\n    \n    var word = opts.word === undefined ? 'require' : opts.word;\n    if (typeof src !== 'string') src = String(src);\n    \n    var isRequire = opts.isRequire || function (node) {\n        return node.callee.type === 'Identifier'\n            && node.callee.name === word\n        ;\n    };\n    \n    var modules = { strings : [], expressions : [] };\n    if (opts.nodes) modules.nodes = [];\n    \n    var wordRe = word === 'require' ? requireRe : RegExp('\\\\b' + word + '\\\\b');\n    if (!wordRe.test(src)) return modules;\n    \n    var ast = parse(src, opts.parse);\n    \n    function visit(node, st, c) {\n        var hasRequire = wordRe.test(src.slice(node.start, node.end));\n        if (!hasRequire) return;\n        walk.base[node.type](node, st, c);\n        if (node.type !== 'CallExpression') return;\n        if (isRequire(node)) {\n            if (node.arguments.length) {\n                var arg = node.arguments[0];\n                if (arg.type === 'Literal') {\n                    modules.strings.push(arg.value);\n                }\n                else if (arg.type === 'TemplateLiteral'\n                        && arg.quasis.length === 1\n                        && arg.expressions.length === 0) {\n\n                    modules.strings.push(arg.quasis[0].value.raw);\n                }\n                else {\n                    modules.expressions.push(src.slice(arg.start, arg.end));\n                }\n            }\n            if (opts.nodes) modules.nodes.push(node);\n        }\n    }\n    \n    walk.recursive(ast, null, {\n        Statement: visit,\n        Expression: visit\n    });\n    \n    return modules;\n};\n"]},"metadata":{},"sourceType":"script"}