{"ast":null,"code":"/**\r\n * node-compress-commons\r\n *\r\n * Copyright (c) 2014 Chris Talkington, contributors.\r\n * Licensed under the MIT license.\r\n * https://github.com/archiverjs/node-compress-commons/blob/master/LICENSE-MIT\r\n */\nvar inherits = require('util').inherits;\n\nvar Transform = require('readable-stream').Transform;\n\nvar ArchiveEntry = require('./archive-entry');\n\nvar util = require('../util');\n\nvar ArchiveOutputStream = module.exports = function (options) {\n  if (!(this instanceof ArchiveOutputStream)) {\n    return new ArchiveOutputStream(options);\n  }\n\n  Transform.call(this, options);\n  this.offset = 0;\n  this._archive = {\n    finish: false,\n    finished: false,\n    processing: false\n  };\n};\n\ninherits(ArchiveOutputStream, Transform);\n\nArchiveOutputStream.prototype._appendBuffer = function (zae, source, callback) {// scaffold only\n};\n\nArchiveOutputStream.prototype._appendStream = function (zae, source, callback) {// scaffold only\n};\n\nArchiveOutputStream.prototype._emitErrorCallback = function (err) {\n  if (err) {\n    this.emit('error', err);\n  }\n};\n\nArchiveOutputStream.prototype._finish = function (ae) {// scaffold only\n};\n\nArchiveOutputStream.prototype._normalizeEntry = function (ae) {// scaffold only\n};\n\nArchiveOutputStream.prototype._transform = function (chunk, encoding, callback) {\n  callback(null, chunk);\n};\n\nArchiveOutputStream.prototype.entry = function (ae, source, callback) {\n  source = source || null;\n\n  if (typeof callback !== 'function') {\n    callback = this._emitErrorCallback.bind(this);\n  }\n\n  if (!(ae instanceof ArchiveEntry)) {\n    callback(new Error('not a valid instance of ArchiveEntry'));\n    return;\n  }\n\n  if (this._archive.finish || this._archive.finished) {\n    callback(new Error('unacceptable entry after finish'));\n    return;\n  }\n\n  if (this._archive.processing) {\n    callback(new Error('already processing an entry'));\n    return;\n  }\n\n  this._archive.processing = true;\n\n  this._normalizeEntry(ae);\n\n  this._entry = ae;\n  source = util.normalizeInputSource(source);\n\n  if (Buffer.isBuffer(source)) {\n    this._appendBuffer(ae, source, callback);\n  } else if (util.isStream(source)) {\n    this._appendStream(ae, source, callback);\n  } else {\n    this._archive.processing = false;\n    callback(new Error('input source must be valid Stream or Buffer instance'));\n    return;\n  }\n\n  return this;\n};\n\nArchiveOutputStream.prototype.finish = function () {\n  if (this._archive.processing) {\n    this._archive.finish = true;\n    return;\n  }\n\n  this._finish();\n};\n\nArchiveOutputStream.prototype.getBytesWritten = function () {\n  return this.offset;\n};\n\nArchiveOutputStream.prototype.write = function (chunk, cb) {\n  if (chunk) {\n    this.offset += chunk.length;\n  }\n\n  return Transform.prototype.write.call(this, chunk, cb);\n};","map":{"version":3,"sources":["/home/yanxiaoyang/react-project/PersonalWebsiteTest/node_modules/compress-commons/lib/archivers/archive-output-stream.js"],"names":["inherits","require","Transform","ArchiveEntry","util","ArchiveOutputStream","module","exports","options","call","offset","_archive","finish","finished","processing","prototype","_appendBuffer","zae","source","callback","_appendStream","_emitErrorCallback","err","emit","_finish","ae","_normalizeEntry","_transform","chunk","encoding","entry","bind","Error","_entry","normalizeInputSource","Buffer","isBuffer","isStream","getBytesWritten","write","cb","length"],"mappings":"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","sourcesContent":["/**\r\n * node-compress-commons\r\n *\r\n * Copyright (c) 2014 Chris Talkington, contributors.\r\n * Licensed under the MIT license.\r\n * https://github.com/archiverjs/node-compress-commons/blob/master/LICENSE-MIT\r\n */\r\nvar inherits = require('util').inherits;\r\nvar Transform = require('readable-stream').Transform;\r\n\r\nvar ArchiveEntry = require('./archive-entry');\r\nvar util = require('../util');\r\n\r\nvar ArchiveOutputStream = module.exports = function(options) {\r\n  if (!(this instanceof ArchiveOutputStream)) {\r\n    return new ArchiveOutputStream(options);\r\n  }\r\n\r\n  Transform.call(this, options);\r\n\r\n  this.offset = 0;\r\n  this._archive = {\r\n    finish: false,\r\n    finished: false,\r\n    processing: false\r\n  };\r\n};\r\n\r\ninherits(ArchiveOutputStream, Transform);\r\n\r\nArchiveOutputStream.prototype._appendBuffer = function(zae, source, callback) {\r\n  // scaffold only\r\n};\r\n\r\nArchiveOutputStream.prototype._appendStream = function(zae, source, callback) {\r\n  // scaffold only\r\n};\r\n\r\nArchiveOutputStream.prototype._emitErrorCallback = function(err) {\r\n  if (err) {\r\n    this.emit('error', err);\r\n  }\r\n};\r\n\r\nArchiveOutputStream.prototype._finish = function(ae) {\r\n  // scaffold only\r\n};\r\n\r\nArchiveOutputStream.prototype._normalizeEntry = function(ae) {\r\n  // scaffold only\r\n};\r\n\r\nArchiveOutputStream.prototype._transform = function(chunk, encoding, callback) {\r\n  callback(null, chunk);\r\n};\r\n\r\nArchiveOutputStream.prototype.entry = function(ae, source, callback) {\r\n  source = source || null;\r\n\r\n  if (typeof callback !== 'function') {\r\n    callback = this._emitErrorCallback.bind(this);\r\n  }\r\n\r\n  if (!(ae instanceof ArchiveEntry)) {\r\n    callback(new Error('not a valid instance of ArchiveEntry'));\r\n    return;\r\n  }\r\n\r\n  if (this._archive.finish || this._archive.finished) {\r\n    callback(new Error('unacceptable entry after finish'));\r\n    return;\r\n  }\r\n\r\n  if (this._archive.processing) {\r\n    callback(new Error('already processing an entry'));\r\n    return;\r\n  }\r\n\r\n  this._archive.processing = true;\r\n  this._normalizeEntry(ae);\r\n  this._entry = ae;\r\n\r\n  source = util.normalizeInputSource(source);\r\n\r\n  if (Buffer.isBuffer(source)) {\r\n    this._appendBuffer(ae, source, callback);\r\n  } else if (util.isStream(source)) {\r\n    this._appendStream(ae, source, callback);\r\n  } else {\r\n    this._archive.processing = false;\r\n    callback(new Error('input source must be valid Stream or Buffer instance'));\r\n    return;\r\n  }\r\n\r\n  return this;\r\n};\r\n\r\nArchiveOutputStream.prototype.finish = function() {\r\n  if (this._archive.processing) {\r\n    this._archive.finish = true;\r\n    return;\r\n  }\r\n\r\n  this._finish();\r\n};\r\n\r\nArchiveOutputStream.prototype.getBytesWritten = function() {\r\n  return this.offset;\r\n};\r\n\r\nArchiveOutputStream.prototype.write = function(chunk, cb) {\r\n  if (chunk) {\r\n    this.offset += chunk.length;\r\n  }\r\n\r\n  return Transform.prototype.write.call(this, chunk, cb);\r\n};"]},"metadata":{},"sourceType":"script"}