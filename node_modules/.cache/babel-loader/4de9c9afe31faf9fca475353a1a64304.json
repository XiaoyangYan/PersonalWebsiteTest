{"ast":null,"code":"// -------------------------------------------\n// Loads resources from the /resources folder\n// -------------------------------------------\n// TODO: rename loader\nmodule.exports = function loader(ripple, {\n  dir = '.',\n  watch = isNonProd(),\n  pattern = '/**/!(*test).{css,js}',\n  autoload = 'resources',\n  autolink = '/resources/components/**/!(*test).{css,js}',\n  aliases = {}\n} = {}) {\n  log('creating', {\n    watch\n  });\n  glob(autolink, {\n    root: dir\n  }).map(path => ripple.link(rel(dir, path), rtype(ripple, path).shortname(path)));\n\n  const _require = require('minimist')(process.argv.slice(2)),\n        _require$r = _require.r,\n        r = _require$r === void 0 ? '' : _require$r,\n        _require$resdirs = _require.resdirs,\n        resdirs = _require$resdirs === void 0 ? r : _require$resdirs,\n        load = register(ripple, dir),\n        folders = resdirs.split(',').concat(resolve(dir, autoload)).filter(Boolean).map(d => resolve(d)).map(append(pattern));\n\n  ripple.watcher = chokidar.watch(folders, {\n    ignored: /\\b_/\n  }).on('error', err).on('add', load).on('change', load).on('ready', async () => {\n    if (!watch) ripple.watcher.close();\n    await Promise.all(values(ripple.resources).map(res => res.headers.loading)).catch(err);\n    def(ripple, 'ready', true);\n    ripple.emit('ready');\n  });\n\n  ripple.load = (name, alias) => {\n    if (ripple.resources[name]) return ripple.resources[name];\n    const path = bresolve(ripple.aliases.dst[name] || name, resolve(dir, 'foo')),\n          canonical = rel(dir, path);\n\n    if (alias) {\n      ripple.link(canonical, alias);\n    } else if (!ripple.aliases.dst[name] && name != canonical) {\n      ripple.link(name, canonical);\n    }\n\n    return load(path);\n  }; // TODO: move back to core as chainable \n\n\n  ripple.resource = (name, body, headers) => {\n    // is.str(body)\n    //   ? ripple.load(body, name)\n    ripple(name, body, headers);\n    return ripple;\n  };\n\n  return ripple;\n};\n\nconst register = (ripple, dir) => path => {\n  const type = rtype(ripple, path);\n  if (!exists(path)) throw new Error(`no such resource at ${path}`);\n  if (!type) throw new Error(`could not understand how to load resource at ${path}`); // TODO: should probably let loaders do this\n\n  delete require.cache[path];\n  return type.load({\n    name: rel(dir, path),\n    headers: {\n      path\n    }\n  });\n};\n\nconst rtype = (ripple, path) => values(ripple.types).filter(d => d.ext).sort(za('ext.length')).find(({\n  ext\n}) => minimatch(basename(path), ext));\n\nconst rel = (dir, path) => './' + relative(dir, path).replace(/\\\\/g, '/');\n\nconst bresolve = (module, parent) => require('browser-resolve').sync(module, {\n  filename: parent\n});\n\nfunction isNonProd() {\n  return lo(process.env.NODE_ENV) != 'prod' && lo(process.env.NODE_ENV) != 'production';\n}\n\nconst _require2 = require('path'),\n      resolve = _require2.resolve,\n      relative = _require2.relative,\n      basename = _require2.basename,\n      exists = require('fs').existsSync,\n      glob = require('glob').sync,\n      chokidar = require('chokidar'),\n      append = require('utilise/append'),\n      values = require('utilise/values'),\n      keys = require('utilise/keys'),\n      def = require('utilise/def'),\n      key = require('utilise/key'),\n      is = require('utilise/is'),\n      lo = require('utilise/lo'),\n      by = require('utilise/by'),\n      za = require('utilise/za'),\n      log = require('utilise/log')('[ri/resdir]'),\n      err = require('utilise/err')('[ri/resdir]'),\n      minimatch = require('minimatch'),\n      extname = path => [''].concat(path.split('.').slice(1)).join('.');","map":{"version":3,"sources":["/home/yanxiaoyang/react-project/PersonalWebsiteTest/node_modules/rijs.resdir/index.js"],"names":["module","exports","loader","ripple","dir","watch","isNonProd","pattern","autoload","autolink","aliases","log","glob","root","map","path","link","rel","rtype","shortname","require","process","argv","slice","r","resdirs","load","register","folders","split","concat","resolve","filter","Boolean","d","append","watcher","chokidar","ignored","on","err","close","Promise","all","values","resources","res","headers","loading","catch","def","emit","name","alias","bresolve","dst","canonical","resource","body","type","exists","Error","cache","types","ext","sort","za","find","minimatch","basename","relative","replace","parent","sync","filename","lo","env","NODE_ENV","existsSync","keys","key","is","by","extname","join"],"mappings":"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","sourcesContent":["// -------------------------------------------\r\n// Loads resources from the /resources folder\r\n// -------------------------------------------\r\n// TODO: rename loader\r\nmodule.exports = function loader(ripple, {\r\n  dir = '.'\r\n, watch = isNonProd()\r\n, pattern = '/**/!(*test).{css,js}'\r\n, autoload = 'resources'\r\n, autolink = '/resources/components/**/!(*test).{css,js}'\r\n, aliases = {}\r\n} = {}){\r\n  log('creating', { watch })\r\n  \r\n  glob(autolink, { root: dir })\r\n    .map(path => ripple.link(rel(dir, path), rtype(ripple, path).shortname(path)))\r\n\r\n  const { r = '', resdirs = r } = require('minimist')(process.argv.slice(2))\r\n      , load = register(ripple, dir)\r\n      , folders = resdirs\r\n          .split(',')\r\n          .concat(resolve(dir, autoload))\r\n          .filter(Boolean)\r\n          .map(d => resolve(d))\r\n          .map(append(pattern))\r\n\r\n  ripple.watcher = chokidar.watch(folders, { ignored: /\\b_/ })\r\n    .on('error', err)\r\n    .on('add', load)\r\n    .on('change', load)\r\n    .on('ready', async () => {\r\n      if (!watch) ripple.watcher.close()\r\n      \r\n      await Promise.all(values(ripple.resources)\r\n        .map(res => res.headers.loading))\r\n        .catch(err)\r\n\r\n      def(ripple, 'ready', true)\r\n      ripple.emit('ready')\r\n    })\r\n\r\n  ripple.load = (name, alias) => {\r\n    if (ripple.resources[name])\r\n      return ripple.resources[name]\r\n\r\n    const path = bresolve(ripple.aliases.dst[name] || name, resolve(dir, 'foo'))\r\n        , canonical = rel(dir, path)\r\n\r\n    if (alias) {\r\n      ripple.link(canonical, alias)\r\n    } else if (!ripple.aliases.dst[name] && name != canonical) {\r\n      ripple.link(name, canonical)\r\n    }\r\n    \r\n    return load(path)\r\n  }\r\n\r\n  // TODO: move back to core as chainable \r\n  ripple.resource = (name, body, headers) => {\r\n    // is.str(body)\r\n    //   ? ripple.load(body, name)\r\n    ripple(name, body, headers)\r\n    return ripple\r\n  }\r\n\r\n  return ripple\r\n}\r\n\r\nconst register = (ripple, dir) => path => {\r\n  const type = rtype(ripple, path)\r\n\r\n  if (!exists(path)) \r\n    throw new Error(`no such resource at ${path}`)\r\n  if (!type)\r\n    throw new Error(`could not understand how to load resource at ${path}`)\r\n\r\n  // TODO: should probably let loaders do this\r\n  delete require.cache[path]\r\n\r\n  return type.load({ \r\n    name: rel(dir, path)\r\n  , headers: { path } \r\n  })\r\n}\r\n\r\nconst rtype = (ripple, path) => values(ripple.types)\r\n  .filter(d => d.ext)\r\n  .sort(za('ext.length'))\r\n  .find(({ ext }) => minimatch(basename(path), ext))\r\n\r\nconst rel = (dir, path) => './' + relative(dir, path).replace(/\\\\/g, '/')\r\n\r\nconst bresolve = (module, parent) => require('browser-resolve').sync(module, { filename: parent })\r\n\r\nfunction isNonProd(){\r\n  return lo(process.env.NODE_ENV) != 'prod' && lo(process.env.NODE_ENV) != 'production'\r\n}\r\n\r\nconst { resolve, relative, basename } = require('path')\r\n    , exists = require('fs').existsSync\r\n    , glob = require('glob').sync\r\n    , chokidar = require('chokidar')\r\n    , append = require('utilise/append')\r\n    , values = require('utilise/values')\r\n    , keys = require('utilise/keys')\r\n    , def = require('utilise/def')\r\n    , key = require('utilise/key')\r\n    , is = require('utilise/is')\r\n    , lo = require('utilise/lo')\r\n    , by = require('utilise/by')\r\n    , za = require('utilise/za')\r\n    , log = require('utilise/log')('[ri/resdir]')\r\n    , err = require('utilise/err')('[ri/resdir]')\r\n    , minimatch = require('minimatch')\r\n    , extname = path => [''].concat(path.split('.').slice(1)).join('.')"]},"metadata":{},"sourceType":"script"}