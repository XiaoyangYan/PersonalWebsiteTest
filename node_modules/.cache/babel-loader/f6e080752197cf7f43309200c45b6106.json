{"ast":null,"code":"/*!\n * micromatch <https://github.com/jonschlinkert/micromatch>\n *\n * Copyright (c) 2014-2015, Jon Schlinkert.\n * Licensed under the MIT License.\n */\n'use strict';\n\nvar expand = require('./lib/expand');\n\nvar utils = require('./lib/utils');\n/**\n * The main function. Pass an array of filepaths,\n * and a string or array of glob patterns\n *\n * @param  {Array|String} `files`\n * @param  {Array|String} `patterns`\n * @param  {Object} `opts`\n * @return {Array} Array of matches\n */\n\n\nfunction micromatch(files, patterns, opts) {\n  if (!files || !patterns) return [];\n  opts = opts || {};\n\n  if (typeof opts.cache === 'undefined') {\n    opts.cache = true;\n  }\n\n  if (!Array.isArray(patterns)) {\n    return match(files, patterns, opts);\n  }\n\n  var len = patterns.length,\n      i = 0;\n  var omit = [],\n      keep = [];\n\n  while (len--) {\n    var glob = patterns[i++];\n\n    if (typeof glob === 'string' && glob.charCodeAt(0) === 33\n    /* ! */\n    ) {\n        omit.push.apply(omit, match(files, glob.slice(1), opts));\n      } else {\n      keep.push.apply(keep, match(files, glob, opts));\n    }\n  }\n\n  return utils.diff(keep, omit);\n}\n/**\n * Return an array of files that match the given glob pattern.\n *\n * This function is called by the main `micromatch` function If you only\n * need to pass a single pattern you might get very minor speed improvements\n * using this function.\n *\n * @param  {Array} `files`\n * @param  {String} `pattern`\n * @param  {Object} `options`\n * @return {Array}\n */\n\n\nfunction match(files, pattern, opts) {\n  if (utils.typeOf(files) !== 'string' && !Array.isArray(files)) {\n    throw new Error(msg('match', 'files', 'a string or array'));\n  }\n\n  files = utils.arrayify(files);\n  opts = opts || {};\n  var negate = opts.negate || false;\n  var orig = pattern;\n\n  if (typeof pattern === 'string') {\n    negate = pattern.charAt(0) === '!';\n\n    if (negate) {\n      pattern = pattern.slice(1);\n    } // we need to remove the character regardless,\n    // so the above logic is still needed\n\n\n    if (opts.nonegate === true) {\n      negate = false;\n    }\n  }\n\n  var _isMatch = matcher(pattern, opts);\n\n  var len = files.length,\n      i = 0;\n  var res = [];\n\n  while (i < len) {\n    var file = files[i++];\n    var fp = utils.unixify(file, opts);\n\n    if (!_isMatch(fp)) {\n      continue;\n    }\n\n    res.push(fp);\n  }\n\n  if (res.length === 0) {\n    if (opts.failglob === true) {\n      throw new Error('micromatch.match() found no matches for: \"' + orig + '\".');\n    }\n\n    if (opts.nonull || opts.nullglob) {\n      res.push(utils.unescapeGlob(orig));\n    }\n  } // if `negate` was defined, diff negated files\n\n\n  if (negate) {\n    res = utils.diff(files, res);\n  } // if `ignore` was defined, diff ignored filed\n\n\n  if (opts.ignore && opts.ignore.length) {\n    pattern = opts.ignore;\n    opts = utils.omit(opts, ['ignore']);\n    res = utils.diff(res, micromatch(res, pattern, opts));\n  }\n\n  if (opts.nodupes) {\n    return utils.unique(res);\n  }\n\n  return res;\n}\n/**\n * Returns a function that takes a glob pattern or array of glob patterns\n * to be used with `Array#filter()`. (Internally this function generates\n * the matching function using the [matcher] method).\n *\n * ```js\n * var fn = mm.filter('[a-c]');\n * ['a', 'b', 'c', 'd', 'e'].filter(fn);\n * //=> ['a', 'b', 'c']\n * ```\n * @param  {String|Array} `patterns` Can be a glob or array of globs.\n * @param  {Options} `opts` Options to pass to the [matcher] method.\n * @return {Function} Filter function to be passed to `Array#filter()`.\n */\n\n\nfunction filter(patterns, opts) {\n  if (!Array.isArray(patterns) && typeof patterns !== 'string') {\n    throw new TypeError(msg('filter', 'patterns', 'a string or array'));\n  }\n\n  patterns = utils.arrayify(patterns);\n  var len = patterns.length,\n      i = 0;\n  var patternMatchers = Array(len);\n\n  while (i < len) {\n    patternMatchers[i] = matcher(patterns[i++], opts);\n  }\n\n  return function (fp) {\n    if (fp == null) return [];\n    var len = patternMatchers.length,\n        i = 0;\n    var res = true;\n    fp = utils.unixify(fp, opts);\n\n    while (i < len) {\n      var fn = patternMatchers[i++];\n\n      if (!fn(fp)) {\n        res = false;\n        break;\n      }\n    }\n\n    return res;\n  };\n}\n/**\n * Returns true if the filepath contains the given\n * pattern. Can also return a function for matching.\n *\n * ```js\n * isMatch('foo.md', '*.md', {});\n * //=> true\n *\n * isMatch('*.md', {})('foo.md')\n * //=> true\n * ```\n * @param  {String} `fp`\n * @param  {String} `pattern`\n * @param  {Object} `opts`\n * @return {Boolean}\n */\n\n\nfunction isMatch(fp, pattern, opts) {\n  if (typeof fp !== 'string') {\n    throw new TypeError(msg('isMatch', 'filepath', 'a string'));\n  }\n\n  fp = utils.unixify(fp, opts);\n\n  if (utils.typeOf(pattern) === 'object') {\n    return matcher(fp, pattern);\n  }\n\n  return matcher(pattern, opts)(fp);\n}\n/**\n * Returns true if the filepath matches the\n * given pattern.\n */\n\n\nfunction contains(fp, pattern, opts) {\n  if (typeof fp !== 'string') {\n    throw new TypeError(msg('contains', 'pattern', 'a string'));\n  }\n\n  opts = opts || {};\n  opts.contains = pattern !== '';\n  fp = utils.unixify(fp, opts);\n\n  if (opts.contains && !utils.isGlob(pattern)) {\n    return fp.indexOf(pattern) !== -1;\n  }\n\n  return matcher(pattern, opts)(fp);\n}\n/**\n * Returns true if a file path matches any of the\n * given patterns.\n *\n * @param  {String} `fp` The filepath to test.\n * @param  {String|Array} `patterns` Glob patterns to use.\n * @param  {Object} `opts` Options to pass to the `matcher()` function.\n * @return {String}\n */\n\n\nfunction any(fp, patterns, opts) {\n  if (!Array.isArray(patterns) && typeof patterns !== 'string') {\n    throw new TypeError(msg('any', 'patterns', 'a string or array'));\n  }\n\n  patterns = utils.arrayify(patterns);\n  var len = patterns.length;\n  fp = utils.unixify(fp, opts);\n\n  while (len--) {\n    var isMatch = matcher(patterns[len], opts);\n\n    if (isMatch(fp)) {\n      return true;\n    }\n  }\n\n  return false;\n}\n/**\n * Filter the keys of an object with the given `glob` pattern\n * and `options`\n *\n * @param  {Object} `object`\n * @param  {Pattern} `object`\n * @return {Array}\n */\n\n\nfunction matchKeys(obj, glob, options) {\n  if (utils.typeOf(obj) !== 'object') {\n    throw new TypeError(msg('matchKeys', 'first argument', 'an object'));\n  }\n\n  var fn = matcher(glob, options);\n  var res = {};\n\n  for (var key in obj) {\n    if (obj.hasOwnProperty(key) && fn(key)) {\n      res[key] = obj[key];\n    }\n  }\n\n  return res;\n}\n/**\n * Return a function for matching based on the\n * given `pattern` and `options`.\n *\n * @param  {String} `pattern`\n * @param  {Object} `options`\n * @return {Function}\n */\n\n\nfunction matcher(pattern, opts) {\n  // pattern is a function\n  if (typeof pattern === 'function') {\n    return pattern;\n  } // pattern is a regex\n\n\n  if (pattern instanceof RegExp) {\n    return function (fp) {\n      return pattern.test(fp);\n    };\n  }\n\n  if (typeof pattern !== 'string') {\n    throw new TypeError(msg('matcher', 'pattern', 'a string, regex, or function'));\n  } // strings, all the way down...\n\n\n  pattern = utils.unixify(pattern, opts); // pattern is a non-glob string\n\n  if (!utils.isGlob(pattern)) {\n    return utils.matchPath(pattern, opts);\n  } // pattern is a glob string\n\n\n  var re = makeRe(pattern, opts); // `matchBase` is defined\n\n  if (opts && opts.matchBase) {\n    return utils.hasFilename(re, opts);\n  } // `matchBase` is not defined\n\n\n  return function (fp) {\n    fp = utils.unixify(fp, opts);\n    return re.test(fp);\n  };\n}\n/**\n * Create and cache a regular expression for matching\n * file paths.\n *\n * If the leading character in the `glob` is `!`, a negation\n * regex is returned.\n *\n * @param  {String} `glob`\n * @param  {Object} `options`\n * @return {RegExp}\n */\n\n\nfunction toRegex(glob, options) {\n  // clone options to prevent  mutating the original object\n  var opts = Object.create(options || {});\n  var flags = opts.flags || '';\n\n  if (opts.nocase && flags.indexOf('i') === -1) {\n    flags += 'i';\n  }\n\n  var parsed = expand(glob, opts); // pass in tokens to avoid parsing more than once\n\n  opts.negated = opts.negated || parsed.negated;\n  opts.negate = opts.negated;\n  glob = wrapGlob(parsed.pattern, opts);\n  var re;\n\n  try {\n    re = new RegExp(glob, flags);\n    return re;\n  } catch (err) {\n    err.reason = 'micromatch invalid regex: (' + re + ')';\n    if (opts.strict) throw new SyntaxError(err);\n  } // we're only here if a bad pattern was used and the user\n  // passed `options.silent`, so match nothing\n\n\n  return /$^/;\n}\n/**\n * Create the regex to do the matching. If the leading\n * character in the `glob` is `!` a negation regex is returned.\n *\n * @param {String} `glob`\n * @param {Boolean} `negate`\n */\n\n\nfunction wrapGlob(glob, opts) {\n  var prefix = opts && !opts.contains ? '^' : '';\n  var after = opts && !opts.contains ? '$' : '';\n  glob = '(?:' + glob + ')' + after;\n\n  if (opts && opts.negate) {\n    return prefix + ('(?!^' + glob + ').*$');\n  }\n\n  return prefix + glob;\n}\n/**\n * Create and cache a regular expression for matching file paths.\n * If the leading character in the `glob` is `!`, a negation\n * regex is returned.\n *\n * @param  {String} `glob`\n * @param  {Object} `options`\n * @return {RegExp}\n */\n\n\nfunction makeRe(glob, opts) {\n  if (utils.typeOf(glob) !== 'string') {\n    throw new Error(msg('makeRe', 'glob', 'a string'));\n  }\n\n  return utils.cache(toRegex, glob, opts);\n}\n/**\n * Make error messages consistent. Follows this format:\n *\n * ```js\n * msg(methodName, argNumber, nativeType);\n * // example:\n * msg('matchKeys', 'first', 'an object');\n * ```\n *\n * @param  {String} `method`\n * @param  {String} `num`\n * @param  {String} `type`\n * @return {String}\n */\n\n\nfunction msg(method, what, type) {\n  return 'micromatch.' + method + '(): ' + what + ' should be ' + type + '.';\n}\n/**\n * Public methods\n */\n\n/* eslint no-multi-spaces: 0 */\n\n\nmicromatch.any = any;\nmicromatch.braces = micromatch.braceExpand = utils.braces;\nmicromatch.contains = contains;\nmicromatch.expand = expand;\nmicromatch.filter = filter;\nmicromatch.isMatch = isMatch;\nmicromatch.makeRe = makeRe;\nmicromatch.match = match;\nmicromatch.matcher = matcher;\nmicromatch.matchKeys = matchKeys;\n/**\n * Expose `micromatch`\n */\n\nmodule.exports = micromatch;","map":{"version":3,"sources":["/home/yanxiaoyang/react-project/PersonalWebsiteTest/node_modules/rijs.resdir/node_modules/micromatch/index.js"],"names":["expand","require","utils","micromatch","files","patterns","opts","cache","Array","isArray","match","len","length","i","omit","keep","glob","charCodeAt","push","apply","slice","diff","pattern","typeOf","Error","msg","arrayify","negate","orig","charAt","nonegate","_isMatch","matcher","res","file","fp","unixify","failglob","nonull","nullglob","unescapeGlob","ignore","nodupes","unique","filter","TypeError","patternMatchers","fn","isMatch","contains","isGlob","indexOf","any","matchKeys","obj","options","key","hasOwnProperty","RegExp","test","matchPath","re","makeRe","matchBase","hasFilename","toRegex","Object","create","flags","nocase","parsed","negated","wrapGlob","err","reason","strict","SyntaxError","prefix","after","method","what","type","braces","braceExpand","module","exports"],"mappings":"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","sourcesContent":["/*!\n * micromatch <https://github.com/jonschlinkert/micromatch>\n *\n * Copyright (c) 2014-2015, Jon Schlinkert.\n * Licensed under the MIT License.\n */\n\n'use strict';\n\nvar expand = require('./lib/expand');\nvar utils = require('./lib/utils');\n\n/**\n * The main function. Pass an array of filepaths,\n * and a string or array of glob patterns\n *\n * @param  {Array|String} `files`\n * @param  {Array|String} `patterns`\n * @param  {Object} `opts`\n * @return {Array} Array of matches\n */\n\nfunction micromatch(files, patterns, opts) {\n  if (!files || !patterns) return [];\n  opts = opts || {};\n\n  if (typeof opts.cache === 'undefined') {\n    opts.cache = true;\n  }\n\n  if (!Array.isArray(patterns)) {\n    return match(files, patterns, opts);\n  }\n\n  var len = patterns.length, i = 0;\n  var omit = [], keep = [];\n\n  while (len--) {\n    var glob = patterns[i++];\n    if (typeof glob === 'string' && glob.charCodeAt(0) === 33 /* ! */) {\n      omit.push.apply(omit, match(files, glob.slice(1), opts));\n    } else {\n      keep.push.apply(keep, match(files, glob, opts));\n    }\n  }\n  return utils.diff(keep, omit);\n}\n\n/**\n * Return an array of files that match the given glob pattern.\n *\n * This function is called by the main `micromatch` function If you only\n * need to pass a single pattern you might get very minor speed improvements\n * using this function.\n *\n * @param  {Array} `files`\n * @param  {String} `pattern`\n * @param  {Object} `options`\n * @return {Array}\n */\n\nfunction match(files, pattern, opts) {\n  if (utils.typeOf(files) !== 'string' && !Array.isArray(files)) {\n    throw new Error(msg('match', 'files', 'a string or array'));\n  }\n\n  files = utils.arrayify(files);\n  opts = opts || {};\n\n  var negate = opts.negate || false;\n  var orig = pattern;\n\n  if (typeof pattern === 'string') {\n    negate = pattern.charAt(0) === '!';\n    if (negate) {\n      pattern = pattern.slice(1);\n    }\n\n    // we need to remove the character regardless,\n    // so the above logic is still needed\n    if (opts.nonegate === true) {\n      negate = false;\n    }\n  }\n\n  var _isMatch = matcher(pattern, opts);\n  var len = files.length, i = 0;\n  var res = [];\n\n  while (i < len) {\n    var file = files[i++];\n    var fp = utils.unixify(file, opts);\n\n    if (!_isMatch(fp)) { continue; }\n    res.push(fp);\n  }\n\n  if (res.length === 0) {\n    if (opts.failglob === true) {\n      throw new Error('micromatch.match() found no matches for: \"' + orig + '\".');\n    }\n\n    if (opts.nonull || opts.nullglob) {\n      res.push(utils.unescapeGlob(orig));\n    }\n  }\n\n  // if `negate` was defined, diff negated files\n  if (negate) { res = utils.diff(files, res); }\n\n  // if `ignore` was defined, diff ignored filed\n  if (opts.ignore && opts.ignore.length) {\n    pattern = opts.ignore;\n    opts = utils.omit(opts, ['ignore']);\n    res = utils.diff(res, micromatch(res, pattern, opts));\n  }\n\n  if (opts.nodupes) {\n    return utils.unique(res);\n  }\n  return res;\n}\n\n/**\n * Returns a function that takes a glob pattern or array of glob patterns\n * to be used with `Array#filter()`. (Internally this function generates\n * the matching function using the [matcher] method).\n *\n * ```js\n * var fn = mm.filter('[a-c]');\n * ['a', 'b', 'c', 'd', 'e'].filter(fn);\n * //=> ['a', 'b', 'c']\n * ```\n * @param  {String|Array} `patterns` Can be a glob or array of globs.\n * @param  {Options} `opts` Options to pass to the [matcher] method.\n * @return {Function} Filter function to be passed to `Array#filter()`.\n */\n\nfunction filter(patterns, opts) {\n  if (!Array.isArray(patterns) && typeof patterns !== 'string') {\n    throw new TypeError(msg('filter', 'patterns', 'a string or array'));\n  }\n\n  patterns = utils.arrayify(patterns);\n  var len = patterns.length, i = 0;\n  var patternMatchers = Array(len);\n  while (i < len) {\n    patternMatchers[i] = matcher(patterns[i++], opts);\n  }\n\n  return function(fp) {\n    if (fp == null) return [];\n    var len = patternMatchers.length, i = 0;\n    var res = true;\n\n    fp = utils.unixify(fp, opts);\n    while (i < len) {\n      var fn = patternMatchers[i++];\n      if (!fn(fp)) {\n        res = false;\n        break;\n      }\n    }\n    return res;\n  };\n}\n\n/**\n * Returns true if the filepath contains the given\n * pattern. Can also return a function for matching.\n *\n * ```js\n * isMatch('foo.md', '*.md', {});\n * //=> true\n *\n * isMatch('*.md', {})('foo.md')\n * //=> true\n * ```\n * @param  {String} `fp`\n * @param  {String} `pattern`\n * @param  {Object} `opts`\n * @return {Boolean}\n */\n\nfunction isMatch(fp, pattern, opts) {\n  if (typeof fp !== 'string') {\n    throw new TypeError(msg('isMatch', 'filepath', 'a string'));\n  }\n\n  fp = utils.unixify(fp, opts);\n  if (utils.typeOf(pattern) === 'object') {\n    return matcher(fp, pattern);\n  }\n  return matcher(pattern, opts)(fp);\n}\n\n/**\n * Returns true if the filepath matches the\n * given pattern.\n */\n\nfunction contains(fp, pattern, opts) {\n  if (typeof fp !== 'string') {\n    throw new TypeError(msg('contains', 'pattern', 'a string'));\n  }\n\n  opts = opts || {};\n  opts.contains = (pattern !== '');\n  fp = utils.unixify(fp, opts);\n\n  if (opts.contains && !utils.isGlob(pattern)) {\n    return fp.indexOf(pattern) !== -1;\n  }\n  return matcher(pattern, opts)(fp);\n}\n\n/**\n * Returns true if a file path matches any of the\n * given patterns.\n *\n * @param  {String} `fp` The filepath to test.\n * @param  {String|Array} `patterns` Glob patterns to use.\n * @param  {Object} `opts` Options to pass to the `matcher()` function.\n * @return {String}\n */\n\nfunction any(fp, patterns, opts) {\n  if (!Array.isArray(patterns) && typeof patterns !== 'string') {\n    throw new TypeError(msg('any', 'patterns', 'a string or array'));\n  }\n\n  patterns = utils.arrayify(patterns);\n  var len = patterns.length;\n\n  fp = utils.unixify(fp, opts);\n  while (len--) {\n    var isMatch = matcher(patterns[len], opts);\n    if (isMatch(fp)) {\n      return true;\n    }\n  }\n  return false;\n}\n\n/**\n * Filter the keys of an object with the given `glob` pattern\n * and `options`\n *\n * @param  {Object} `object`\n * @param  {Pattern} `object`\n * @return {Array}\n */\n\nfunction matchKeys(obj, glob, options) {\n  if (utils.typeOf(obj) !== 'object') {\n    throw new TypeError(msg('matchKeys', 'first argument', 'an object'));\n  }\n\n  var fn = matcher(glob, options);\n  var res = {};\n\n  for (var key in obj) {\n    if (obj.hasOwnProperty(key) && fn(key)) {\n      res[key] = obj[key];\n    }\n  }\n  return res;\n}\n\n/**\n * Return a function for matching based on the\n * given `pattern` and `options`.\n *\n * @param  {String} `pattern`\n * @param  {Object} `options`\n * @return {Function}\n */\n\nfunction matcher(pattern, opts) {\n  // pattern is a function\n  if (typeof pattern === 'function') {\n    return pattern;\n  }\n  // pattern is a regex\n  if (pattern instanceof RegExp) {\n    return function(fp) {\n      return pattern.test(fp);\n    };\n  }\n\n  if (typeof pattern !== 'string') {\n    throw new TypeError(msg('matcher', 'pattern', 'a string, regex, or function'));\n  }\n\n  // strings, all the way down...\n  pattern = utils.unixify(pattern, opts);\n\n  // pattern is a non-glob string\n  if (!utils.isGlob(pattern)) {\n    return utils.matchPath(pattern, opts);\n  }\n  // pattern is a glob string\n  var re = makeRe(pattern, opts);\n\n  // `matchBase` is defined\n  if (opts && opts.matchBase) {\n    return utils.hasFilename(re, opts);\n  }\n  // `matchBase` is not defined\n  return function(fp) {\n    fp = utils.unixify(fp, opts);\n    return re.test(fp);\n  };\n}\n\n/**\n * Create and cache a regular expression for matching\n * file paths.\n *\n * If the leading character in the `glob` is `!`, a negation\n * regex is returned.\n *\n * @param  {String} `glob`\n * @param  {Object} `options`\n * @return {RegExp}\n */\n\nfunction toRegex(glob, options) {\n  // clone options to prevent  mutating the original object\n  var opts = Object.create(options || {});\n  var flags = opts.flags || '';\n  if (opts.nocase && flags.indexOf('i') === -1) {\n    flags += 'i';\n  }\n\n  var parsed = expand(glob, opts);\n\n  // pass in tokens to avoid parsing more than once\n  opts.negated = opts.negated || parsed.negated;\n  opts.negate = opts.negated;\n  glob = wrapGlob(parsed.pattern, opts);\n  var re;\n\n  try {\n    re = new RegExp(glob, flags);\n    return re;\n  } catch (err) {\n    err.reason = 'micromatch invalid regex: (' + re + ')';\n    if (opts.strict) throw new SyntaxError(err);\n  }\n\n  // we're only here if a bad pattern was used and the user\n  // passed `options.silent`, so match nothing\n  return /$^/;\n}\n\n/**\n * Create the regex to do the matching. If the leading\n * character in the `glob` is `!` a negation regex is returned.\n *\n * @param {String} `glob`\n * @param {Boolean} `negate`\n */\n\nfunction wrapGlob(glob, opts) {\n  var prefix = (opts && !opts.contains) ? '^' : '';\n  var after = (opts && !opts.contains) ? '$' : '';\n  glob = ('(?:' + glob + ')' + after);\n  if (opts && opts.negate) {\n    return prefix + ('(?!^' + glob + ').*$');\n  }\n  return prefix + glob;\n}\n\n/**\n * Create and cache a regular expression for matching file paths.\n * If the leading character in the `glob` is `!`, a negation\n * regex is returned.\n *\n * @param  {String} `glob`\n * @param  {Object} `options`\n * @return {RegExp}\n */\n\nfunction makeRe(glob, opts) {\n  if (utils.typeOf(glob) !== 'string') {\n    throw new Error(msg('makeRe', 'glob', 'a string'));\n  }\n  return utils.cache(toRegex, glob, opts);\n}\n\n/**\n * Make error messages consistent. Follows this format:\n *\n * ```js\n * msg(methodName, argNumber, nativeType);\n * // example:\n * msg('matchKeys', 'first', 'an object');\n * ```\n *\n * @param  {String} `method`\n * @param  {String} `num`\n * @param  {String} `type`\n * @return {String}\n */\n\nfunction msg(method, what, type) {\n  return 'micromatch.' + method + '(): ' + what + ' should be ' + type + '.';\n}\n\n/**\n * Public methods\n */\n\n/* eslint no-multi-spaces: 0 */\nmicromatch.any       = any;\nmicromatch.braces    = micromatch.braceExpand = utils.braces;\nmicromatch.contains  = contains;\nmicromatch.expand    = expand;\nmicromatch.filter    = filter;\nmicromatch.isMatch   = isMatch;\nmicromatch.makeRe    = makeRe;\nmicromatch.match     = match;\nmicromatch.matcher   = matcher;\nmicromatch.matchKeys = matchKeys;\n\n/**\n * Expose `micromatch`\n */\n\nmodule.exports = micromatch;\n"]},"metadata":{},"sourceType":"script"}