{"ast":null,"code":"'use strict';\n\nvar fs = require('fs');\n\nvar sysPath = require('path');\n\nvar readdirp = require('readdirp');\n\nvar isBinaryPath = require('is-binary-path'); // fs.watch helpers\n// object to hold per-process fs.watch instances\n// (may be shared across chokidar FSWatcher instances)\n\n\nvar FsWatchInstances = Object.create(null); // Private function: Instantiates the fs.watch interface\n// * path       - string, path to be watched\n// * options    - object, options to be passed to fs.watch\n// * listener   - function, main event handler\n// * errHandler - function, handler which emits info about errors\n// * emitRaw    - function, handler which emits raw event data\n// Returns new fsevents instance\n\nfunction createFsWatchInstance(path, options, listener, errHandler, emitRaw) {\n  var handleEvent = function (rawEvent, evPath) {\n    listener(path);\n    emitRaw(rawEvent, evPath, {\n      watchedPath: path\n    }); // emit based on events occuring for files from a directory's watcher in\n    // case the file's watcher misses it (and rely on throttling to de-dupe)\n\n    if (evPath && path !== evPath) {\n      fsWatchBroadcast(sysPath.resolve(path, evPath), 'listeners', sysPath.join(path, evPath));\n    }\n  };\n\n  try {\n    return fs.watch(path, options, handleEvent);\n  } catch (error) {\n    errHandler(error);\n  }\n} // Private function: Helper for passing fs.watch event data to a\n// collection of listeners\n// * fullPath   - string, absolute path bound to the fs.watch instance\n// * type       - string, listener type\n// * val[1..3]  - arguments to be passed to listeners\n// Returns nothing\n\n\nfunction fsWatchBroadcast(fullPath, type, val1, val2, val3) {\n  if (!FsWatchInstances[fullPath]) return;\n  FsWatchInstances[fullPath][type].forEach(function (listener) {\n    listener(val1, val2, val3);\n  });\n} // Private function: Instantiates the fs.watch interface or binds listeners\n// to an existing one covering the same file system entry\n// * path       - string, path to be watched\n// * fullPath   - string, absolute path\n// * options    - object, options to be passed to fs.watch\n// * handlers   - object, container for event listener functions\n// Returns close function\n\n\nfunction setFsWatchListener(path, fullPath, options, handlers) {\n  var listener = handlers.listener;\n  var errHandler = handlers.errHandler;\n  var rawEmitter = handlers.rawEmitter;\n  var container = FsWatchInstances[fullPath];\n  var watcher;\n\n  if (!options.persistent) {\n    watcher = createFsWatchInstance(path, options, listener, errHandler, rawEmitter);\n    return watcher.close.bind(watcher);\n  }\n\n  if (!container) {\n    watcher = createFsWatchInstance(path, options, fsWatchBroadcast.bind(null, fullPath, 'listeners'), errHandler, // no need to use broadcast here\n    fsWatchBroadcast.bind(null, fullPath, 'rawEmitters'));\n    if (!watcher) return;\n    var broadcastErr = fsWatchBroadcast.bind(null, fullPath, 'errHandlers');\n    watcher.on('error', function (error) {\n      // Workaround for https://github.com/joyent/node/issues/4337\n      if (process.platform === 'win32' && error.code === 'EPERM') {\n        fs.open(path, 'r', function (err, fd) {\n          if (fd) fs.close(fd);\n          if (!err) broadcastErr(error);\n        });\n      } else {\n        broadcastErr(error);\n      }\n    });\n    container = FsWatchInstances[fullPath] = {\n      listeners: [listener],\n      errHandlers: [errHandler],\n      rawEmitters: [rawEmitter],\n      watcher: watcher\n    };\n  } else {\n    container.listeners.push(listener);\n    container.errHandlers.push(errHandler);\n    container.rawEmitters.push(rawEmitter);\n  }\n\n  var listenerIndex = container.listeners.length - 1; // removes this instance's listeners and closes the underlying fs.watch\n  // instance if there are no more listeners left\n\n  return function close() {\n    delete container.listeners[listenerIndex];\n    delete container.errHandlers[listenerIndex];\n    delete container.rawEmitters[listenerIndex];\n\n    if (!Object.keys(container.listeners).length) {\n      container.watcher.close();\n      delete FsWatchInstances[fullPath];\n    }\n  };\n} // fs.watchFile helpers\n// object to hold per-process fs.watchFile instances\n// (may be shared across chokidar FSWatcher instances)\n\n\nvar FsWatchFileInstances = Object.create(null); // Private function: Instantiates the fs.watchFile interface or binds listeners\n// to an existing one covering the same file system entry\n// * path       - string, path to be watched\n// * fullPath   - string, absolute path\n// * options    - object, options to be passed to fs.watchFile\n// * handlers   - object, container for event listener functions\n// Returns close function\n\nfunction setFsWatchFileListener(path, fullPath, options, handlers) {\n  var listener = handlers.listener;\n  var rawEmitter = handlers.rawEmitter;\n  var container = FsWatchFileInstances[fullPath];\n  var listeners = [];\n  var rawEmitters = [];\n\n  if (container && (container.options.persistent < options.persistent || container.options.interval > options.interval)) {\n    // \"Upgrade\" the watcher to persistence or a quicker interval.\n    // This creates some unlikely edge case issues if the user mixes\n    // settings in a very weird way, but solving for those cases\n    // doesn't seem worthwhile for the added complexity.\n    listeners = container.listeners;\n    rawEmitters = container.rawEmitters;\n    fs.unwatchFile(fullPath);\n    container = false;\n  }\n\n  if (!container) {\n    listeners.push(listener);\n    rawEmitters.push(rawEmitter);\n    container = FsWatchFileInstances[fullPath] = {\n      listeners: listeners,\n      rawEmitters: rawEmitters,\n      options: options,\n      watcher: fs.watchFile(fullPath, options, function (curr, prev) {\n        container.rawEmitters.forEach(function (rawEmitter) {\n          rawEmitter('change', fullPath, {\n            curr: curr,\n            prev: prev\n          });\n        });\n        var currmtime = curr.mtime.getTime();\n\n        if (curr.size !== prev.size || currmtime > prev.mtime.getTime() || currmtime === 0) {\n          container.listeners.forEach(function (listener) {\n            listener(path, curr);\n          });\n        }\n      })\n    };\n  } else {\n    container.listeners.push(listener);\n    container.rawEmitters.push(rawEmitter);\n  }\n\n  var listenerIndex = container.listeners.length - 1; // removes this instance's listeners and closes the underlying fs.watchFile\n  // instance if there are no more listeners left\n\n  return function close() {\n    delete container.listeners[listenerIndex];\n    delete container.rawEmitters[listenerIndex];\n\n    if (!Object.keys(container.listeners).length) {\n      fs.unwatchFile(fullPath);\n      delete FsWatchFileInstances[fullPath];\n    }\n  };\n} // fake constructor for attaching nodefs-specific prototype methods that\n// will be copied to FSWatcher's prototype\n\n\nfunction NodeFsHandler() {} // Private method: Watch file for changes with fs.watchFile or fs.watch.\n// * path     - string, path to file or directory.\n// * listener - function, to be executed on fs change.\n// Returns close function for the watcher instance\n\n\nNodeFsHandler.prototype._watchWithNodeFs = function (path, listener) {\n  var directory = sysPath.dirname(path);\n  var basename = sysPath.basename(path);\n\n  var parent = this._getWatchedDir(directory);\n\n  parent.add(basename);\n  var absolutePath = sysPath.resolve(path);\n  var options = {\n    persistent: this.options.persistent\n  };\n  if (!listener) listener = Function.prototype; // empty function\n\n  var closer;\n\n  if (this.options.usePolling) {\n    options.interval = this.enableBinaryInterval && isBinaryPath(basename) ? this.options.binaryInterval : this.options.interval;\n    closer = setFsWatchFileListener(path, absolutePath, options, {\n      listener: listener,\n      rawEmitter: this.emit.bind(this, 'raw')\n    });\n  } else {\n    closer = setFsWatchListener(path, absolutePath, options, {\n      listener: listener,\n      errHandler: this._handleError.bind(this),\n      rawEmitter: this.emit.bind(this, 'raw')\n    });\n  }\n\n  return closer;\n}; // Private method: Watch a file and emit add event if warranted\n// * file       - string, the file's path\n// * stats      - object, result of fs.stat\n// * initialAdd - boolean, was the file added at watch instantiation?\n// * callback   - function, called when done processing as a newly seen file\n// Returns close function for the watcher instance\n\n\nNodeFsHandler.prototype._handleFile = function (file, stats, initialAdd, callback) {\n  var dirname = sysPath.dirname(file);\n  var basename = sysPath.basename(file);\n\n  var parent = this._getWatchedDir(dirname); // if the file is already being watched, do nothing\n\n\n  if (parent.has(basename)) return callback(); // kick off the watcher\n\n  var closer = this._watchWithNodeFs(file, function (path, newStats) {\n    if (!this._throttle('watch', file, 5)) return;\n\n    if (!newStats || newStats && newStats.mtime.getTime() === 0) {\n      fs.stat(file, function (error, newStats) {\n        // Fix issues where mtime is null but file is still present\n        if (error) {\n          this._remove(dirname, basename);\n        } else {\n          this._emit('change', file, newStats);\n        }\n      }.bind(this)); // add is about to be emitted if file not already tracked in parent\n    } else if (parent.has(basename)) {\n      this._emit('change', file, newStats);\n    }\n  }.bind(this)); // emit an add event if we're supposed to\n\n\n  if (!(initialAdd && this.options.ignoreInitial)) {\n    if (!this._throttle('add', file, 0)) return;\n\n    this._emit('add', file, stats);\n  }\n\n  if (callback) callback();\n  return closer;\n}; // Private method: Handle symlinks encountered while reading a dir\n// * entry      - object, entry object returned by readdirp\n// * directory  - string, path of the directory being read\n// * path       - string, path of this item\n// * item       - string, basename of this item\n// Returns true if no more processing is needed for this entry.\n\n\nNodeFsHandler.prototype._handleSymlink = function (entry, directory, path, item) {\n  var full = entry.fullPath;\n\n  var dir = this._getWatchedDir(directory);\n\n  if (!this.options.followSymlinks) {\n    // watch symlink directly (don't follow) and detect changes\n    this._readyCount++;\n    fs.realpath(path, function (error, linkPath) {\n      if (dir.has(item)) {\n        if (this._symlinkPaths[full] !== linkPath) {\n          this._symlinkPaths[full] = linkPath;\n\n          this._emit('change', path, entry.stat);\n        }\n      } else {\n        dir.add(item);\n        this._symlinkPaths[full] = linkPath;\n\n        this._emit('add', path, entry.stat);\n      }\n\n      this._emitReady();\n    }.bind(this));\n    return true;\n  } // don't follow the same symlink more than once\n\n\n  if (this._symlinkPaths[full]) return true;else this._symlinkPaths[full] = true;\n}; // Private method: Read directory to add / remove files from `@watched` list\n// and re-read it on change.\n// * dir        - string, fs path.\n// * stats      - object, result of fs.stat\n// * initialAdd - boolean, was the file added at watch instantiation?\n// * depth      - int, depth relative to user-supplied path\n// * target     - string, child path actually targeted for watch\n// * wh         - object, common watch helpers for this path\n// * callback   - function, called when dir scan is complete\n// Returns close function for the watcher instance\n\n\nNodeFsHandler.prototype._handleDir = function (dir, stats, initialAdd, depth, target, wh, callback) {\n  var parentDir = this._getWatchedDir(sysPath.dirname(dir));\n\n  var tracked = parentDir.has(sysPath.basename(dir));\n\n  if (!(initialAdd && this.options.ignoreInitial) && !target && !tracked) {\n    if (!wh.hasGlob || wh.globFilter(dir)) this._emit('addDir', dir, stats);\n  } // ensure dir is tracked (harmless if redundant)\n\n\n  parentDir.add(sysPath.basename(dir));\n\n  this._getWatchedDir(dir);\n\n  var read = function (directory, initialAdd, done) {\n    // Normalize the directory name on Windows\n    directory = sysPath.join(directory, '');\n\n    if (!wh.hasGlob) {\n      var throttler = this._throttle('readdir', directory, 1000);\n\n      if (!throttler) return;\n    }\n\n    var previous = this._getWatchedDir(wh.path);\n\n    var current = [];\n    readdirp({\n      root: directory,\n      entryType: 'all',\n      fileFilter: wh.filterPath,\n      directoryFilter: wh.filterDir,\n      depth: 0,\n      lstat: true\n    }).on('data', function (entry) {\n      var item = entry.path;\n      var path = sysPath.join(directory, item);\n      current.push(item);\n      if (entry.stat.isSymbolicLink() && this._handleSymlink(entry, directory, path, item)) return; // Files that present in current directory snapshot\n      // but absent in previous are added to watch list and\n      // emit `add` event.\n\n      if (item === target || !target && !previous.has(item)) {\n        this._readyCount++; // ensure relativeness of path is preserved in case of watcher reuse\n\n        path = sysPath.join(dir, sysPath.relative(dir, path));\n\n        this._addToNodeFs(path, initialAdd, wh, depth + 1);\n      }\n    }.bind(this)).on('end', function () {\n      if (throttler) throttler.clear();\n      if (done) done(); // Files that absent in current directory snapshot\n      // but present in previous emit `remove` event\n      // and are removed from @watched[directory].\n\n      previous.children().filter(function (item) {\n        return item !== directory && current.indexOf(item) === -1 && ( // in case of intersecting globs;\n        // a path may have been filtered out of this readdir, but\n        // shouldn't be removed because it matches a different glob\n        !wh.hasGlob || wh.filterPath({\n          fullPath: sysPath.resolve(directory, item)\n        }));\n      }).forEach(function (item) {\n        this._remove(directory, item);\n      }, this);\n    }.bind(this)).on('error', this._handleError.bind(this));\n  }.bind(this);\n\n  var closer;\n\n  if (this.options.depth == null || depth <= this.options.depth) {\n    if (!target) read(dir, initialAdd, callback);\n    closer = this._watchWithNodeFs(dir, function (dirPath, stats) {\n      // if current directory is removed, do nothing\n      if (stats && stats.mtime.getTime() === 0) return;\n      read(dirPath, false);\n    });\n  } else {\n    callback();\n  }\n\n  return closer;\n}; // Private method: Handle added file, directory, or glob pattern.\n// Delegates call to _handleFile / _handleDir after checks.\n// * path       - string, path to file or directory.\n// * initialAdd - boolean, was the file added at watch instantiation?\n// * depth      - int, depth relative to user-supplied path\n// * target     - string, child path actually targeted for watch\n// * callback   - function, indicates whether the path was found or not\n// Returns nothing\n\n\nNodeFsHandler.prototype._addToNodeFs = function (path, initialAdd, priorWh, depth, target, callback) {\n  if (!callback) callback = Function.prototype;\n  var ready = this._emitReady;\n\n  if (this._isIgnored(path) || this.closed) {\n    ready();\n    return callback(null, false);\n  }\n\n  var wh = this._getWatchHelpers(path, depth);\n\n  if (!wh.hasGlob && priorWh) {\n    wh.hasGlob = priorWh.hasGlob;\n    wh.globFilter = priorWh.globFilter;\n    wh.filterPath = priorWh.filterPath;\n    wh.filterDir = priorWh.filterDir;\n  } // evaluate what is at the path we're being asked to watch\n\n\n  fs[wh.statMethod](wh.watchPath, function (error, stats) {\n    if (this._handleError(error)) return callback(null, path);\n\n    if (this._isIgnored(wh.watchPath, stats)) {\n      ready();\n      return callback(null, false);\n    }\n\n    var initDir = function (dir, target) {\n      return this._handleDir(dir, stats, initialAdd, depth, target, wh, ready);\n    }.bind(this);\n\n    var closer;\n\n    if (stats.isDirectory()) {\n      closer = initDir(wh.watchPath, target);\n    } else if (stats.isSymbolicLink()) {\n      var parent = sysPath.dirname(wh.watchPath);\n\n      this._getWatchedDir(parent).add(wh.watchPath);\n\n      this._emit('add', wh.watchPath, stats);\n\n      closer = initDir(parent, path); // preserve this symlink's target path\n\n      fs.realpath(path, function (error, targetPath) {\n        this._symlinkPaths[sysPath.resolve(path)] = targetPath;\n        ready();\n      }.bind(this));\n    } else {\n      closer = this._handleFile(wh.watchPath, stats, initialAdd, ready);\n    }\n\n    if (closer) this._closers[path] = closer;\n    callback(null, false);\n  }.bind(this));\n};\n\nmodule.exports = NodeFsHandler;","map":{"version":3,"sources":["/home/yanxiaoyang/react-project/PersonalWebsiteTest/node_modules/rijs.resdir/node_modules/chokidar/lib/nodefs-handler.js"],"names":["fs","require","sysPath","readdirp","isBinaryPath","FsWatchInstances","Object","create","createFsWatchInstance","path","options","listener","errHandler","emitRaw","handleEvent","rawEvent","evPath","watchedPath","fsWatchBroadcast","resolve","join","watch","error","fullPath","type","val1","val2","val3","forEach","setFsWatchListener","handlers","rawEmitter","container","watcher","persistent","close","bind","broadcastErr","on","process","platform","code","open","err","fd","listeners","errHandlers","rawEmitters","push","listenerIndex","length","keys","FsWatchFileInstances","setFsWatchFileListener","interval","unwatchFile","watchFile","curr","prev","currmtime","mtime","getTime","size","NodeFsHandler","prototype","_watchWithNodeFs","directory","dirname","basename","parent","_getWatchedDir","add","absolutePath","Function","closer","usePolling","enableBinaryInterval","binaryInterval","emit","_handleError","_handleFile","file","stats","initialAdd","callback","has","newStats","_throttle","stat","_remove","_emit","ignoreInitial","_handleSymlink","entry","item","full","dir","followSymlinks","_readyCount","realpath","linkPath","_symlinkPaths","_emitReady","_handleDir","depth","target","wh","parentDir","tracked","hasGlob","globFilter","read","done","throttler","previous","current","root","entryType","fileFilter","filterPath","directoryFilter","filterDir","lstat","isSymbolicLink","relative","_addToNodeFs","clear","children","filter","indexOf","dirPath","priorWh","ready","_isIgnored","closed","_getWatchHelpers","statMethod","watchPath","initDir","isDirectory","targetPath","_closers","module","exports"],"mappings":"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","sourcesContent":["'use strict';\n\nvar fs = require('fs');\nvar sysPath = require('path');\nvar readdirp = require('readdirp');\nvar isBinaryPath = require('is-binary-path');\n\n// fs.watch helpers\n\n// object to hold per-process fs.watch instances\n// (may be shared across chokidar FSWatcher instances)\nvar FsWatchInstances = Object.create(null);\n\n// Private function: Instantiates the fs.watch interface\n\n// * path       - string, path to be watched\n// * options    - object, options to be passed to fs.watch\n// * listener   - function, main event handler\n// * errHandler - function, handler which emits info about errors\n// * emitRaw    - function, handler which emits raw event data\n\n// Returns new fsevents instance\nfunction createFsWatchInstance(path, options, listener, errHandler, emitRaw) {\n  var handleEvent = function(rawEvent, evPath) {\n    listener(path);\n    emitRaw(rawEvent, evPath, {watchedPath: path});\n\n    // emit based on events occuring for files from a directory's watcher in\n    // case the file's watcher misses it (and rely on throttling to de-dupe)\n    if (evPath && path !== evPath) {\n      fsWatchBroadcast(\n        sysPath.resolve(path, evPath), 'listeners', sysPath.join(path, evPath)\n      );\n    }\n  };\n  try {\n    return fs.watch(path, options, handleEvent);\n  } catch (error) {\n    errHandler(error);\n  }\n}\n\n// Private function: Helper for passing fs.watch event data to a\n// collection of listeners\n\n// * fullPath   - string, absolute path bound to the fs.watch instance\n// * type       - string, listener type\n// * val[1..3]  - arguments to be passed to listeners\n\n// Returns nothing\nfunction fsWatchBroadcast(fullPath, type, val1, val2, val3) {\n  if (!FsWatchInstances[fullPath]) return;\n  FsWatchInstances[fullPath][type].forEach(function(listener) {\n    listener(val1, val2, val3);\n  });\n}\n\n// Private function: Instantiates the fs.watch interface or binds listeners\n// to an existing one covering the same file system entry\n\n// * path       - string, path to be watched\n// * fullPath   - string, absolute path\n// * options    - object, options to be passed to fs.watch\n// * handlers   - object, container for event listener functions\n\n// Returns close function\nfunction setFsWatchListener(path, fullPath, options, handlers) {\n  var listener = handlers.listener;\n  var errHandler = handlers.errHandler;\n  var rawEmitter = handlers.rawEmitter;\n  var container = FsWatchInstances[fullPath];\n  var watcher;\n  if (!options.persistent) {\n    watcher = createFsWatchInstance(\n      path, options, listener, errHandler, rawEmitter\n    );\n    return watcher.close.bind(watcher);\n  }\n  if (!container) {\n    watcher = createFsWatchInstance(\n      path,\n      options,\n      fsWatchBroadcast.bind(null, fullPath, 'listeners'),\n      errHandler, // no need to use broadcast here\n      fsWatchBroadcast.bind(null, fullPath, 'rawEmitters')\n    );\n    if (!watcher) return;\n    var broadcastErr = fsWatchBroadcast.bind(null, fullPath, 'errHandlers');\n    watcher.on('error', function(error) {\n      // Workaround for https://github.com/joyent/node/issues/4337\n      if (process.platform === 'win32' && error.code === 'EPERM') {\n        fs.open(path, 'r', function(err, fd) {\n          if (fd) fs.close(fd);\n          if (!err) broadcastErr(error);\n        });\n      } else {\n        broadcastErr(error);\n      }\n    });\n    container = FsWatchInstances[fullPath] = {\n      listeners: [listener],\n      errHandlers: [errHandler],\n      rawEmitters: [rawEmitter],\n      watcher: watcher\n    };\n  } else {\n    container.listeners.push(listener);\n    container.errHandlers.push(errHandler);\n    container.rawEmitters.push(rawEmitter);\n  }\n  var listenerIndex = container.listeners.length - 1;\n\n  // removes this instance's listeners and closes the underlying fs.watch\n  // instance if there are no more listeners left\n  return function close() {\n    delete container.listeners[listenerIndex];\n    delete container.errHandlers[listenerIndex];\n    delete container.rawEmitters[listenerIndex];\n    if (!Object.keys(container.listeners).length) {\n      container.watcher.close();\n      delete FsWatchInstances[fullPath];\n    }\n  };\n}\n\n// fs.watchFile helpers\n\n// object to hold per-process fs.watchFile instances\n// (may be shared across chokidar FSWatcher instances)\nvar FsWatchFileInstances = Object.create(null);\n\n// Private function: Instantiates the fs.watchFile interface or binds listeners\n// to an existing one covering the same file system entry\n\n// * path       - string, path to be watched\n// * fullPath   - string, absolute path\n// * options    - object, options to be passed to fs.watchFile\n// * handlers   - object, container for event listener functions\n\n// Returns close function\nfunction setFsWatchFileListener(path, fullPath, options, handlers) {\n  var listener = handlers.listener;\n  var rawEmitter = handlers.rawEmitter;\n  var container = FsWatchFileInstances[fullPath];\n  var listeners = [];\n  var rawEmitters = [];\n  if (\n    container && (\n      container.options.persistent < options.persistent ||\n      container.options.interval > options.interval\n    )\n  ) {\n    // \"Upgrade\" the watcher to persistence or a quicker interval.\n    // This creates some unlikely edge case issues if the user mixes\n    // settings in a very weird way, but solving for those cases\n    // doesn't seem worthwhile for the added complexity.\n    listeners = container.listeners;\n    rawEmitters = container.rawEmitters;\n    fs.unwatchFile(fullPath);\n    container = false;\n  }\n  if (!container) {\n    listeners.push(listener);\n    rawEmitters.push(rawEmitter);\n    container = FsWatchFileInstances[fullPath] = {\n      listeners: listeners,\n      rawEmitters: rawEmitters,\n      options: options,\n      watcher: fs.watchFile(fullPath, options, function(curr, prev) {\n        container.rawEmitters.forEach(function(rawEmitter) {\n          rawEmitter('change', fullPath, {curr: curr, prev: prev});\n        });\n        var currmtime = curr.mtime.getTime();\n        if (curr.size !== prev.size || currmtime > prev.mtime.getTime() || currmtime === 0) {\n          container.listeners.forEach(function(listener) {\n            listener(path, curr);\n          });\n        }\n      })\n    };\n  } else {\n    container.listeners.push(listener);\n    container.rawEmitters.push(rawEmitter);\n  }\n  var listenerIndex = container.listeners.length - 1;\n\n  // removes this instance's listeners and closes the underlying fs.watchFile\n  // instance if there are no more listeners left\n  return function close() {\n    delete container.listeners[listenerIndex];\n    delete container.rawEmitters[listenerIndex];\n    if (!Object.keys(container.listeners).length) {\n      fs.unwatchFile(fullPath);\n      delete FsWatchFileInstances[fullPath];\n    }\n  };\n}\n\n// fake constructor for attaching nodefs-specific prototype methods that\n// will be copied to FSWatcher's prototype\nfunction NodeFsHandler() {}\n\n// Private method: Watch file for changes with fs.watchFile or fs.watch.\n\n// * path     - string, path to file or directory.\n// * listener - function, to be executed on fs change.\n\n// Returns close function for the watcher instance\nNodeFsHandler.prototype._watchWithNodeFs =\nfunction(path, listener) {\n  var directory = sysPath.dirname(path);\n  var basename = sysPath.basename(path);\n  var parent = this._getWatchedDir(directory);\n  parent.add(basename);\n  var absolutePath = sysPath.resolve(path);\n  var options = {persistent: this.options.persistent};\n  if (!listener) listener = Function.prototype; // empty function\n\n  var closer;\n  if (this.options.usePolling) {\n    options.interval = this.enableBinaryInterval && isBinaryPath(basename) ?\n      this.options.binaryInterval : this.options.interval;\n    closer = setFsWatchFileListener(path, absolutePath, options, {\n      listener: listener,\n      rawEmitter: this.emit.bind(this, 'raw')\n    });\n  } else {\n    closer = setFsWatchListener(path, absolutePath, options, {\n      listener: listener,\n      errHandler: this._handleError.bind(this),\n      rawEmitter: this.emit.bind(this, 'raw')\n    });\n  }\n  return closer;\n};\n\n// Private method: Watch a file and emit add event if warranted\n\n// * file       - string, the file's path\n// * stats      - object, result of fs.stat\n// * initialAdd - boolean, was the file added at watch instantiation?\n// * callback   - function, called when done processing as a newly seen file\n\n// Returns close function for the watcher instance\nNodeFsHandler.prototype._handleFile =\nfunction(file, stats, initialAdd, callback) {\n  var dirname = sysPath.dirname(file);\n  var basename = sysPath.basename(file);\n  var parent = this._getWatchedDir(dirname);\n\n  // if the file is already being watched, do nothing\n  if (parent.has(basename)) return callback();\n\n  // kick off the watcher\n  var closer = this._watchWithNodeFs(file, function(path, newStats) {\n    if (!this._throttle('watch', file, 5)) return;\n    if (!newStats || newStats && newStats.mtime.getTime() === 0) {\n      fs.stat(file, function(error, newStats) {\n        // Fix issues where mtime is null but file is still present\n        if (error) {\n          this._remove(dirname, basename);\n        } else {\n          this._emit('change', file, newStats);\n        }\n      }.bind(this));\n    // add is about to be emitted if file not already tracked in parent\n    } else if (parent.has(basename)) {\n      this._emit('change', file, newStats);\n    }\n  }.bind(this));\n\n  // emit an add event if we're supposed to\n  if (!(initialAdd && this.options.ignoreInitial)) {\n    if (!this._throttle('add', file, 0)) return;\n    this._emit('add', file, stats);\n  }\n\n  if (callback) callback();\n  return closer;\n};\n\n// Private method: Handle symlinks encountered while reading a dir\n\n// * entry      - object, entry object returned by readdirp\n// * directory  - string, path of the directory being read\n// * path       - string, path of this item\n// * item       - string, basename of this item\n\n// Returns true if no more processing is needed for this entry.\nNodeFsHandler.prototype._handleSymlink =\nfunction(entry, directory, path, item) {\n  var full = entry.fullPath;\n  var dir = this._getWatchedDir(directory);\n\n  if (!this.options.followSymlinks) {\n    // watch symlink directly (don't follow) and detect changes\n    this._readyCount++;\n    fs.realpath(path, function(error, linkPath) {\n      if (dir.has(item)) {\n        if (this._symlinkPaths[full] !== linkPath) {\n          this._symlinkPaths[full] = linkPath;\n          this._emit('change', path, entry.stat);\n        }\n      } else {\n        dir.add(item);\n        this._symlinkPaths[full] = linkPath;\n        this._emit('add', path, entry.stat);\n      }\n      this._emitReady();\n    }.bind(this));\n    return true;\n  }\n\n  // don't follow the same symlink more than once\n  if (this._symlinkPaths[full]) return true;\n  else this._symlinkPaths[full] = true;\n};\n\n// Private method: Read directory to add / remove files from `@watched` list\n// and re-read it on change.\n\n// * dir        - string, fs path.\n// * stats      - object, result of fs.stat\n// * initialAdd - boolean, was the file added at watch instantiation?\n// * depth      - int, depth relative to user-supplied path\n// * target     - string, child path actually targeted for watch\n// * wh         - object, common watch helpers for this path\n// * callback   - function, called when dir scan is complete\n\n// Returns close function for the watcher instance\nNodeFsHandler.prototype._handleDir =\nfunction(dir, stats, initialAdd, depth, target, wh, callback) {\n  var parentDir = this._getWatchedDir(sysPath.dirname(dir));\n  var tracked = parentDir.has(sysPath.basename(dir));\n  if (!(initialAdd && this.options.ignoreInitial) && !target && !tracked) {\n    if (!wh.hasGlob || wh.globFilter(dir)) this._emit('addDir', dir, stats);\n  }\n\n  // ensure dir is tracked (harmless if redundant)\n  parentDir.add(sysPath.basename(dir));\n  this._getWatchedDir(dir);\n\n  var read = function(directory, initialAdd, done) {\n    // Normalize the directory name on Windows\n    directory = sysPath.join(directory, '');\n\n    if (!wh.hasGlob) {\n      var throttler = this._throttle('readdir', directory, 1000);\n      if (!throttler) return;\n    }\n\n    var previous = this._getWatchedDir(wh.path);\n    var current = [];\n\n    readdirp({\n      root: directory,\n      entryType: 'all',\n      fileFilter: wh.filterPath,\n      directoryFilter: wh.filterDir,\n      depth: 0,\n      lstat: true\n    }).on('data', function(entry) {\n      var item = entry.path;\n      var path = sysPath.join(directory, item);\n      current.push(item);\n\n      if (entry.stat.isSymbolicLink() &&\n        this._handleSymlink(entry, directory, path, item)) return;\n\n      // Files that present in current directory snapshot\n      // but absent in previous are added to watch list and\n      // emit `add` event.\n      if (item === target || !target && !previous.has(item)) {\n        this._readyCount++;\n\n        // ensure relativeness of path is preserved in case of watcher reuse\n        path = sysPath.join(dir, sysPath.relative(dir, path));\n\n        this._addToNodeFs(path, initialAdd, wh, depth + 1);\n      }\n    }.bind(this)).on('end', function() {\n      if (throttler) throttler.clear();\n      if (done) done();\n\n      // Files that absent in current directory snapshot\n      // but present in previous emit `remove` event\n      // and are removed from @watched[directory].\n      previous.children().filter(function(item) {\n        return item !== directory &&\n          current.indexOf(item) === -1 &&\n          // in case of intersecting globs;\n          // a path may have been filtered out of this readdir, but\n          // shouldn't be removed because it matches a different glob\n          (!wh.hasGlob || wh.filterPath({\n            fullPath: sysPath.resolve(directory, item)\n          }));\n      }).forEach(function(item) {\n        this._remove(directory, item);\n      }, this);\n    }.bind(this)).on('error', this._handleError.bind(this));\n  }.bind(this);\n\n  var closer;\n\n  if (this.options.depth == null || depth <= this.options.depth) {\n    if (!target) read(dir, initialAdd, callback);\n    closer = this._watchWithNodeFs(dir, function(dirPath, stats) {\n      // if current directory is removed, do nothing\n      if (stats && stats.mtime.getTime() === 0) return;\n\n      read(dirPath, false);\n    });\n  } else {\n    callback();\n  }\n  return closer;\n};\n\n// Private method: Handle added file, directory, or glob pattern.\n// Delegates call to _handleFile / _handleDir after checks.\n\n// * path       - string, path to file or directory.\n// * initialAdd - boolean, was the file added at watch instantiation?\n// * depth      - int, depth relative to user-supplied path\n// * target     - string, child path actually targeted for watch\n// * callback   - function, indicates whether the path was found or not\n\n// Returns nothing\nNodeFsHandler.prototype._addToNodeFs =\nfunction(path, initialAdd, priorWh, depth, target, callback) {\n  if (!callback) callback = Function.prototype;\n  var ready = this._emitReady;\n  if (this._isIgnored(path) || this.closed) {\n    ready();\n    return callback(null, false);\n  }\n\n  var wh = this._getWatchHelpers(path, depth);\n  if (!wh.hasGlob && priorWh) {\n    wh.hasGlob = priorWh.hasGlob;\n    wh.globFilter = priorWh.globFilter;\n    wh.filterPath = priorWh.filterPath;\n    wh.filterDir = priorWh.filterDir;\n  }\n\n  // evaluate what is at the path we're being asked to watch\n  fs[wh.statMethod](wh.watchPath, function(error, stats) {\n    if (this._handleError(error)) return callback(null, path);\n    if (this._isIgnored(wh.watchPath, stats)) {\n      ready();\n      return callback(null, false);\n    }\n\n    var initDir = function(dir, target) {\n      return this._handleDir(dir, stats, initialAdd, depth, target, wh, ready);\n    }.bind(this);\n\n    var closer;\n    if (stats.isDirectory()) {\n      closer = initDir(wh.watchPath, target);\n    } else if (stats.isSymbolicLink()) {\n      var parent = sysPath.dirname(wh.watchPath);\n      this._getWatchedDir(parent).add(wh.watchPath);\n      this._emit('add', wh.watchPath, stats);\n      closer = initDir(parent, path);\n\n      // preserve this symlink's target path\n      fs.realpath(path, function(error, targetPath) {\n        this._symlinkPaths[sysPath.resolve(path)] = targetPath;\n        ready();\n      }.bind(this));\n    } else {\n      closer = this._handleFile(wh.watchPath, stats, initialAdd, ready);\n    }\n\n    if (closer) this._closers[path] = closer;\n    callback(null, false);\n  }.bind(this));\n};\n\nmodule.exports = NodeFsHandler;\n"]},"metadata":{},"sourceType":"script"}