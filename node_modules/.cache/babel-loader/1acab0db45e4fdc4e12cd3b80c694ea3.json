{"ast":null,"code":"'use strict';\n\nvar fs = require('fs');\n\nvar sysPath = require('path');\n\nvar readdirp = require('readdirp');\n\nvar isBinaryPath = require('is-binary-path'); // fs.watch helpers\n// object to hold per-process fs.watch instances\n// (may be shared across chokidar FSWatcher instances)\n\n\nvar FsWatchInstances = Object.create(null); // Private function: Instantiates the fs.watch interface\n// * path       - string, path to be watched\n// * options    - object, options to be passed to fs.watch\n// * listener   - function, main event handler\n// * errHandler - function, handler which emits info about errors\n// * emitRaw    - function, handler which emits raw event data\n// Returns new fsevents instance\n\nfunction createFsWatchInstance(path, options, listener, errHandler, emitRaw) {\n  var handleEvent = function (rawEvent, evPath) {\n    listener(path);\n    emitRaw(rawEvent, evPath, {\n      watchedPath: path\n    }); // emit based on events occurring for files from a directory's watcher in\n    // case the file's watcher misses it (and rely on throttling to de-dupe)\n\n    if (evPath && path !== evPath) {\n      fsWatchBroadcast(sysPath.resolve(path, evPath), 'listeners', sysPath.join(path, evPath));\n    }\n  };\n\n  try {\n    return fs.watch(path, options, handleEvent);\n  } catch (error) {\n    errHandler(error);\n  }\n} // Private function: Helper for passing fs.watch event data to a\n// collection of listeners\n// * fullPath   - string, absolute path bound to the fs.watch instance\n// * type       - string, listener type\n// * val[1..3]  - arguments to be passed to listeners\n// Returns nothing\n\n\nfunction fsWatchBroadcast(fullPath, type, val1, val2, val3) {\n  if (!FsWatchInstances[fullPath]) return;\n  FsWatchInstances[fullPath][type].forEach(function (listener) {\n    listener(val1, val2, val3);\n  });\n} // Private function: Instantiates the fs.watch interface or binds listeners\n// to an existing one covering the same file system entry\n// * path       - string, path to be watched\n// * fullPath   - string, absolute path\n// * options    - object, options to be passed to fs.watch\n// * handlers   - object, container for event listener functions\n// Returns close function\n\n\nfunction setFsWatchListener(path, fullPath, options, handlers) {\n  var listener = handlers.listener;\n  var errHandler = handlers.errHandler;\n  var rawEmitter = handlers.rawEmitter;\n  var container = FsWatchInstances[fullPath];\n  var watcher;\n\n  if (!options.persistent) {\n    watcher = createFsWatchInstance(path, options, listener, errHandler, rawEmitter);\n    return watcher.close.bind(watcher);\n  }\n\n  if (!container) {\n    watcher = createFsWatchInstance(path, options, fsWatchBroadcast.bind(null, fullPath, 'listeners'), errHandler, // no need to use broadcast here\n    fsWatchBroadcast.bind(null, fullPath, 'rawEmitters'));\n    if (!watcher) return;\n    var broadcastErr = fsWatchBroadcast.bind(null, fullPath, 'errHandlers');\n    watcher.on('error', function (error) {\n      container.watcherUnusable = true; // documented since Node 10.4.1\n      // Workaround for https://github.com/joyent/node/issues/4337\n\n      if (process.platform === 'win32' && error.code === 'EPERM') {\n        fs.open(path, 'r', function (err, fd) {\n          if (!err) fs.close(fd, function (err) {\n            if (!err) broadcastErr(error);\n          });\n        });\n      } else {\n        broadcastErr(error);\n      }\n    });\n    container = FsWatchInstances[fullPath] = {\n      listeners: [listener],\n      errHandlers: [errHandler],\n      rawEmitters: [rawEmitter],\n      watcher: watcher\n    };\n  } else {\n    container.listeners.push(listener);\n    container.errHandlers.push(errHandler);\n    container.rawEmitters.push(rawEmitter);\n  }\n\n  var listenerIndex = container.listeners.length - 1; // removes this instance's listeners and closes the underlying fs.watch\n  // instance if there are no more listeners left\n\n  return function close() {\n    delete container.listeners[listenerIndex];\n    delete container.errHandlers[listenerIndex];\n    delete container.rawEmitters[listenerIndex];\n\n    if (!Object.keys(container.listeners).length) {\n      if (!container.watcherUnusable) {\n        // check to protect against issue #730\n        container.watcher.close();\n      }\n\n      delete FsWatchInstances[fullPath];\n    }\n  };\n} // fs.watchFile helpers\n// object to hold per-process fs.watchFile instances\n// (may be shared across chokidar FSWatcher instances)\n\n\nvar FsWatchFileInstances = Object.create(null); // Private function: Instantiates the fs.watchFile interface or binds listeners\n// to an existing one covering the same file system entry\n// * path       - string, path to be watched\n// * fullPath   - string, absolute path\n// * options    - object, options to be passed to fs.watchFile\n// * handlers   - object, container for event listener functions\n// Returns close function\n\nfunction setFsWatchFileListener(path, fullPath, options, handlers) {\n  var listener = handlers.listener;\n  var rawEmitter = handlers.rawEmitter;\n  var container = FsWatchFileInstances[fullPath];\n  var listeners = [];\n  var rawEmitters = [];\n\n  if (container && (container.options.persistent < options.persistent || container.options.interval > options.interval)) {\n    // \"Upgrade\" the watcher to persistence or a quicker interval.\n    // This creates some unlikely edge case issues if the user mixes\n    // settings in a very weird way, but solving for those cases\n    // doesn't seem worthwhile for the added complexity.\n    listeners = container.listeners;\n    rawEmitters = container.rawEmitters;\n    fs.unwatchFile(fullPath);\n    container = false;\n  }\n\n  if (!container) {\n    listeners.push(listener);\n    rawEmitters.push(rawEmitter);\n    container = FsWatchFileInstances[fullPath] = {\n      listeners: listeners,\n      rawEmitters: rawEmitters,\n      options: options,\n      watcher: fs.watchFile(fullPath, options, function (curr, prev) {\n        container.rawEmitters.forEach(function (rawEmitter) {\n          rawEmitter('change', fullPath, {\n            curr: curr,\n            prev: prev\n          });\n        });\n        var currmtime = curr.mtime.getTime();\n\n        if (curr.size !== prev.size || currmtime > prev.mtime.getTime() || currmtime === 0) {\n          container.listeners.forEach(function (listener) {\n            listener(path, curr);\n          });\n        }\n      })\n    };\n  } else {\n    container.listeners.push(listener);\n    container.rawEmitters.push(rawEmitter);\n  }\n\n  var listenerIndex = container.listeners.length - 1; // removes this instance's listeners and closes the underlying fs.watchFile\n  // instance if there are no more listeners left\n\n  return function close() {\n    delete container.listeners[listenerIndex];\n    delete container.rawEmitters[listenerIndex];\n\n    if (!Object.keys(container.listeners).length) {\n      fs.unwatchFile(fullPath);\n      delete FsWatchFileInstances[fullPath];\n    }\n  };\n} // fake constructor for attaching nodefs-specific prototype methods that\n// will be copied to FSWatcher's prototype\n\n\nfunction NodeFsHandler() {} // Private method: Watch file for changes with fs.watchFile or fs.watch.\n// * path     - string, path to file or directory.\n// * listener - function, to be executed on fs change.\n// Returns close function for the watcher instance\n\n\nNodeFsHandler.prototype._watchWithNodeFs = function (path, listener) {\n  var directory = sysPath.dirname(path);\n  var basename = sysPath.basename(path);\n\n  var parent = this._getWatchedDir(directory);\n\n  parent.add(basename);\n  var absolutePath = sysPath.resolve(path);\n  var options = {\n    persistent: this.options.persistent\n  };\n  if (!listener) listener = Function.prototype; // empty function\n\n  var closer;\n\n  if (this.options.usePolling) {\n    options.interval = this.enableBinaryInterval && isBinaryPath(basename) ? this.options.binaryInterval : this.options.interval;\n    closer = setFsWatchFileListener(path, absolutePath, options, {\n      listener: listener,\n      rawEmitter: this.emit.bind(this, 'raw')\n    });\n  } else {\n    closer = setFsWatchListener(path, absolutePath, options, {\n      listener: listener,\n      errHandler: this._handleError.bind(this),\n      rawEmitter: this.emit.bind(this, 'raw')\n    });\n  }\n\n  return closer;\n}; // Private method: Watch a file and emit add event if warranted\n// * file       - string, the file's path\n// * stats      - object, result of fs.stat\n// * initialAdd - boolean, was the file added at watch instantiation?\n// * callback   - function, called when done processing as a newly seen file\n// Returns close function for the watcher instance\n\n\nNodeFsHandler.prototype._handleFile = function (file, stats, initialAdd, callback) {\n  var dirname = sysPath.dirname(file);\n  var basename = sysPath.basename(file);\n\n  var parent = this._getWatchedDir(dirname); // stats is always present\n\n\n  var prevStats = stats; // if the file is already being watched, do nothing\n\n  if (parent.has(basename)) return callback(); // kick off the watcher\n\n  var closer = this._watchWithNodeFs(file, function (path, newStats) {\n    if (!this._throttle('watch', file, 5)) return;\n\n    if (!newStats || newStats && newStats.mtime.getTime() === 0) {\n      fs.stat(file, function (error, newStats) {\n        // Fix issues where mtime is null but file is still present\n        if (error) {\n          this._remove(dirname, basename);\n        } else {\n          // Check that change event was not fired because of changed only accessTime.\n          var at = newStats.atime.getTime();\n          var mt = newStats.mtime.getTime();\n\n          if (!at || at <= mt || mt !== prevStats.mtime.getTime()) {\n            this._emit('change', file, newStats);\n          }\n\n          prevStats = newStats;\n        }\n      }.bind(this)); // add is about to be emitted if file not already tracked in parent\n    } else if (parent.has(basename)) {\n      // Check that change event was not fired because of changed only accessTime.\n      var at = newStats.atime.getTime();\n      var mt = newStats.mtime.getTime();\n\n      if (!at || at <= mt || mt !== prevStats.mtime.getTime()) {\n        this._emit('change', file, newStats);\n      }\n\n      prevStats = newStats;\n    }\n  }.bind(this)); // emit an add event if we're supposed to\n\n\n  if (!(initialAdd && this.options.ignoreInitial)) {\n    if (!this._throttle('add', file, 0)) return;\n\n    this._emit('add', file, stats);\n  }\n\n  if (callback) callback();\n  return closer;\n}; // Private method: Handle symlinks encountered while reading a dir\n// * entry      - object, entry object returned by readdirp\n// * directory  - string, path of the directory being read\n// * path       - string, path of this item\n// * item       - string, basename of this item\n// Returns true if no more processing is needed for this entry.\n\n\nNodeFsHandler.prototype._handleSymlink = function (entry, directory, path, item) {\n  var full = entry.fullPath;\n\n  var dir = this._getWatchedDir(directory);\n\n  if (!this.options.followSymlinks) {\n    // watch symlink directly (don't follow) and detect changes\n    this._readyCount++;\n    fs.realpath(path, function (error, linkPath) {\n      if (dir.has(item)) {\n        if (this._symlinkPaths[full] !== linkPath) {\n          this._symlinkPaths[full] = linkPath;\n\n          this._emit('change', path, entry.stat);\n        }\n      } else {\n        dir.add(item);\n        this._symlinkPaths[full] = linkPath;\n\n        this._emit('add', path, entry.stat);\n      }\n\n      this._emitReady();\n    }.bind(this));\n    return true;\n  } // don't follow the same symlink more than once\n\n\n  if (this._symlinkPaths[full]) return true;else this._symlinkPaths[full] = true;\n}; // Private method: Read directory to add / remove files from `@watched` list\n// and re-read it on change.\n// * dir        - string, fs path.\n// * stats      - object, result of fs.stat\n// * initialAdd - boolean, was the file added at watch instantiation?\n// * depth      - int, depth relative to user-supplied path\n// * target     - string, child path actually targeted for watch\n// * wh         - object, common watch helpers for this path\n// * callback   - function, called when dir scan is complete\n// Returns close function for the watcher instance\n\n\nNodeFsHandler.prototype._handleDir = function (dir, stats, initialAdd, depth, target, wh, callback) {\n  var parentDir = this._getWatchedDir(sysPath.dirname(dir));\n\n  var tracked = parentDir.has(sysPath.basename(dir));\n\n  if (!(initialAdd && this.options.ignoreInitial) && !target && !tracked) {\n    if (!wh.hasGlob || wh.globFilter(dir)) this._emit('addDir', dir, stats);\n  } // ensure dir is tracked (harmless if redundant)\n\n\n  parentDir.add(sysPath.basename(dir));\n\n  this._getWatchedDir(dir);\n\n  var read = function (directory, initialAdd, done) {\n    // Normalize the directory name on Windows\n    directory = sysPath.join(directory, '');\n\n    if (!wh.hasGlob) {\n      var throttler = this._throttle('readdir', directory, 1000);\n\n      if (!throttler) return;\n    }\n\n    var previous = this._getWatchedDir(wh.path);\n\n    var current = [];\n    readdirp({\n      root: directory,\n      entryType: 'all',\n      fileFilter: wh.filterPath,\n      directoryFilter: wh.filterDir,\n      depth: 0,\n      lstat: true\n    }).on('data', function (entry) {\n      var item = entry.path;\n      var path = sysPath.join(directory, item);\n      current.push(item);\n      if (entry.stat.isSymbolicLink() && this._handleSymlink(entry, directory, path, item)) return; // Files that present in current directory snapshot\n      // but absent in previous are added to watch list and\n      // emit `add` event.\n\n      if (item === target || !target && !previous.has(item)) {\n        this._readyCount++; // ensure relativeness of path is preserved in case of watcher reuse\n\n        path = sysPath.join(dir, sysPath.relative(dir, path));\n\n        this._addToNodeFs(path, initialAdd, wh, depth + 1);\n      }\n    }.bind(this)).on('end', function () {\n      var wasThrottled = throttler ? throttler.clear() : false;\n      if (done) done(); // Files that absent in current directory snapshot\n      // but present in previous emit `remove` event\n      // and are removed from @watched[directory].\n\n      previous.children().filter(function (item) {\n        return item !== directory && current.indexOf(item) === -1 && ( // in case of intersecting globs;\n        // a path may have been filtered out of this readdir, but\n        // shouldn't be removed because it matches a different glob\n        !wh.hasGlob || wh.filterPath({\n          fullPath: sysPath.resolve(directory, item)\n        }));\n      }).forEach(function (item) {\n        this._remove(directory, item);\n      }, this); // one more time for any missed in case changes came in extremely quickly\n\n      if (wasThrottled) read(directory, false);\n    }.bind(this)).on('error', this._handleError.bind(this));\n  }.bind(this);\n\n  var closer;\n\n  if (this.options.depth == null || depth <= this.options.depth) {\n    if (!target) read(dir, initialAdd, callback);\n    closer = this._watchWithNodeFs(dir, function (dirPath, stats) {\n      // if current directory is removed, do nothing\n      if (stats && stats.mtime.getTime() === 0) return;\n      read(dirPath, false);\n    });\n  } else {\n    callback();\n  }\n\n  return closer;\n}; // Private method: Handle added file, directory, or glob pattern.\n// Delegates call to _handleFile / _handleDir after checks.\n// * path       - string, path to file or directory.\n// * initialAdd - boolean, was the file added at watch instantiation?\n// * depth      - int, depth relative to user-supplied path\n// * target     - string, child path actually targeted for watch\n// * callback   - function, indicates whether the path was found or not\n// Returns nothing\n\n\nNodeFsHandler.prototype._addToNodeFs = function (path, initialAdd, priorWh, depth, target, callback) {\n  if (!callback) callback = Function.prototype;\n  var ready = this._emitReady;\n\n  if (this._isIgnored(path) || this.closed) {\n    ready();\n    return callback(null, false);\n  }\n\n  var wh = this._getWatchHelpers(path, depth);\n\n  if (!wh.hasGlob && priorWh) {\n    wh.hasGlob = priorWh.hasGlob;\n    wh.globFilter = priorWh.globFilter;\n    wh.filterPath = priorWh.filterPath;\n    wh.filterDir = priorWh.filterDir;\n  } // evaluate what is at the path we're being asked to watch\n\n\n  fs[wh.statMethod](wh.watchPath, function (error, stats) {\n    if (this._handleError(error)) return callback(null, path);\n\n    if (this._isIgnored(wh.watchPath, stats)) {\n      ready();\n      return callback(null, false);\n    }\n\n    var initDir = function (dir, target) {\n      return this._handleDir(dir, stats, initialAdd, depth, target, wh, ready);\n    }.bind(this);\n\n    var closer;\n\n    if (stats.isDirectory()) {\n      closer = initDir(wh.watchPath, target);\n    } else if (stats.isSymbolicLink()) {\n      var parent = sysPath.dirname(wh.watchPath);\n\n      this._getWatchedDir(parent).add(wh.watchPath);\n\n      this._emit('add', wh.watchPath, stats);\n\n      closer = initDir(parent, path); // preserve this symlink's target path\n\n      fs.realpath(path, function (error, targetPath) {\n        this._symlinkPaths[sysPath.resolve(path)] = targetPath;\n        ready();\n      }.bind(this));\n    } else {\n      closer = this._handleFile(wh.watchPath, stats, initialAdd, ready);\n    }\n\n    if (closer) {\n      this._closers[path] = this._closers[path] || [];\n\n      this._closers[path].push(closer);\n    }\n\n    callback(null, false);\n  }.bind(this));\n};\n\nmodule.exports = NodeFsHandler;","map":{"version":3,"sources":["/home/yanxiaoyang/react-project/PersonalWebsiteTest/node_modules/chokidar/lib/nodefs-handler.js"],"names":["fs","require","sysPath","readdirp","isBinaryPath","FsWatchInstances","Object","create","createFsWatchInstance","path","options","listener","errHandler","emitRaw","handleEvent","rawEvent","evPath","watchedPath","fsWatchBroadcast","resolve","join","watch","error","fullPath","type","val1","val2","val3","forEach","setFsWatchListener","handlers","rawEmitter","container","watcher","persistent","close","bind","broadcastErr","on","watcherUnusable","process","platform","code","open","err","fd","listeners","errHandlers","rawEmitters","push","listenerIndex","length","keys","FsWatchFileInstances","setFsWatchFileListener","interval","unwatchFile","watchFile","curr","prev","currmtime","mtime","getTime","size","NodeFsHandler","prototype","_watchWithNodeFs","directory","dirname","basename","parent","_getWatchedDir","add","absolutePath","Function","closer","usePolling","enableBinaryInterval","binaryInterval","emit","_handleError","_handleFile","file","stats","initialAdd","callback","prevStats","has","newStats","_throttle","stat","_remove","at","atime","mt","_emit","ignoreInitial","_handleSymlink","entry","item","full","dir","followSymlinks","_readyCount","realpath","linkPath","_symlinkPaths","_emitReady","_handleDir","depth","target","wh","parentDir","tracked","hasGlob","globFilter","read","done","throttler","previous","current","root","entryType","fileFilter","filterPath","directoryFilter","filterDir","lstat","isSymbolicLink","relative","_addToNodeFs","wasThrottled","clear","children","filter","indexOf","dirPath","priorWh","ready","_isIgnored","closed","_getWatchHelpers","statMethod","watchPath","initDir","isDirectory","targetPath","_closers","module","exports"],"mappings":"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","sourcesContent":["'use strict';\n\nvar fs = require('fs');\nvar sysPath = require('path');\nvar readdirp = require('readdirp');\nvar isBinaryPath = require('is-binary-path');\n\n// fs.watch helpers\n\n// object to hold per-process fs.watch instances\n// (may be shared across chokidar FSWatcher instances)\nvar FsWatchInstances = Object.create(null);\n\n\n// Private function: Instantiates the fs.watch interface\n\n// * path       - string, path to be watched\n// * options    - object, options to be passed to fs.watch\n// * listener   - function, main event handler\n// * errHandler - function, handler which emits info about errors\n// * emitRaw    - function, handler which emits raw event data\n\n// Returns new fsevents instance\nfunction createFsWatchInstance(path, options, listener, errHandler, emitRaw) {\n  var handleEvent = function(rawEvent, evPath) {\n    listener(path);\n    emitRaw(rawEvent, evPath, {watchedPath: path});\n\n    // emit based on events occurring for files from a directory's watcher in\n    // case the file's watcher misses it (and rely on throttling to de-dupe)\n    if (evPath && path !== evPath) {\n      fsWatchBroadcast(\n        sysPath.resolve(path, evPath), 'listeners', sysPath.join(path, evPath)\n      );\n    }\n  };\n  try {\n    return fs.watch(path, options, handleEvent);\n  } catch (error) {\n    errHandler(error);\n  }\n}\n\n// Private function: Helper for passing fs.watch event data to a\n// collection of listeners\n\n// * fullPath   - string, absolute path bound to the fs.watch instance\n// * type       - string, listener type\n// * val[1..3]  - arguments to be passed to listeners\n\n// Returns nothing\nfunction fsWatchBroadcast(fullPath, type, val1, val2, val3) {\n  if (!FsWatchInstances[fullPath]) return;\n  FsWatchInstances[fullPath][type].forEach(function(listener) {\n    listener(val1, val2, val3);\n  });\n}\n\n// Private function: Instantiates the fs.watch interface or binds listeners\n// to an existing one covering the same file system entry\n\n// * path       - string, path to be watched\n// * fullPath   - string, absolute path\n// * options    - object, options to be passed to fs.watch\n// * handlers   - object, container for event listener functions\n\n// Returns close function\nfunction setFsWatchListener(path, fullPath, options, handlers) {\n  var listener = handlers.listener;\n  var errHandler = handlers.errHandler;\n  var rawEmitter = handlers.rawEmitter;\n  var container = FsWatchInstances[fullPath];\n  var watcher;\n  if (!options.persistent) {\n    watcher = createFsWatchInstance(\n      path, options, listener, errHandler, rawEmitter\n    );\n    return watcher.close.bind(watcher);\n  }\n  if (!container) {\n    watcher = createFsWatchInstance(\n      path,\n      options,\n      fsWatchBroadcast.bind(null, fullPath, 'listeners'),\n      errHandler, // no need to use broadcast here\n      fsWatchBroadcast.bind(null, fullPath, 'rawEmitters')\n    );\n    if (!watcher) return;\n    var broadcastErr = fsWatchBroadcast.bind(null, fullPath, 'errHandlers');\n    watcher.on('error', function(error) {\n      container.watcherUnusable = true; // documented since Node 10.4.1\n      // Workaround for https://github.com/joyent/node/issues/4337\n      if (process.platform === 'win32' && error.code === 'EPERM') {\n        fs.open(path, 'r', function(err, fd) {\n          if (!err) fs.close(fd, function(err) {\n            if (!err) broadcastErr(error);\n          });\n        });\n      } else {\n        broadcastErr(error);\n      }\n    });\n    container = FsWatchInstances[fullPath] = {\n      listeners: [listener],\n      errHandlers: [errHandler],\n      rawEmitters: [rawEmitter],\n      watcher: watcher\n    };\n  } else {\n    container.listeners.push(listener);\n    container.errHandlers.push(errHandler);\n    container.rawEmitters.push(rawEmitter);\n  }\n  var listenerIndex = container.listeners.length - 1;\n\n  // removes this instance's listeners and closes the underlying fs.watch\n  // instance if there are no more listeners left\n  return function close() {\n    delete container.listeners[listenerIndex];\n    delete container.errHandlers[listenerIndex];\n    delete container.rawEmitters[listenerIndex];\n    if (!Object.keys(container.listeners).length) {\n      if (!container.watcherUnusable) { // check to protect against issue #730\n        container.watcher.close();\n      }\n      delete FsWatchInstances[fullPath];\n    }\n  };\n}\n\n// fs.watchFile helpers\n\n// object to hold per-process fs.watchFile instances\n// (may be shared across chokidar FSWatcher instances)\nvar FsWatchFileInstances = Object.create(null);\n\n// Private function: Instantiates the fs.watchFile interface or binds listeners\n// to an existing one covering the same file system entry\n\n// * path       - string, path to be watched\n// * fullPath   - string, absolute path\n// * options    - object, options to be passed to fs.watchFile\n// * handlers   - object, container for event listener functions\n\n// Returns close function\nfunction setFsWatchFileListener(path, fullPath, options, handlers) {\n  var listener = handlers.listener;\n  var rawEmitter = handlers.rawEmitter;\n  var container = FsWatchFileInstances[fullPath];\n  var listeners = [];\n  var rawEmitters = [];\n  if (\n    container && (\n      container.options.persistent < options.persistent ||\n      container.options.interval > options.interval\n    )\n  ) {\n    // \"Upgrade\" the watcher to persistence or a quicker interval.\n    // This creates some unlikely edge case issues if the user mixes\n    // settings in a very weird way, but solving for those cases\n    // doesn't seem worthwhile for the added complexity.\n    listeners = container.listeners;\n    rawEmitters = container.rawEmitters;\n    fs.unwatchFile(fullPath);\n    container = false;\n  }\n  if (!container) {\n    listeners.push(listener);\n    rawEmitters.push(rawEmitter);\n    container = FsWatchFileInstances[fullPath] = {\n      listeners: listeners,\n      rawEmitters: rawEmitters,\n      options: options,\n      watcher: fs.watchFile(fullPath, options, function(curr, prev) {\n        container.rawEmitters.forEach(function(rawEmitter) {\n          rawEmitter('change', fullPath, {curr: curr, prev: prev});\n        });\n        var currmtime = curr.mtime.getTime();\n        if (curr.size !== prev.size || currmtime > prev.mtime.getTime() || currmtime === 0) {\n          container.listeners.forEach(function(listener) {\n            listener(path, curr);\n          });\n        }\n      })\n    };\n  } else {\n    container.listeners.push(listener);\n    container.rawEmitters.push(rawEmitter);\n  }\n  var listenerIndex = container.listeners.length - 1;\n\n  // removes this instance's listeners and closes the underlying fs.watchFile\n  // instance if there are no more listeners left\n  return function close() {\n    delete container.listeners[listenerIndex];\n    delete container.rawEmitters[listenerIndex];\n    if (!Object.keys(container.listeners).length) {\n      fs.unwatchFile(fullPath);\n      delete FsWatchFileInstances[fullPath];\n    }\n  };\n}\n\n// fake constructor for attaching nodefs-specific prototype methods that\n// will be copied to FSWatcher's prototype\nfunction NodeFsHandler() {}\n\n// Private method: Watch file for changes with fs.watchFile or fs.watch.\n\n// * path     - string, path to file or directory.\n// * listener - function, to be executed on fs change.\n\n// Returns close function for the watcher instance\nNodeFsHandler.prototype._watchWithNodeFs =\nfunction(path, listener) {\n  var directory = sysPath.dirname(path);\n  var basename = sysPath.basename(path);\n  var parent = this._getWatchedDir(directory);\n  parent.add(basename);\n  var absolutePath = sysPath.resolve(path);\n  var options = {persistent: this.options.persistent};\n  if (!listener) listener = Function.prototype; // empty function\n\n  var closer;\n  if (this.options.usePolling) {\n    options.interval = this.enableBinaryInterval && isBinaryPath(basename) ?\n      this.options.binaryInterval : this.options.interval;\n    closer = setFsWatchFileListener(path, absolutePath, options, {\n      listener: listener,\n      rawEmitter: this.emit.bind(this, 'raw')\n    });\n  } else {\n    closer = setFsWatchListener(path, absolutePath, options, {\n      listener: listener,\n      errHandler: this._handleError.bind(this),\n      rawEmitter: this.emit.bind(this, 'raw')\n    });\n  }\n  return closer;\n};\n\n// Private method: Watch a file and emit add event if warranted\n\n// * file       - string, the file's path\n// * stats      - object, result of fs.stat\n// * initialAdd - boolean, was the file added at watch instantiation?\n// * callback   - function, called when done processing as a newly seen file\n\n// Returns close function for the watcher instance\nNodeFsHandler.prototype._handleFile =\nfunction(file, stats, initialAdd, callback) {\n  var dirname = sysPath.dirname(file);\n  var basename = sysPath.basename(file);\n  var parent = this._getWatchedDir(dirname);\n  // stats is always present\n  var prevStats = stats;\n\n  // if the file is already being watched, do nothing\n  if (parent.has(basename)) return callback();\n\n  // kick off the watcher\n  var closer = this._watchWithNodeFs(file, function(path, newStats) {\n    if (!this._throttle('watch', file, 5)) return;\n    if (!newStats || newStats && newStats.mtime.getTime() === 0) {\n      fs.stat(file, function(error, newStats) {\n        // Fix issues where mtime is null but file is still present\n        if (error) {\n          this._remove(dirname, basename);\n        } else {\n          // Check that change event was not fired because of changed only accessTime.\n          var at = newStats.atime.getTime();\n          var mt = newStats.mtime.getTime();\n          if (!at || at <= mt || mt !== prevStats.mtime.getTime()) {\n            this._emit('change', file, newStats);\n          }\n          prevStats = newStats;\n        }\n      }.bind(this));\n    // add is about to be emitted if file not already tracked in parent\n    } else if (parent.has(basename)) {\n      // Check that change event was not fired because of changed only accessTime.\n      var at = newStats.atime.getTime();\n      var mt = newStats.mtime.getTime();\n      if (!at || at <= mt ||  mt !== prevStats.mtime.getTime()) {\n        this._emit('change', file, newStats);\n      }\n      prevStats = newStats;\n    }\n  }.bind(this));\n\n  // emit an add event if we're supposed to\n  if (!(initialAdd && this.options.ignoreInitial)) {\n    if (!this._throttle('add', file, 0)) return;\n    this._emit('add', file, stats);\n  }\n\n  if (callback) callback();\n  return closer;\n};\n\n// Private method: Handle symlinks encountered while reading a dir\n\n// * entry      - object, entry object returned by readdirp\n// * directory  - string, path of the directory being read\n// * path       - string, path of this item\n// * item       - string, basename of this item\n\n// Returns true if no more processing is needed for this entry.\nNodeFsHandler.prototype._handleSymlink =\nfunction(entry, directory, path, item) {\n  var full = entry.fullPath;\n  var dir = this._getWatchedDir(directory);\n\n  if (!this.options.followSymlinks) {\n    // watch symlink directly (don't follow) and detect changes\n    this._readyCount++;\n    fs.realpath(path, function(error, linkPath) {\n      if (dir.has(item)) {\n        if (this._symlinkPaths[full] !== linkPath) {\n          this._symlinkPaths[full] = linkPath;\n          this._emit('change', path, entry.stat);\n        }\n      } else {\n        dir.add(item);\n        this._symlinkPaths[full] = linkPath;\n        this._emit('add', path, entry.stat);\n      }\n      this._emitReady();\n    }.bind(this));\n    return true;\n  }\n\n  // don't follow the same symlink more than once\n  if (this._symlinkPaths[full]) return true;\n  else this._symlinkPaths[full] = true;\n};\n\n// Private method: Read directory to add / remove files from `@watched` list\n// and re-read it on change.\n\n// * dir        - string, fs path.\n// * stats      - object, result of fs.stat\n// * initialAdd - boolean, was the file added at watch instantiation?\n// * depth      - int, depth relative to user-supplied path\n// * target     - string, child path actually targeted for watch\n// * wh         - object, common watch helpers for this path\n// * callback   - function, called when dir scan is complete\n\n// Returns close function for the watcher instance\nNodeFsHandler.prototype._handleDir =\nfunction(dir, stats, initialAdd, depth, target, wh, callback) {\n  var parentDir = this._getWatchedDir(sysPath.dirname(dir));\n  var tracked = parentDir.has(sysPath.basename(dir));\n  if (!(initialAdd && this.options.ignoreInitial) && !target && !tracked) {\n    if (!wh.hasGlob || wh.globFilter(dir)) this._emit('addDir', dir, stats);\n  }\n\n  // ensure dir is tracked (harmless if redundant)\n  parentDir.add(sysPath.basename(dir));\n  this._getWatchedDir(dir);\n\n  var read = function(directory, initialAdd, done) {\n    // Normalize the directory name on Windows\n    directory = sysPath.join(directory, '');\n\n    if (!wh.hasGlob) {\n      var throttler = this._throttle('readdir', directory, 1000);\n      if (!throttler) return;\n    }\n\n    var previous = this._getWatchedDir(wh.path);\n    var current = [];\n\n    readdirp({\n      root: directory,\n      entryType: 'all',\n      fileFilter: wh.filterPath,\n      directoryFilter: wh.filterDir,\n      depth: 0,\n      lstat: true\n    }).on('data', function(entry) {\n      var item = entry.path;\n      var path = sysPath.join(directory, item);\n      current.push(item);\n\n      if (entry.stat.isSymbolicLink() &&\n        this._handleSymlink(entry, directory, path, item)) return;\n\n      // Files that present in current directory snapshot\n      // but absent in previous are added to watch list and\n      // emit `add` event.\n      if (item === target || !target && !previous.has(item)) {\n        this._readyCount++;\n\n        // ensure relativeness of path is preserved in case of watcher reuse\n        path = sysPath.join(dir, sysPath.relative(dir, path));\n\n        this._addToNodeFs(path, initialAdd, wh, depth + 1);\n      }\n    }.bind(this)).on('end', function() {\n      var wasThrottled = throttler ? throttler.clear() : false;\n      if (done) done();\n\n      // Files that absent in current directory snapshot\n      // but present in previous emit `remove` event\n      // and are removed from @watched[directory].\n      previous.children().filter(function(item) {\n        return item !== directory &&\n          current.indexOf(item) === -1 &&\n          // in case of intersecting globs;\n          // a path may have been filtered out of this readdir, but\n          // shouldn't be removed because it matches a different glob\n          (!wh.hasGlob || wh.filterPath({\n            fullPath: sysPath.resolve(directory, item)\n          }));\n      }).forEach(function(item) {\n        this._remove(directory, item);\n      }, this);\n\n      // one more time for any missed in case changes came in extremely quickly\n      if (wasThrottled) read(directory, false);\n    }.bind(this)).on('error', this._handleError.bind(this));\n  }.bind(this);\n\n  var closer;\n\n  if (this.options.depth == null || depth <= this.options.depth) {\n    if (!target) read(dir, initialAdd, callback);\n    closer = this._watchWithNodeFs(dir, function(dirPath, stats) {\n      // if current directory is removed, do nothing\n      if (stats && stats.mtime.getTime() === 0) return;\n\n      read(dirPath, false);\n    });\n  } else {\n    callback();\n  }\n  return closer;\n};\n\n// Private method: Handle added file, directory, or glob pattern.\n// Delegates call to _handleFile / _handleDir after checks.\n\n// * path       - string, path to file or directory.\n// * initialAdd - boolean, was the file added at watch instantiation?\n// * depth      - int, depth relative to user-supplied path\n// * target     - string, child path actually targeted for watch\n// * callback   - function, indicates whether the path was found or not\n\n// Returns nothing\nNodeFsHandler.prototype._addToNodeFs =\nfunction(path, initialAdd, priorWh, depth, target, callback) {\n  if (!callback) callback = Function.prototype;\n  var ready = this._emitReady;\n  if (this._isIgnored(path) || this.closed) {\n    ready();\n    return callback(null, false);\n  }\n\n  var wh = this._getWatchHelpers(path, depth);\n  if (!wh.hasGlob && priorWh) {\n    wh.hasGlob = priorWh.hasGlob;\n    wh.globFilter = priorWh.globFilter;\n    wh.filterPath = priorWh.filterPath;\n    wh.filterDir = priorWh.filterDir;\n  }\n\n  // evaluate what is at the path we're being asked to watch\n  fs[wh.statMethod](wh.watchPath, function(error, stats) {\n    if (this._handleError(error)) return callback(null, path);\n    if (this._isIgnored(wh.watchPath, stats)) {\n      ready();\n      return callback(null, false);\n    }\n\n    var initDir = function(dir, target) {\n      return this._handleDir(dir, stats, initialAdd, depth, target, wh, ready);\n    }.bind(this);\n\n    var closer;\n    if (stats.isDirectory()) {\n      closer = initDir(wh.watchPath, target);\n    } else if (stats.isSymbolicLink()) {\n      var parent = sysPath.dirname(wh.watchPath);\n      this._getWatchedDir(parent).add(wh.watchPath);\n      this._emit('add', wh.watchPath, stats);\n      closer = initDir(parent, path);\n\n      // preserve this symlink's target path\n      fs.realpath(path, function(error, targetPath) {\n        this._symlinkPaths[sysPath.resolve(path)] = targetPath;\n        ready();\n      }.bind(this));\n    } else {\n      closer = this._handleFile(wh.watchPath, stats, initialAdd, ready);\n    }\n\n    if (closer) {\n      this._closers[path] = this._closers[path] || [];\n      this._closers[path].push(closer);\n    }\n    callback(null, false);\n  }.bind(this));\n};\n\nmodule.exports = NodeFsHandler;\n"]},"metadata":{},"sourceType":"script"}