{"ast":null,"code":"const _require = require('child_process'),\n      spawn = _require.spawn;\n\nconst platform = require('os').platform();\n\nconst defaultDir = __dirname + '/bin';\nconst bin = './ngrok' + (platform === 'win32' ? '.exe' : '');\nconst ready = /starting web service.*addr=(\\d+\\.\\d+\\.\\d+\\.\\d+:\\d+)/;\nconst inUse = /address already in use/;\nlet processPromise, activeProcess;\n/*\n\tngrok process runs internal ngrok api\n\tand should be spawned only ONCE\n\t(respawn allowed if it fails or .kill method called)\n*/\n\nasync function getProcess(opts) {\n  if (processPromise) return processPromise;\n\n  try {\n    processPromise = startProcess(opts);\n    return await processPromise;\n  } catch (ex) {\n    processPromise = null;\n    throw ex;\n  }\n}\n\nasync function startProcess(opts) {\n  let dir = defaultDir;\n  const start = ['start', '--none', '--log=stdout'];\n  if (opts.region) start.push('--region=' + opts.region);\n  if (opts.configPath) start.push('--config=' + opts.configPath);\n  if (opts.binPath) dir = opts.binPath(dir);\n  const ngrok = spawn(bin, start, {\n    cwd: dir\n  });\n  let resolve, reject;\n  const apiUrl = new Promise((res, rej) => {\n    resolve = res;\n    reject = rej;\n  });\n  ngrok.stdout.on('data', data => {\n    const msg = data.toString();\n    const addr = msg.match(ready);\n\n    if (opts.onLogEvent) {\n      opts.onLogEvent(msg.trim());\n    }\n\n    if (opts.onStatusChange) {\n      if (msg.match('client session established')) {\n        opts.onStatusChange('connected');\n      } else if (msg.match('session closed, starting reconnect loop')) {\n        opts.onStatusChange('closed');\n      }\n    }\n\n    if (addr) {\n      resolve(`http://${addr[1]}`);\n    } else if (msg.match(inUse)) {\n      reject(new Error(msg.substring(0, 10000)));\n    }\n  });\n  ngrok.stderr.on('data', data => {\n    const msg = data.toString().substring(0, 10000);\n    reject(new Error(msg));\n  });\n  ngrok.on('exit', () => {\n    processPromise = null;\n    activeProcess = null;\n  });\n  process.on('exit', async () => await killProcess());\n\n  try {\n    const url = await apiUrl;\n    activeProcess = ngrok;\n    return url;\n  } catch (ex) {\n    ngrok.kill();\n    throw ex;\n  } finally {\n    // Remove the stdout listeners if nobody is interested in the content.\n    if (!opts.onLogEvent && !opts.onStatusChange) {\n      ngrok.stdout.removeAllListeners('data');\n    }\n\n    ngrok.stderr.removeAllListeners('data');\n  }\n}\n\nfunction killProcess() {\n  if (!activeProcess) return;\n  return new Promise(resolve => {\n    activeProcess.on('exit', () => resolve());\n    activeProcess.kill();\n  });\n}\n/**\n * @param {string | INgrokOptions} optsOrToken\n */\n\n\nasync function setAuthtoken(optsOrToken) {\n  const isOpts = typeof optsOrToken !== 'string';\n  const opts = isOpts ? optsOrToken : {};\n  const token = isOpts ? opts.authtoken : optsOrToken;\n  const authtoken = ['authtoken', token];\n  if (opts.configPath) authtoken.push('--config=' + opts.configPath);\n  let dir = defaultDir;\n  if (opts.binPath) dir = opts.binPath(dir);\n  const ngrok = spawn(bin, authtoken, {\n    cwd: dir\n  });\n  const killed = new Promise((resolve, reject) => {\n    ngrok.stdout.once('data', () => resolve());\n    ngrok.stderr.once('data', () => reject(new Error('cant set authtoken')));\n  });\n\n  try {\n    return await killed;\n  } finally {\n    ngrok.kill();\n  }\n}\n\nmodule.exports = {\n  getProcess,\n  killProcess,\n  setAuthtoken\n};","map":{"version":3,"sources":["/home/yanxiaoyang/react-project/PersonalWebsiteTest/node_modules/ngrok/process.js"],"names":["require","spawn","platform","defaultDir","__dirname","bin","ready","inUse","processPromise","activeProcess","getProcess","opts","startProcess","ex","dir","start","region","push","configPath","binPath","ngrok","cwd","resolve","reject","apiUrl","Promise","res","rej","stdout","on","data","msg","toString","addr","match","onLogEvent","trim","onStatusChange","Error","substring","stderr","process","killProcess","url","kill","removeAllListeners","setAuthtoken","optsOrToken","isOpts","token","authtoken","killed","once","module","exports"],"mappings":"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","sourcesContent":["const { spawn } = require('child_process');\nconst platform = require('os').platform();\n\nconst defaultDir = __dirname + '/bin';\nconst bin = './ngrok' + (platform === 'win32' ? '.exe' : '');\nconst ready = /starting web service.*addr=(\\d+\\.\\d+\\.\\d+\\.\\d+:\\d+)/;\nconst inUse = /address already in use/;\n\nlet processPromise, activeProcess;\n\n/*\n\tngrok process runs internal ngrok api\n\tand should be spawned only ONCE\n\t(respawn allowed if it fails or .kill method called)\n*/\n\nasync function getProcess(opts) {\n\tif (processPromise) return processPromise;\n\ttry {\n\t\tprocessPromise = startProcess(opts);\n\t\treturn await processPromise;\n\t}\n\tcatch(ex) {\n\t\tprocessPromise = null;\n\t\tthrow ex;\n\t}\n}\n\nasync function startProcess (opts) {\n\tlet dir = defaultDir;\n\tconst start = ['start', '--none', '--log=stdout'];\n\tif (opts.region) start.push('--region=' + opts.region);\n\tif (opts.configPath) start.push('--config=' + opts.configPath);\n\tif (opts.binPath) dir = opts.binPath(dir);\n\n\tconst ngrok = spawn(bin, start, {cwd: dir});\n\n\tlet resolve, reject;\n\tconst apiUrl = new Promise((res, rej) => {\n\t\tresolve = res;\n\t\treject = rej;\n\t});\n\n\tngrok.stdout.on('data', data => {\n\t\tconst msg = data.toString();\n\t\tconst addr = msg.match(ready);\n\t\tif (opts.onLogEvent) {\n\t\t\topts.onLogEvent(msg.trim());\n\t\t}\n\t\tif (opts.onStatusChange) {\n\t\t\tif (msg.match('client session established')) {\n\t\t\t\topts.onStatusChange('connected');\n\t\t\t} else if (msg.match('session closed, starting reconnect loop')) {\n\t\t\t\topts.onStatusChange('closed');\n\t\t\t}\n\t\t}\n\t\tif (addr) {\n\t\t\tresolve(`http://${addr[1]}`);\n\t\t} else if (msg.match(inUse)) {\n\t\t\treject(new Error(msg.substring(0, 10000)));\n\t\t}\n\t});\n\n\tngrok.stderr.on('data', data => {\n\t\tconst msg = data.toString().substring(0, 10000);\n\t\treject(new Error(msg));\n\t});\n\n\tngrok.on('exit', () => {\n\t\tprocessPromise = null;\n\t\tactiveProcess = null;\n\t});\n\n\tprocess.on('exit', async () => await killProcess());\n\n\ttry {\n\t\tconst url = await apiUrl;\n\t\tactiveProcess = ngrok;\n\t\treturn url;\n\t}\n\tcatch(ex) {\n\t\tngrok.kill();\n\t\tthrow ex;\n\t}\n\tfinally {\n\t\t// Remove the stdout listeners if nobody is interested in the content.\n\t\tif (!opts.onLogEvent && !opts.onStatusChange) {\n\t\t\tngrok.stdout.removeAllListeners('data');\n\t\t}\n\t\tngrok.stderr.removeAllListeners('data');\n\t}\n}\n\nfunction killProcess ()  {\n\tif (!activeProcess) return;\n\treturn new Promise(resolve => {\n\t\tactiveProcess.on('exit', () => resolve());\n\t\tactiveProcess.kill();\n\t});\n}\n\n/**\n * @param {string | INgrokOptions} optsOrToken\n */\nasync function setAuthtoken (optsOrToken) {\n\tconst isOpts = typeof optsOrToken !== 'string'\n\tconst opts = isOpts ? optsOrToken : {}\n\tconst token = isOpts ? opts.authtoken : optsOrToken\n\n\tconst authtoken = ['authtoken', token];\n\tif (opts.configPath) authtoken.push('--config=' + opts.configPath);\n\n\tlet dir = defaultDir;\n\tif (opts.binPath) dir = opts.binPath(dir)\n\tconst ngrok = spawn(bin, authtoken, {cwd: dir});\n\n\tconst killed = new Promise((resolve, reject) => {\n\t\tngrok.stdout.once('data', () => resolve());\n\t\tngrok.stderr.once('data', () => reject(new Error('cant set authtoken')));\n\t});\n\n\ttry {\n\t\treturn await killed;\n\t}\n\tfinally {\n\t\tngrok.kill();\n\t}\n}\n\nmodule.exports = {\n\tgetProcess,\n\tkillProcess,\n\tsetAuthtoken\n};\n"]},"metadata":{},"sourceType":"script"}